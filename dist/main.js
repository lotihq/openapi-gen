#!/usr/bin/env node
'use strict';

var Stream = require('stream');
var http = require('http');
var Url = require('url');
var zlib = require('zlib');
var Yaml = require('yaml');
var ChildProcess = require('child_process');
var Crypto = require('crypto');
var NFS = require('fs');
var OS = require('os');
var Path3 = require('path');
var readline = require('readline');
var Fs = require('fs/promises');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var Stream__default = /*#__PURE__*/_interopDefault(Stream);
var http__default = /*#__PURE__*/_interopDefault(http);
var Url__namespace = /*#__PURE__*/_interopNamespace(Url);
var zlib__default = /*#__PURE__*/_interopDefault(zlib);
var Yaml__namespace = /*#__PURE__*/_interopNamespace(Yaml);
var ChildProcess__namespace = /*#__PURE__*/_interopNamespace(ChildProcess);
var Crypto__namespace = /*#__PURE__*/_interopNamespace(Crypto);
var NFS__namespace = /*#__PURE__*/_interopNamespace(NFS);
var OS__namespace = /*#__PURE__*/_interopNamespace(OS);
var Path3__namespace = /*#__PURE__*/_interopNamespace(Path3);
var readline__namespace = /*#__PURE__*/_interopNamespace(readline);
var Fs__namespace = /*#__PURE__*/_interopNamespace(Fs);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all9) => {
  for (var name2 in all9)
    __defProp(target, name2, { get: all9[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/ini@4.1.3/node_modules/ini/lib/ini.js
var require_ini = __commonJS({
  "node_modules/.pnpm/ini@4.1.3/node_modules/ini/lib/ini.js"(exports, module) {
    var { hasOwnProperty } = Object.prototype;
    var encode = (obj, opt = {}) => {
      if (typeof opt === "string") {
        opt = { section: opt };
      }
      opt.align = opt.align === true;
      opt.newline = opt.newline === true;
      opt.sort = opt.sort === true;
      opt.whitespace = opt.whitespace === true || opt.align === true;
      opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
      opt.bracketedArray = opt.bracketedArray !== false;
      const eol = opt.platform === "win32" ? "\r\n" : "\n";
      const separator = opt.whitespace ? " = " : "=";
      const children2 = [];
      const keys5 = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
      let padToChars = 0;
      if (opt.align) {
        padToChars = safe(
          keys5.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)
        ).length;
      }
      let out2 = "";
      const arraySuffix = opt.bracketedArray ? "[]" : "";
      for (const k of keys5) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val) {
            out2 += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
          }
        } else if (val && typeof val === "object") {
          children2.push(k);
        } else {
          out2 += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
        }
      }
      if (opt.section && out2.length) {
        out2 = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out2;
      }
      for (const k of children2) {
        const nk = splitSections(k, ".").join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const child = encode(obj[k], {
          ...opt,
          section
        });
        if (out2.length && child.length) {
          out2 += eol;
        }
        out2 += child;
      }
      return out2;
    };
    function splitSections(str, separator) {
      var lastMatchIndex = 0;
      var lastSeparatorIndex = 0;
      var nextIndex = 0;
      var sections = [];
      do {
        nextIndex = str.indexOf(separator, lastMatchIndex);
        if (nextIndex !== -1) {
          lastMatchIndex = nextIndex + separator.length;
          if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
            continue;
          }
          sections.push(str.slice(lastSeparatorIndex, nextIndex));
          lastSeparatorIndex = nextIndex + separator.length;
        }
      } while (nextIndex !== -1);
      sections.push(str.slice(lastSeparatorIndex));
      return sections;
    }
    var decode2 = (str, opt = {}) => {
      opt.bracketedArray = opt.bracketedArray !== false;
      const out2 = /* @__PURE__ */ Object.create(null);
      let p2 = out2;
      let section = null;
      const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
      const lines3 = str.split(/[\r\n]+/g);
      const duplicates = {};
      for (const line4 of lines3) {
        if (!line4 || line4.match(/^\s*[;#]/) || line4.match(/^\s*$/)) {
          continue;
        }
        const match17 = line4.match(re);
        if (!match17) {
          continue;
        }
        if (match17[1] !== void 0) {
          section = unsafe(match17[1]);
          if (section === "__proto__") {
            p2 = /* @__PURE__ */ Object.create(null);
            continue;
          }
          p2 = out2[section] = out2[section] || /* @__PURE__ */ Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match17[2]);
        let isArray2;
        if (opt.bracketedArray) {
          isArray2 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        } else {
          duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
          isArray2 = duplicates[keyRaw] > 1;
        }
        const key = isArray2 && keyRaw.endsWith("[]") ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__") {
          continue;
        }
        const valueRaw = match17[3] ? unsafe(match17[4]) : true;
        const value5 = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray2) {
          if (!hasOwnProperty.call(p2, key)) {
            p2[key] = [];
          } else if (!Array.isArray(p2[key])) {
            p2[key] = [p2[key]];
          }
        }
        if (Array.isArray(p2[key])) {
          p2[key].push(value5);
        } else {
          p2[key] = value5;
        }
      }
      const remove8 = [];
      for (const k of Object.keys(out2)) {
        if (!hasOwnProperty.call(out2, k) || typeof out2[k] !== "object" || Array.isArray(out2[k])) {
          continue;
        }
        const parts2 = splitSections(k, ".");
        p2 = out2;
        const l = parts2.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts2) {
          if (part === "__proto__") {
            continue;
          }
          if (!hasOwnProperty.call(p2, part) || typeof p2[part] !== "object") {
            p2[part] = /* @__PURE__ */ Object.create(null);
          }
          p2 = p2[part];
        }
        if (p2 === out2 && nl === l) {
          continue;
        }
        p2[nl] = out2[k];
        remove8.push(k);
      }
      for (const del of remove8) {
        delete out2[del];
      }
      return out2;
    };
    var isQuoted = (val) => {
      return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
    };
    var safe = (val) => {
      if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
        return JSON.stringify(val);
      }
      return val.split(";").join("\\;").split("#").join("\\#");
    };
    var unsafe = (val) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.slice(1, -1);
        }
        try {
          val = JSON.parse(val);
        } catch {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1) {
              unesc += c;
            } else {
              unesc += "\\" + c;
            }
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc) {
          unesc += "\\";
        }
        return unesc.trim();
      }
      return val;
    };
    module.exports = {
      parse: decode2,
      decode: decode2,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js"(exports, module) {
    module.exports = function() {
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function SyntaxError(message, expected, found, offset, line4, column3) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line4;
        this.column = column3;
        this.name = "SyntaxError";
      }
      peg$subclass(SyntaxError, Error);
      function parse8(input) {
        var options3 = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c1 = function() {
          return nodes;
        }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name2) {
          addNode(node("ObjectPath", name2, line4, column3));
        }, peg$c12 = function(name2) {
          addNode(node("ArrayPath", name2, line4, column3));
        }, peg$c13 = function(parts2, name2) {
          return parts2.concat(name2);
        }, peg$c14 = function(name2) {
          return [name2];
        }, peg$c15 = function(name2) {
          return name2;
        }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value5) {
          addNode(node("Assign", value5, line4, column3, key));
        }, peg$c21 = function(chars) {
          return chars.join("");
        }, peg$c22 = function(node2) {
          return node2.value;
        }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
          return node("String", chars.join(""), line4, column3);
        }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char4) {
          return char4;
        }, peg$c34 = function(char4) {
          return char4;
        }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
          return "";
        }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left3, right3) {
          return node("Float", parseFloat(left3 + "e" + right3), line4, column3);
        }, peg$c43 = function(text10) {
          return node("Float", parseFloat(text10), line4, column3);
        }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
          return digits.join("");
        }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
          return "-" + digits.join("");
        }, peg$c50 = function(text10) {
          return node("Integer", parseInt(text10, 10), line4, column3);
        }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
          return node("Boolean", true, line4, column3);
        }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
          return node("Boolean", false, line4, column3);
        }, peg$c57 = function() {
          return node("Array", [], line4, column3);
        }, peg$c58 = function(value5) {
          return node("Array", value5 ? [value5] : [], line4, column3);
        }, peg$c59 = function(values3) {
          return node("Array", values3, line4, column3);
        }, peg$c60 = function(values3, value5) {
          return node("Array", values3.concat(value5), line4, column3);
        }, peg$c61 = function(value5) {
          return value5;
        }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values3) {
          return node("InlineTable", values3, line4, column3);
        }, peg$c69 = function(key, value5) {
          return node("InlineTableValue", value5, line4, column3, key);
        }, peg$c70 = function(digits) {
          return "." + digits;
        }, peg$c71 = function(date5) {
          return date5.join("");
        }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time2) {
          return time2.join("");
        }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date5, time2) {
          return node("Date", /* @__PURE__ */ new Date(date5 + "T" + time2 + "Z"), line4, column3);
        }, peg$c80 = function(date5, time2) {
          return node("Date", /* @__PURE__ */ new Date(date5 + "T" + time2), line4, column3);
        }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
          return "";
        }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
          return d.join("");
        }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
          return '"';
        }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
          return "\\";
        }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
          return "\b";
        }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
          return "	";
        }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
          return "\n";
        }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
          return "\f";
        }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
          return "\r";
        }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
          return convertCodePoint(digits.join(""));
        }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
        if ("startRule" in options3) {
          if (!(options3.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options3.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options3.startRule];
        }
        function line4() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
        function column3() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p2, ch;
            for (p2 = startPos; p2 < endPos; p2++) {
              ch = input.charAt(p2);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, pos) {
          function cleanupExpected(expected3) {
            var i = 1;
            expected3.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected3.length) {
              if (expected3[i - 1] === expected3[i]) {
                expected3.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
            for (i = 0; i < expected3.length; i++) {
              expectedDescs[i] = expected3[i].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new SyntaxError(
            buildMessage(expected2, found),
            expected2,
            found,
            pos,
            posDetails.line,
            posDetails.column
          );
        }
        function peg$parsestart() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 0, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseline();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseline();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1();
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseline() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 1, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpression();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsecomment();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parsecomment();
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseNL();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseNL();
                    }
                  } else {
                    s5 = peg$c2;
                  }
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseEOF();
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = [s1, s2, s3, s4, s5];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseNL();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseNL();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseEOF();
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseexpression() {
          var s0;
          var key = peg$currPos * 49 + 2, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parsecomment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepath();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetablearray();
              if (s0 === peg$FAILED) {
                s0 = peg$parseassignment();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 3, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c3;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c5;
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsepath() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 4, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetable_key();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c9;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c11(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetablearray() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 49 + 5, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parsetable_key();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s6 = peg$c9;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s7 = peg$c9;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c12(s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 6, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsedot_ended_table_key_part();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsedot_ended_table_key_part();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsetable_key_part();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c13(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetable_key_part();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c14(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key_part() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 7, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsequoted_key();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedot_ended_table_key_part() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 8, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsequoted_key();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseassignment() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 9, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsekey();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c18;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsequoted_key();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c18;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsekey() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 10, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseASCII_BASIC();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseASCII_BASIC();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsequoted_key() {
          var s0, s1;
          var key = peg$currPos * 49 + 11, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedouble_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesingle_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsevalue() {
          var s0;
          var key = peg$currPos * 49 + 12, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedatetime();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefloat();
              if (s0 === peg$FAILED) {
                s0 = peg$parseinteger();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseboolean();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsearray();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseinline_table();
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring() {
          var s0;
          var key = peg$currPos * 49 + 13, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parsedouble_quoted_multiline_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_quoted_single_line_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_multiline_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_single_line_string();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_multiline_string() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 14, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsemultiline_string_char();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsemultiline_string_char();
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s4 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_single_line_string() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 15, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestring_char();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestring_char();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c27;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_multiline_string() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 16, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 === peg$FAILED) {
              s2 = peg$c25;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsemultiline_literal_char();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsemultiline_literal_char();
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c29) {
                  s4 = peg$c29;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_single_line_string() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 17, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c31;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseliteral_char();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseliteral_char();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c31;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 18, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c27;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseliteral_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 19, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 39) {
            s2 = peg$c31;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 20, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemultiline_string_delim();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s2 = peg$c23;
                peg$currPos += 3;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c34(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_delim() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 21, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNL();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseNLS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseNLS();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c37();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_literal_char() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 22, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s2 = peg$c29;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 49 + 23, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteger_text();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 101) {
              s2 = peg$c38;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c39);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 69) {
                s2 = peg$c40;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c41);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseinteger_text();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c42(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat_text() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 24, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDIGITS();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s3 = [s3, s4, s5];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseDIGITS();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger() {
          var s0, s1;
          var key = peg$currPos * 49 + 25, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseinteger_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger_text() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 26, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c16;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = peg$c5;
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = peg$c5;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseboolean() {
          var s0, s1;
          var key = peg$currPos * 49 + 27, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c53();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c54) {
              s1 = peg$c54;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c55);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c56();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 28, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsearray_sep();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsearray_sep();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c57();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsearray_value();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c58(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsearray_value_list();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parsearray_value_list();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c59(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearray_value_list();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsearray_value_list();
                    }
                  } else {
                    s2 = peg$c2;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsearray_value();
                    if (s3 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s4 = peg$c9;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s2, s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 29, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsearray_sep();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsevalue();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsearray_sep();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsearray_sep();
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c61(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value_list() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 49 + 30, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsearray_sep();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsevalue();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parsearray_sep();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsearray_sep();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c62;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsearray_sep();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsearray_sep();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c61(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_sep() {
          var s0;
          var key = peg$currPos * 49 + 31, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parseS();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomment();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 49 + 32, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c64;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseS();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseS();
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseinline_table_assignment();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseinline_table_assignment();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseS();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s5 = peg$c66;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c67);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c68(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table_assignment() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 33, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseS();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsekey();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseS();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseS();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s4 = peg$c18;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseS();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseS();
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s8 = peg$c62;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = [];
                          s10 = peg$parseS();
                          while (s10 !== peg$FAILED) {
                            s9.push(s10);
                            s10 = peg$parseS();
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c69(s2, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s4 = peg$c18;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c69(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesecfragment() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 34, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDIGITS();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c70(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedate() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
          var key = peg$currPos * 49 + 35, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseDIGIT_OR_UNDER();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s6 = peg$c47;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c48);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDIGIT_OR_UNDER();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                          s9 = peg$c47;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c48);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseDIGIT_OR_UNDER();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseDIGIT_OR_UNDER();
                            if (s11 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c71(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 36, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c72;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime_with_offset() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
          var key = peg$currPos * 49 + 37, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDIGIT_OR_UNDER();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c72;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                              s11 = peg$c47;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c48);
                              }
                            }
                            if (s11 === peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 43) {
                                s11 = peg$c44;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c45);
                                }
                              }
                            }
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parseDIGIT_OR_UNDER();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parseDIGIT_OR_UNDER();
                                if (s13 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 58) {
                                    s14 = peg$c72;
                                    peg$currPos++;
                                  } else {
                                    s14 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c73);
                                    }
                                  }
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parseDIGIT_OR_UNDER();
                                    if (s15 !== peg$FAILED) {
                                      s16 = peg$parseDIGIT_OR_UNDER();
                                      if (s16 !== peg$FAILED) {
                                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                        s1 = s2;
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedatetime() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 49 + 38, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s2 = peg$c75;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsetime();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 90) {
                  s4 = peg$c77;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c78);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c79(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s2 = peg$c75;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetime_with_offset();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c80(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseS() {
          var s0;
          var key = peg$currPos * 49 + 39, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          if (peg$c81.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNL() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 40, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c83;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 13) {
              s1 = peg$c85;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c83;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNLS() {
          var s0;
          var key = peg$currPos * 49 + 41, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parseS();
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseEOF() {
          var s0, s1;
          var key = peg$currPos * 49 + 42, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          peg$silentFails++;
          if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = peg$c5;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseHEX() {
          var s0;
          var key = peg$currPos * 49 + 43, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          if (peg$c87.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGIT_OR_UNDER() {
          var s0, s1;
          var key = peg$currPos * 49 + 44, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          if (peg$c89.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 95) {
              s1 = peg$c91;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c93();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseASCII_BASIC() {
          var s0;
          var key = peg$currPos * 49 + 45, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          if (peg$c94.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c95);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGITS() {
          var s0, s1, s2;
          var key = peg$currPos * 49 + 46, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseDIGIT_OR_UNDER();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c96(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED() {
          var s0, s1;
          var key = peg$currPos * 49 + 47, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c99();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c100) {
              s1 = peg$c100;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c101);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c102();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c103) {
                s1 = peg$c103;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c104);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c105();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c106) {
                  s1 = peg$c106;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c107);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c108();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c109) {
                    s1 = peg$c109;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c111();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c112) {
                      s1 = peg$c112;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c113);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c114();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c115) {
                        s1 = peg$c115;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c116);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c117();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseESCAPED_UNICODE();
                      }
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED_UNICODE() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 48, cached3 = peg$cache[key];
          if (cached3) {
            peg$currPos = cached3.nextPos;
            return cached3.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c118) {
            s1 = peg$c118;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHEX();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHEX();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHEX();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseHEX();
                          if (s10 !== peg$FAILED) {
                            s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c2;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c121) {
              s1 = peg$c121;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c122);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        var nodes = [];
        function genError(err, line5, col) {
          var ex = new Error(err);
          ex.line = line5;
          ex.column = col;
          throw ex;
        }
        function addNode(node2) {
          nodes.push(node2);
        }
        function node(type2, value5, line5, column4, key) {
          var obj = { type: type2, value: value5, line: line5(), column: column4() };
          if (key) obj.key = key;
          return obj;
        }
        function convertCodePoint(str, line5, col) {
          var num = parseInt("0x" + str);
          if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
            genError("Invalid Unicode escape code: " + str, line5, col);
          } else {
            return fromCodePoint(num);
          }
        }
        function fromCodePoint() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length3 = arguments.length;
          if (!length3) {
            return "";
          }
          var result = "";
          while (++index < length3) {
            var codePoint = Number(arguments[index]);
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 == length3 || codeUnits.length > MAX_SIZE) {
              result += String.fromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError,
        parse: parse8
      };
    }();
  }
});

// node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js"(exports, module) {
    function compile(nodes) {
      var assignedPaths = [];
      var valueAssignments = [];
      var currentPath = "";
      var data = /* @__PURE__ */ Object.create(null);
      var context7 = data;
      return reduce14(nodes);
      function reduce14(nodes2) {
        var node;
        for (var i = 0; i < nodes2.length; i++) {
          node = nodes2[i];
          switch (node.type) {
            case "Assign":
              assign(node);
              break;
            case "ObjectPath":
              setPath(node);
              break;
            case "ArrayPath":
              addTableArray(node);
              break;
          }
        }
        return data;
      }
      function genError(err, line4, col) {
        var ex = new Error(err);
        ex.line = line4;
        ex.column = col;
        throw ex;
      }
      function assign(node) {
        var key = node.key;
        var value5 = node.value;
        var line4 = node.line;
        var column3 = node.column;
        var fullPath;
        if (currentPath) {
          fullPath = currentPath + "." + key;
        } else {
          fullPath = key;
        }
        if (typeof context7[key] !== "undefined") {
          genError("Cannot redefine existing key '" + fullPath + "'.", line4, column3);
        }
        context7[key] = reduceValueNode(value5);
        if (!pathAssigned(fullPath)) {
          assignedPaths.push(fullPath);
          valueAssignments.push(fullPath);
        }
      }
      function pathAssigned(path2) {
        return assignedPaths.indexOf(path2) !== -1;
      }
      function reduceValueNode(node) {
        if (node.type === "Array") {
          return reduceArrayWithTypeChecking(node.value);
        } else if (node.type === "InlineTable") {
          return reduceInlineTableNode(node.value);
        } else {
          return node.value;
        }
      }
      function reduceInlineTableNode(values3) {
        var obj = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < values3.length; i++) {
          var val = values3[i];
          if (val.value.type === "InlineTable") {
            obj[val.key] = reduceInlineTableNode(val.value.value);
          } else if (val.type === "InlineTableValue") {
            obj[val.key] = reduceValueNode(val.value);
          }
        }
        return obj;
      }
      function setPath(node) {
        var path2 = node.value;
        var quotedPath = path2.map(quoteDottedString).join(".");
        var line4 = node.line;
        var column3 = node.column;
        if (pathAssigned(quotedPath)) {
          genError("Cannot redefine existing key '" + path2 + "'.", line4, column3);
        }
        assignedPaths.push(quotedPath);
        context7 = deepRef(data, path2, /* @__PURE__ */ Object.create(null), line4, column3);
        currentPath = path2;
      }
      function addTableArray(node) {
        var path2 = node.value;
        var quotedPath = path2.map(quoteDottedString).join(".");
        var line4 = node.line;
        var column3 = node.column;
        if (!pathAssigned(quotedPath)) {
          assignedPaths.push(quotedPath);
        }
        assignedPaths = assignedPaths.filter(function(p2) {
          return p2.indexOf(quotedPath) !== 0;
        });
        assignedPaths.push(quotedPath);
        context7 = deepRef(data, path2, [], line4, column3);
        currentPath = quotedPath;
        if (context7 instanceof Array) {
          var newObj = /* @__PURE__ */ Object.create(null);
          context7.push(newObj);
          context7 = newObj;
        } else {
          genError("Cannot redefine existing key '" + path2 + "'.", line4, column3);
        }
      }
      function deepRef(start4, keys5, value5, line4, column3) {
        var traversed = [];
        var traversedPath = "";
        keys5.join(".");
        var ctx = start4;
        for (var i = 0; i < keys5.length; i++) {
          var key = keys5[i];
          traversed.push(key);
          traversedPath = traversed.join(".");
          if (typeof ctx[key] === "undefined") {
            if (i === keys5.length - 1) {
              ctx[key] = value5;
            } else {
              ctx[key] = /* @__PURE__ */ Object.create(null);
            }
          } else if (i !== keys5.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
            genError("Cannot redefine existing key '" + traversedPath + "'.", line4, column3);
          }
          ctx = ctx[key];
          if (ctx instanceof Array && ctx.length && i < keys5.length - 1) {
            ctx = ctx[ctx.length - 1];
          }
        }
        return ctx;
      }
      function reduceArrayWithTypeChecking(array7) {
        var firstType = null;
        for (var i = 0; i < array7.length; i++) {
          var node = array7[i];
          if (firstType === null) {
            firstType = node.type;
          } else {
            if (node.type !== firstType) {
              genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
            }
          }
        }
        return array7.map(reduceValueNode);
      }
      function quoteDottedString(str) {
        if (str.indexOf(".") > -1) {
          return '"' + str + '"';
        } else {
          return str;
        }
      }
    }
    module.exports = {
      compile
    };
  }
});

// node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js
var require_toml = __commonJS({
  "node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js"(exports, module) {
    var parser = require_parser();
    var compiler = require_compiler();
    module.exports = {
      parse: function(input) {
        var nodes = parser.parse(input.toString());
        return compiler.compile(nodes);
      }
    };
  }
});

// node_modules/.pnpm/call-me-maybe@1.0.2/node_modules/call-me-maybe/src/next.js
var require_next = __commonJS({
  "node_modules/.pnpm/call-me-maybe@1.0.2/node_modules/call-me-maybe/src/next.js"(exports, module) {
    function makeNext() {
      if (typeof process === "object" && typeof process.nextTick === "function") {
        return process.nextTick;
      } else if (typeof setImmediate === "function") {
        return setImmediate;
      } else {
        return function next(f) {
          setTimeout(f, 0);
        };
      }
    }
    module.exports = makeNext();
  }
});

// node_modules/.pnpm/call-me-maybe@1.0.2/node_modules/call-me-maybe/src/maybe.js
var require_maybe = __commonJS({
  "node_modules/.pnpm/call-me-maybe@1.0.2/node_modules/call-me-maybe/src/maybe.js"(exports, module) {
    var next = require_next();
    module.exports = function maybe(cb, promise3) {
      if (cb) {
        promise3.then(function(result) {
          next(function() {
            cb(null, result);
          });
        }, function(err) {
          next(function() {
            cb(err);
          });
        });
        return void 0;
      } else {
        return promise3;
      }
    };
  }
});

// node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/utils.js"(exports, module) {
    var DebounceTimers = class {
      constructor(cb, defaultDelay) {
        this.cb = cb;
        this.delay = defaultDelay;
        this.timers = {};
        this.pausers = {};
      }
      setDelay(delay2) {
        if (delay2 >= 0)
          this.delay = delay2;
      }
      pause(key) {
        this.pausers[key] = this.pausers[key] || 0;
        this.pausers[key]++;
      }
      unpause(key) {
        var count4 = this.pausers[key] || 0;
        if (count4 > 0)
          count4--;
        this.pausers[key] = count4;
      }
      unpauseAndTime(key) {
        this.unpause(key);
        this.time(key);
      }
      time(key) {
        var self = this;
        var timers = this.timers;
        var timer = this.timers[key];
        if (this.pausers[key] > 0)
          return;
        if (timer)
          clearTimeout(timer);
        timers[key] = setTimeout(function onTimer() {
          self.cb(key);
          delete timers[key];
        }, self.delay);
      }
    };
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(name2, expected, actual) {
        name2.includes(".") ? "property" : "argument";
      }
    };
    function assertIsObject(value5, name2, types = "Object") {
      if (value5 !== void 0 && (value5 === null || typeof value5 !== "object" || Array.isArray(value5))) {
        const err = new ERR_INVALID_ARG_TYPE(name2, types, value5);
        Error.captureStackTrace(err, assertIsObject);
        throw err;
      }
    }
    module.exports = {
      ERR_INVALID_ARG_TYPE,
      assertIsObject,
      DebounceTimers
    };
  }
});

// node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/request-options.js
var require_request_options = __commonJS({
  "node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/request-options.js"(exports, module) {
    var { assertIsObject } = require_utils();
    function initializeOptions(options3) {
      assertIsObject(options3, "options");
      options3 = Object.assign({}, options3);
      options3.allowHalfOpen = true;
      options3.rejectUnauthorized = false;
      assertIsObject(options3.settings, "options.settings");
      options3.settings = Object.assign({}, options3.settings);
      options3.Http1IncomingMessage = options3.Http1IncomingMessage || this.http.IncomingMessage;
      options3.Http1ServerResponse = options3.Http1ServerResponse || this.http.ServerResponse;
      options3.Http2ServerRequest = options3.Http2ServerRequest || (this.http2 || {}).Http2ServerRequest;
      options3.Http2ServerResponse = options3.Http2ServerResponse || (this.http2 || {}).Http2ServerResponse;
      return options3;
    }
    function initializeTLSOptions(options3, servername) {
      options3 = initializeOptions.call(this, options3);
      var ALPNProtocols = options3.ALPNProtocols = [];
      if (this.http2Support)
        ALPNProtocols.push("h2");
      if (options3.allowHTTP1 == true || !this.http2Support)
        ALPNProtocols.push("http/1.1");
      if (servername !== void 0 && options3.servername === void 0)
        options3.servername = servername;
      return options3;
    }
    module.exports = {
      initializeTLSOptions
    };
  }
});

// node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/request.js
var require_request = __commonJS({
  "node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/request.js"(exports, module) {
    var { URL: URL2 } = __require("url");
    var { EventEmitter } = __require("events");
    var _extend = __require("util")._extend;
    var { DebounceTimers, assertIsObject} = require_utils();
    var { initializeTLSOptions } = require_request_options();
    var http2 = __require("http");
    var https = __require("https");
    var { Stream: Stream2 } = __require("stream");
    function addFunctions(container, obj) {
      const proto25 = obj.prototype;
      Object.keys(proto25).forEach((name2) => {
        if (container.indexOf(name2) != -1)
          return;
        if (name2.indexOf("_") != 0 && typeof proto25[name2] == "function") {
          container.push(name2);
        }
      });
    }
    var STUBBED_METHODS_NAME = [];
    addFunctions(STUBBED_METHODS_NAME, http2.ClientRequest);
    addFunctions(STUBBED_METHODS_NAME, http2.OutgoingMessage);
    addFunctions(STUBBED_METHODS_NAME, EventEmitter);
    addFunctions(STUBBED_METHODS_NAME, Stream2);
    var PROPERTIES_TO_PROXY = [
      "httpVersionMajor",
      "httpVersionMinor",
      "httpVersion"
    ];
    var HEADERS_TO_REMOVE = ["host", "connection"];
    var $stubs = Symbol("stubs");
    function ClientRequest() {
      this.http2Mimic = true;
      this[$stubs] = [];
      for (var i = 0; i < STUBBED_METHODS_NAME.length; i++) {
        let name2 = STUBBED_METHODS_NAME[i];
        if (!ClientRequest.prototype[name2]) {
          this[name2] = function method() {
            return this.genericStubber(name2, arguments);
          }.bind(this);
        }
      }
      var requestOptions, cb, url2, args2;
      const isInternal = arguments[0] instanceof RequestInternalEnforce;
      var isInternalMethod, isInternalProtocol;
      if (isInternal) {
        const enforceOptions = arguments[0];
        if (enforceOptions.method)
          isInternalMethod = enforceOptions.method;
        if (enforceOptions.protocol)
          isInternalProtocol = enforceOptions.protocol;
      }
      if (isInternal) {
        args2 = arguments[0].args;
      } else {
        args2 = arguments;
      }
      if (args2[2] != void 0) {
        url2 = args2[0];
        requestOptions = args2[1];
        cb = args2[2];
      } else if (args2[1] == void 0) {
        requestOptions = args2[0];
      } else {
        requestOptions = args2[0];
        cb = args2[1];
      }
      cb = cb || function dummy() {
      };
      if (typeof requestOptions === "string") {
        requestOptions = urlToOptions(new URL2(requestOptions));
        if (!requestOptions.hostname) {
          throw new Error("Unable to determine the domain name");
        }
      } else {
        if (url2) {
          requestOptions = _extend(urlToOptions(new URL2(url2)), requestOptions);
        } else {
          requestOptions = _extend({}, requestOptions);
        }
      }
      if (isInternalProtocol != isInternalProtocol) {
        requestOptions.protocol = isInternalProtocol;
      }
      if (requestOptions.protocol == "https:" && !requestOptions.port && requestOptions.port != 0)
        requestOptions.port = 443;
      if (!requestOptions.port && requestOptions.port != 0)
        requestOptions.port = 80;
      if (isInternalMethod) {
        requestOptions.method = isInternalMethod;
      } else if (!requestOptions.method)
        requestOptions.method = "GET";
      requestOptions.method = requestOptions.method.toUpperCase();
      const requestManager = requestOptions.requestManager || this.getGlobalManager(requestOptions);
      requestManager.handleClientRequest(this, requestOptions, cb);
    }
    ClientRequest.prototype = {
      getGlobalManager(options3) {
        if (options3.agent)
          return options3.agent.protocol == "https:" ? HttpsRequest.globalManager : HttpRequest.globalManager;
        else
          return HttpRequestManager.globalManager;
      },
      genericStubber(method, args2) {
        if (this[$stubs]) {
          this[$stubs].push([method, args2]);
          return true;
        } else
          return this[method](...arguments);
      },
      on(eventName, cb) {
        if (eventName == "response") {
          if (!cb.http2Safe) {
            eventName = "http1.response";
            arguments[0] = eventName;
          }
        }
        if (this._on) {
          this._on(...arguments);
        } else
          this.genericStubber("on", arguments);
      },
      once(eventName, cb) {
        if (eventName == "response") {
          if (!cb.http2Safe) {
            eventName = "http1.response";
          }
        }
        if (this._once) {
          this._once(...arguments);
        } else
          this.genericStubber("once", arguments);
      },
      emitError(error4) {
        if (this[$stubs]) {
          this[$stubs].forEach(([method, args2]) => {
            if ((method === "on" || method === "once") && args2[0] === "error") {
              args2[1](error4);
            }
          });
        } else
          return this.emit("error", error4);
      },
      take(stream3) {
        for (var i = 0; i < STUBBED_METHODS_NAME.length; i++) {
          let name2 = STUBBED_METHODS_NAME[i];
          if (stream3[name2]) {
            this[name2] = stream3[name2].bind(stream3);
          }
        }
        this._on = stream3.on.bind(stream3);
        this._once = stream3.once.bind(stream3);
        this.proxyProps(stream3);
        for (let i2 = 0; i2 < this[$stubs].length; i2++) {
          var stub = this[$stubs][i2];
          stream3[stub[0]](...stub[1]);
        }
        this[$stubs] = null;
      },
      proxyProps(http2Stream) {
        function getter() {
          return http2Stream[this];
        }
        function setter(value5) {
          http2Stream[this] = value5;
        }
        const notToProxy = ["on", "_on", "_once", "once", "http2Mimic"].concat(STUBBED_METHODS_NAME);
        const keys5 = Object.keys(this);
        const keysToProxy = [].concat(PROPERTIES_TO_PROXY);
        keys5.forEach(function whichProxyKeys(key) {
          if (notToProxy.indexOf(key) == -1 && keysToProxy.indexOf(key) == -1) {
            keysToProxy.push(key);
          }
        });
        const properties = Object.getOwnPropertyDescriptors(http2Stream);
        for (var i = 0; i < keysToProxy.length; i++) {
          let name2 = keysToProxy[i];
          const propConfig = properties[name2];
          let shouldCopyValue;
          if (!propConfig)
            shouldCopyValue = true;
          if (propConfig && (propConfig.writable || propConfig))
            shouldCopyValue = true;
          if (shouldCopyValue)
            http2Stream[name2] = this[name2];
          Object.defineProperty(this, name2, {
            get: getter.bind(name2),
            set: setter.bind(name2)
          });
        }
      }
    };
    var HttpRequestManager = class _HttpRequestManager extends EventEmitter {
      constructor(options3) {
        super();
        this.httpsAgent = https.globalAgent;
        this.httpAgent = http2.globalAgent;
        this.init(options3);
      }
      log() {
      }
      init(options3) {
        options3 = options3 || {};
        this.http2Clients = {};
        this.cachedHTTP1Result = {};
        this.setModules();
        this.http2Debouncer = new DebounceTimers(function stopConnection(key) {
          this.log("stopping ", key);
          var foundConnection = this.http2Clients[key];
          if (foundConnection) {
            this.removeHttp2Client(key, foundConnection);
          }
        }.bind(this), 1e3);
        this.keepH1IdentificationCacheFor = options3.keepH1IdentificationCacheFor || 3e4;
        this.http2Debouncer.setDelay(options3.keepH2ConnectionFor);
        if (options3.useHttp) {
          this.enforceProtocol = "http:";
        } else if (options3.useHttps) {
          this.enforceProtocol = "https:";
        }
      }
      setModules() {
        this["http"] = __require("http");
        this["https"] = __require("https");
        this["tls"] = __require("tls");
        this["net"] = __require("net");
        this.http2Support = false;
        try {
          this["http2"] = __require("http2");
          this.http2Support = true;
        } catch (err) {
        }
      }
      handleClientRequest(clientRequest, requestOptions, cb) {
        const requestManager = this;
        const clientKey = requestManager.getClientKey(requestOptions);
        if (requestManager.hasCachedConnection(clientKey)) {
          const socket = requestManager.getHttp2Client(clientKey);
          const connectionOptions = {
            createConnection() {
              return socket;
            }
          };
          process.nextTick(function onMakeRequest() {
            requestManager.makeRequest(clientRequest, clientKey, requestOptions, cb, connectionOptions);
          }.bind(requestManager));
        } else
          requestManager.holdConnectionToIdentification(clientKey, requestOptions, function onIdentification(error4, connectionOptions) {
            if (error4) {
              clientRequest.emitError(error4);
              return;
            }
            requestManager.makeRequest(clientRequest, clientKey, requestOptions, cb, connectionOptions);
          }.bind(requestManager));
      }
      getClientKey(url2) {
        return `${url2.protocol || this.enforceProtocol}${url2.servername || url2.host || url2.hostname}:${url2.port}`;
      }
      getHttp2Client(clientKey) {
        return this.http2Clients[clientKey];
      }
      setHttp2Client(clientKey, client) {
        const httpManager = this;
        const prevClient = httpManager.http2Clients[clientKey];
        if (prevClient)
          httpManager.removeHttp2Client(clientKey, prevClient);
        httpManager.http2Clients[clientKey] = client;
        function closeClient() {
          httpManager.removeHttp2Client(clientKey, client);
        }
        client.on("close", closeClient);
        client.on("goaway", closeClient);
        client.on("error", closeClient);
        client.on("frameError", closeClient);
        client.on("timeout", closeClient);
      }
      removeHttp2Client(clientKey, client) {
        try {
          delete this.http2Clients[clientKey];
          if (!client.closed) {
            client.close();
          }
        } catch (err) {
        }
        client.removeAllListeners("close");
        client.removeAllListeners("error");
        client.removeAllListeners("frameError");
        client.removeAllListeners("timeout");
      }
      request(url2, options3, cb) {
        var args2 = new RequestInternalEnforce(arguments);
        if (this.enforceProtocol) {
          args2.protocol = this.enforceProtocol;
        }
        return new ClientRequest(args2);
      }
      get() {
        var args2 = new RequestInternalEnforce(arguments);
        args2.method = "GET";
        var request = this.request(args2);
        request.end();
        return request;
      }
      hasCachedConnection(clientKey) {
        const http2Client = this.getHttp2Client(clientKey);
        if (http2Client) {
          return true;
        }
        return this.cachedHTTP1Result[clientKey] + this.keepH1IdentificationCacheFor < Date.now();
      }
      makeRequest(inStream, clientKey, requestOptions, cb, connectionOptions) {
        const http2Client = this.getHttp2Client(clientKey);
        if (http2Client) {
          return this.makeHttp2Request(clientKey, inStream, http2Client, Object.assign(connectionOptions || {}, requestOptions), cb);
        }
        if (!requestOptions.agent) {
          if (requestOptions.protocol == "https:")
            requestOptions.agent = this.httpsAgent;
          else
            requestOptions.agent = this.httpAgent;
        }
        return this.makeHttpRequest(clientKey, inStream, requestOptions, cb, connectionOptions);
      }
      holdConnectionToIdentification(clientKey, requestOptions, cb) {
        const topic = `identify-${clientKey}`;
        if (this._events[topic])
          this.once(topic, cb);
        else {
          this.once(topic, function letKnowThereIsAnEvent() {
          });
          const socket = this.identifyConnection(requestOptions, function onIdentify(error4, type2) {
            if (error4) {
              return cb(error4);
            }
            var options3 = {
              createConnection() {
                return socket;
              }
            };
            if (type2 == "h2" && this.http2Support) {
              var http2Client = this.http2.connect(requestOptions, options3);
              this.setHttp2Client(clientKey, http2Client);
            } else {
              this.cachedHTTP1Result[clientKey] = Date.now();
            }
            cb(null, options3);
            this.emit(topic, options3);
          }.bind(this));
        }
      }
      makeHttpRequest(clientKey, inStream, options3, cb, connectionOptions) {
        if (options3 instanceof URL2)
          options3 = urlToOptions(options3);
        const h1op = _extend({}, options3);
        if (connectionOptions)
          h1op.createConnection = connectionOptions.createConnection;
        const requestModule = h1op.protocol == "https:" ? this.https : this.http;
        const req = requestModule.request(h1op, cb);
        inStream.take(req);
        inStream._on("response", function onHttp1Response(v) {
          this.emit("http1.response", v);
        });
      }
      makeHttp2Request(clientKey, inStream, http2Client, requestOptions, cb) {
        var http2Debouncer = this.http2Debouncer;
        http2Debouncer.pause(clientKey);
        var headers = _extend({}, requestOptions.headers || {});
        if (requestOptions.method)
          headers[":method"] = requestOptions.method;
        if (requestOptions.path)
          headers[":path"] = requestOptions.path;
        Object.keys(headers).forEach((key) => {
          if (HEADERS_TO_REMOVE.indexOf((key + "").toLowerCase()) != -1) {
            delete headers[key];
          }
        });
        requestOptions.headers = headers;
        var req = http2Client.request(
          headers
        );
        inStream.emit("socket", requestOptions.createConnection());
        let maxContentLength;
        let currentContent = 0;
        req.on("data", function onData(data) {
          currentContent += data.length;
          if (currentContent >= maxContentLength)
            http2Debouncer.unpauseAndTime(clientKey);
        });
        inStream.take(req);
        function onResponse(headers2) {
          maxContentLength = parseInt(headers2["content-length"]);
          if (maxContentLength < 0)
            this.http2Debouncer.unpauseAndTime(clientKey);
          _HttpRequestManager.httpCompatibleResponse(req, requestOptions, headers2);
          inStream.emit("http1.response", req);
          if (cb)
            cb(req);
        }
        onResponse.http2Safe = true;
        req.once("response", onResponse.bind(this));
      }
      static httpCompatibleResponse(res, requestOptions, headers) {
        res.httpVersion = "2.0";
        res.rawHeaders = headers;
        res.headers = headers;
        res.statusCode = headers[":status"];
        delete headers[":status"];
      }
      identifyConnection(requestOptions, cb) {
        var socket = this.connect(requestOptions, { allowHTTP1: true }, function onConnect() {
          socket.removeListener("error", cb);
          if (socket.alpnProtocol == "h2") {
            cb(null, "h2");
          } else {
            socket.end();
            cb(null, "h1");
          }
        });
        socket.on("error", cb);
        return socket;
      }
      connect(authority, options3, listener) {
        if (typeof options3 === "function") {
          listener = options3;
          options3 = void 0;
        }
        assertIsObject(options3, "options");
        options3 = Object.assign({}, options3);
        if (typeof authority === "string")
          authority = new URL2(authority);
        assertIsObject(authority, "authority", ["string", "Object", "URL"]);
        var protocol = authority.protocol || options3.protocol || (this.enforceProtocol != "detect" ? this.enforceProtocol : null) || "http:";
        var port = "" + (authority.port !== "" ? authority.port : authority.protocol === "http:" ? 80 : 443);
        var host = authority.hostname || authority.host || "localhost";
        var socket;
        if (typeof options3.createConnection === "function") {
          socket = options3.createConnection(authority, options3);
        } else {
          switch (protocol) {
            case "http:":
              socket = this.net.connect(port, host, listener);
              break;
            case "https:":
              socket = this.tls.connect(port, host, initializeTLSOptions.call(this, options3, host), listener);
              break;
            default:
              throw new Error("Not supprted" + protocol);
          }
        }
        return socket;
      }
    };
    function urlToOptions(url2) {
      var options3 = {
        protocol: url2.protocol,
        hostname: url2.hostname,
        hash: url2.hash,
        search: url2.search,
        pathname: url2.pathname,
        path: `${url2.pathname}${url2.search}`,
        href: url2.href
      };
      if (url2.port !== "") {
        options3.port = Number(url2.port);
      }
      if (url2.username || url2.password) {
        options3.auth = `${url2.username}:${url2.password}`;
      }
      return options3;
    }
    var RequestInternalEnforce = class _RequestInternalEnforce {
      constructor(args2) {
        if (args2[0] instanceof _RequestInternalEnforce) {
          return args2[0];
        }
        this.args = args2;
        this.method = null;
        this.protocol = null;
      }
    };
    var HttpsRequest = class extends HttpRequestManager {
      constructor() {
        super(...arguments);
        this.Agent = https.Agent;
        this.globalAgent = https.globalAgent;
        this.enforceProtocol = "https:";
      }
    };
    var httpsRequestSinglton = new HttpsRequest();
    HttpsRequest.globalManager = httpsRequestSinglton;
    HttpsRequest.Manager = HttpsRequest;
    var HttpRequest = class extends HttpRequestManager {
      constructor() {
        super(...arguments);
        this.Agent = http2.Agent;
        this.globalAgent = http2.globalAgent;
        this.enforceProtocol = "http:";
      }
    };
    var httpRequestSinglton = new HttpRequest();
    HttpRequest.globalManager = httpRequestSinglton;
    HttpRequest.Manager = HttpRequest;
    var singeltonHttpManager = new HttpRequestManager();
    singeltonHttpManager.enforceProtocol = "detect";
    HttpRequestManager.globalManager = singeltonHttpManager;
    module.exports = {
      HttpRequest,
      HttpsRequest,
      HTTP2OutgoingMessage: ClientRequest,
      ClientRequest,
      HttpRequestManager
    };
  }
});

// node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/http.js"(exports, module) {
    var {
      HttpRequest,
      ClientRequest
    } = require_request();
    var globalManager = HttpRequest.globalManager;
    var request = globalManager.request.bind(globalManager);
    var get14 = globalManager.get.bind(globalManager);
    var http2 = Object.assign({}, __require("http"));
    module.exports = Object.assign(http2, {
      ClientRequest,
      globalManager,
      request,
      get: get14
    });
  }
});

// node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/https.js
var require_https = __commonJS({
  "node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/https.js"(exports, module) {
    var {
      HttpsRequest,
      ClientRequest
    } = require_request();
    var globalManager = HttpsRequest.globalManager;
    var request = globalManager.request.bind(globalManager);
    var get14 = globalManager.get.bind(globalManager);
    var https = Object.assign({}, __require("https"));
    module.exports = Object.assign(https, {
      ClientRequest,
      globalManager,
      request,
      get: get14
    });
  }
});

// node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/http2-client@1.3.5/node_modules/http2-client/lib/index.js"(exports, module) {
    var {
      HttpRequestManager,
      HTTP2OutgoingMessage,
      ClientRequest
    } = require_request();
    var http2 = require_http();
    var https = require_https();
    var autoDetectManager = new HttpRequestManager();
    HttpRequestManager.globalManager = autoDetectManager;
    var request = autoDetectManager.request.bind(autoDetectManager);
    var get14 = autoDetectManager.get.bind(autoDetectManager);
    module.exports = {
      HTTP2OutgoingMessage,
      ClientRequest,
      globalManager: HttpRequestManager.globalManager,
      request,
      get: get14,
      http: http2,
      https
    };
  }
});

// node_modules/.pnpm/node-fetch-h2@2.3.0/node_modules/node-fetch-h2/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  default: () => lib_default
});
function FetchError(message, type2, systemError2) {
  Error.call(this, message);
  this.message = message;
  this.type = type2;
  if (systemError2) {
    this.code = this.errno = systemError2.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size13 = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout4 = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (body instanceof Blob) {
    body = body[BUFFER];
  } else if (Buffer.isBuffer(body)) ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof Stream__default.default) ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size13;
  this.timeout = timeout4;
  if (body instanceof Stream__default.default) {
    body.on("error", function(err) {
      const error4 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error4;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  if (this.body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (Buffer.isBuffer(this.body)) {
    return Body.Promise.resolve(this.body);
  }
  if (!(this.body instanceof Stream__default.default)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve3, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    _this4.body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    _this4.body.on("data", function(chunk4) {
      if (abort || chunk4 === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk4.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk4.length;
      accum.push(chunk4);
    });
    _this4.body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve3(Buffer.concat(accum));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer3, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer3.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer3, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function clone2(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream__default.default && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (body instanceof Blob) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof Stream__default.default) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
function validateName(name2) {
  name2 = `${name2}`;
  if (invalidTokenRegex.test(name2)) {
    throw new TypeError(`${name2} is not a legal HTTP header name`);
  }
}
function validateValue(value5) {
  value5 = `${value5}`;
  if (invalidHeaderCharRegex.test(value5)) {
    throw new TypeError(`${value5} is not a legal HTTP header value`);
  }
}
function find3(map33, name2) {
  name2 = name2.toLowerCase();
  for (const key in map33) {
    if (key.toLowerCase() === name2) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys5 = Object.keys(headers[MAP]).sort();
  return keys5.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find3(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name2 of Object.keys(obj)) {
    if (invalidTokenRegex.test(name2)) {
      continue;
    }
    if (Array.isArray(obj[name2])) {
      for (const val of obj[name2]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name2] === void 0) {
          headers[MAP][name2] = [val];
        } else {
          headers[MAP][name2].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name2])) {
      headers[MAP][name2] = [obj[name2]];
    }
  }
  return headers;
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto25 = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto25 && proto25.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof Stream__default.default.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  if (!headers.has("Connection") && !request.agent) {
    headers.set("Connection", "close");
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent: request.agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch(url2, opts) {
  if (!fetch.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch.Promise;
  return new fetch.Promise(function(resolve3, reject) {
    const request = new Request(url2, opts);
    const options3 = getNodeRequestOptions(request);
    const send = import_http2_client.default.request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error4 = new AbortError("The user aborted a request.");
      reject(error4);
      if (request.body && request.body instanceof Stream__default.default.Readable) {
        request.body.destroy(error4);
      }
      if (!response || !response.body) return;
      response.body.emit("error", error4);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options3);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal) signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : resolve_url(request.url, location);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal
            };
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve3(fetch(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal) signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve3(response);
        return;
      }
      const zlibOptions = {
        flush: zlib__default.default.Z_SYNC_FLUSH,
        finishFlush: zlib__default.default.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(zlib__default.default.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve3(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk4) {
          if ((chunk4[0] & 15) === 8) {
            body = body.pipe(zlib__default.default.createInflate());
          } else {
            body = body.pipe(zlib__default.default.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve3(response);
        });
        return;
      }
      response = new Response(body, response_options);
      resolve3(response);
    });
    writeToStream(req, request);
  });
}
var import_http2_client, BUFFER, TYPE, Blob, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response, INTERNALS$2, parse_url, format_url, streamDestructionSupported, Request, PassThrough$1, resolve_url, lib_default;
var init_lib = __esm({
  "node_modules/.pnpm/node-fetch-h2@2.3.0/node_modules/node-fetch-h2/lib/index.mjs"() {
    import_http2_client = __toESM(require_lib(), 1);
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options3 = arguments[1];
        const buffers = [];
        if (blobParts) {
          const a = blobParts;
          const length3 = Number(a.length);
          for (let i = 0; i < length3; i++) {
            const element = a[i];
            let buffer3;
            if (element instanceof Buffer) {
              buffer3 = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer3 = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer3 = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer3 = element[BUFFER];
            } else {
              buffer3 = Buffer.from(typeof element === "string" ? element : String(element));
            }
            buffers.push(buffer3);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type2 = options3 && options3.type !== void 0 && String(options3.type).toLowerCase();
        if (type2 && !/[^\u0020-\u007E]/.test(type2)) {
          this[TYPE] = type2;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      slice() {
        const size13 = this.size;
        const start4 = arguments[0];
        const end5 = arguments[1];
        let relativeStart, relativeEnd;
        if (start4 === void 0) {
          relativeStart = 0;
        } else if (start4 < 0) {
          relativeStart = Math.max(size13 + start4, 0);
        } else {
          relativeStart = Math.min(start4, size13);
        }
        if (end5 === void 0) {
          relativeEnd = size13;
        } else if (end5 < 0) {
          relativeEnd = Math.max(size13 + end5, 0);
        } else {
          relativeEnd = Math.min(end5, size13);
        }
        const span2 = Math.max(relativeEnd - relativeStart, 0);
        const buffer3 = this[BUFFER];
        const slicedBuffer = buffer3.slice(relativeStart, relativeStart + span2);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = __require("encoding").convert;
    } catch (e) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = Stream__default.default.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer3) {
          try {
            return JSON.parse(buffer3.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer3) {
          return buffer3.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer3) {
          return convertBody(buffer3, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto25) {
      for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name2 in proto25)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name2);
          Object.defineProperty(proto25, name2, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value5 of rawHeaders[headerName]) {
              this.append(headerName, value5);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value5 = init[key];
              this.append(key, value5);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key = find3(this[MAP], name2);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name2 = _pairs$i[0], value5 = _pairs$i[1];
          callback.call(thisArg, value5, name2, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name2, value5) {
        name2 = `${name2}`;
        value5 = `${value5}`;
        validateName(name2);
        validateValue(value5);
        const key = find3(this[MAP], name2);
        this[MAP][key !== void 0 ? key : name2] = [value5];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name2, value5) {
        name2 = `${name2}`;
        value5 = `${value5}`;
        validateName(name2);
        validateValue(value5);
        const key = find3(this[MAP], name2);
        if (key !== void 0) {
          this[MAP][key].push(value5);
        } else {
          this[MAP][name2] = [value5];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name2) {
        name2 = `${name2}`;
        validateName(name2);
        return find3(this[MAP], name2) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key = find3(this[MAP], name2);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values3 = getHeaders(target, kind);
        const len = values3.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values3[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = http__default.default.STATUS_CODES;
    Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status2 = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status: status2,
          statusText: opts.statusText || STATUS_CODES[status2],
          headers
        };
      }
      get url() {
        return this[INTERNALS$1].url;
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    parse_url = Url__namespace.default.parse;
    format_url = Url__namespace.default.format;
    streamDestructionSupported = "destroy" in Stream__default.default.Readable.prototype;
    Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone2(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    PassThrough$1 = Stream__default.default.PassThrough;
    resolve_url = Url__namespace.default.resolve;
    fetch.isRedirect = function(code2) {
      return code2 === 301 || code2 === 302 || code2 === 303 || code2 === 307 || code2 === 308;
    };
    fetch.Promise = global.Promise;
    lib_default = fetch;
  }
});

// node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/jptr.js
var require_jptr = __commonJS({
  "node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/jptr.js"(exports, module) {
    function jpescape(s) {
      return s.replace(/\~/g, "~0").replace(/\//g, "~1");
    }
    function jpunescape(s) {
      return s.replace(/\~1/g, "/").replace(/~0/g, "~");
    }
    function jptr(obj, prop, newValue) {
      if (typeof obj === "undefined") return false;
      if (!prop || typeof prop !== "string" || prop === "#") return typeof newValue !== "undefined" ? newValue : obj;
      if (prop.indexOf("#") >= 0) {
        let parts2 = prop.split("#");
        let uri = parts2[0];
        if (uri) return false;
        prop = parts2[1];
        prop = decodeURIComponent(prop.slice(1).split("+").join(" "));
      }
      if (prop.startsWith("/")) prop = prop.slice(1);
      let components = prop.split("/");
      for (let i = 0; i < components.length; i++) {
        components[i] = jpunescape(components[i]);
        let setAndLast = typeof newValue !== "undefined" && i == components.length - 1;
        let index = parseInt(components[i], 10);
        if (!Array.isArray(obj) || isNaN(index) || index.toString() !== components[i]) {
          index = Array.isArray(obj) && components[i] === "-" ? -2 : -1;
        } else {
          components[i] = i > 0 ? components[i - 1] : "";
        }
        if (index != -1 || obj && obj.hasOwnProperty(components[i])) {
          if (index >= 0) {
            if (setAndLast) {
              obj[index] = newValue;
            }
            obj = obj[index];
          } else if (index === -2) {
            if (setAndLast) {
              if (Array.isArray(obj)) {
                obj.push(newValue);
              }
              return newValue;
            } else return void 0;
          } else {
            if (setAndLast) {
              obj[components[i]] = newValue;
            }
            obj = obj[components[i]];
          }
        } else {
          if (typeof newValue !== "undefined" && typeof obj === "object" && !Array.isArray(obj)) {
            obj[components[i]] = setAndLast ? newValue : components[i + 1] === "0" || components[i + 1] === "-" ? [] : {};
            obj = obj[components[i]];
          } else return false;
        }
      }
      return obj;
    }
    module.exports = {
      jptr,
      jpescape,
      jpunescape
    };
  }
});

// node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/isref.js
var require_isref = __commonJS({
  "node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/isref.js"(exports, module) {
    function isRef(obj, key) {
      return key === "$ref" && (!!obj && typeof obj[key] === "string");
    }
    module.exports = {
      isRef
    };
  }
});

// node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/clone.js"(exports, module) {
    function nop(obj) {
      return obj;
    }
    function clone3(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function shallowClone(obj) {
      let result = {};
      for (let p2 in obj) {
        if (obj.hasOwnProperty(p2)) {
          result[p2] = obj[p2];
        }
      }
      return result;
    }
    function deepClone(obj) {
      let result = Array.isArray(obj) ? [] : {};
      for (let p2 in obj) {
        if (obj.hasOwnProperty(p2) || Array.isArray(obj)) {
          result[p2] = typeof obj[p2] === "object" ? deepClone(obj[p2]) : obj[p2];
        }
      }
      return result;
    }
    function fastClone(obj) {
      return Object.assign({}, obj);
    }
    function circularClone(obj, hash2) {
      if (!hash2) hash2 = /* @__PURE__ */ new WeakMap();
      if (Object(obj) !== obj || obj instanceof Function) return obj;
      if (hash2.has(obj)) return hash2.get(obj);
      try {
        var result = new obj.constructor();
      } catch (e) {
        result = Object.create(Object.getPrototypeOf(obj));
      }
      hash2.set(obj, result);
      return Object.assign(result, ...Object.keys(obj).map(
        (key) => ({ [key]: circularClone(obj[key], hash2) })
      ));
    }
    module.exports = {
      nop,
      clone: clone3,
      shallowClone,
      deepClone,
      fastClone,
      circularClone
    };
  }
});

// node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/recurse.js
var require_recurse = __commonJS({
  "node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/recurse.js"(exports, module) {
    var jpescape = require_jptr().jpescape;
    function defaultState() {
      return {
        path: "#",
        depth: 0,
        pkey: "",
        parent: {},
        payload: {},
        seen: /* @__PURE__ */ new WeakMap(),
        identity: false,
        identityDetection: false
      };
    }
    function recurse(object, state, callback) {
      if (!state) state = { depth: 0 };
      if (!state.depth) {
        state = Object.assign({}, defaultState(), state);
      }
      if (typeof object !== "object") return;
      let oPath = state.path;
      for (let key in object) {
        state.key = key;
        state.path = state.path + "/" + encodeURIComponent(jpescape(key));
        state.identityPath = state.seen.get(object[key]);
        state.identity = typeof state.identityPath !== "undefined";
        if (object.hasOwnProperty(key)) {
          callback(object, key, state);
        }
        if (typeof object[key] === "object" && !state.identity) {
          if (state.identityDetection && !Array.isArray(object[key]) && object[key] !== null) {
            state.seen.set(object[key], state.path);
          }
          let newState = {};
          newState.parent = object;
          newState.path = state.path;
          newState.depth = state.depth ? state.depth + 1 : 1;
          newState.pkey = key;
          newState.payload = state.payload;
          newState.seen = state.seen;
          newState.identity = false;
          newState.identityDetection = state.identityDetection;
          recurse(object[key], newState, callback);
        }
        state.path = oPath;
      }
    }
    module.exports = {
      recurse
    };
  }
});

// node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/dereference.js
var require_dereference = __commonJS({
  "node_modules/.pnpm/reftools@1.1.9/node_modules/reftools/lib/dereference.js"(exports, module) {
    var recurse = require_recurse().recurse;
    var clone3 = require_clone().shallowClone;
    var jptr = require_jptr().jptr;
    var isRef = require_isref().isRef;
    var getLogger = function(options3) {
      if (options3 && options3.verbose) {
        return {
          warn: function() {
            var args2 = Array.prototype.slice.call(arguments);
            console.warn.apply(console, args2);
          }
        };
      } else {
        return {
          warn: function() {
          }
        };
      }
    };
    function dereference(o, definitions, options3) {
      if (!options3) options3 = {};
      if (!options3.cache) options3.cache = {};
      if (!options3.state) options3.state = {};
      options3.state.identityDetection = true;
      options3.depth = options3.depth ? options3.depth + 1 : 1;
      let obj = options3.depth > 1 ? o : clone3(o);
      let container = { data: obj };
      let defs = options3.depth > 1 ? definitions : clone3(definitions);
      if (!options3.master) options3.master = obj;
      let logger = getLogger(options3);
      let changes2 = 1;
      while (changes2 > 0) {
        changes2 = 0;
        recurse(container, options3.state, function(obj2, key, state) {
          if (isRef(obj2, key)) {
            let $ref = obj2[key];
            changes2++;
            if (!options3.cache[$ref]) {
              let entry = {};
              entry.path = state.path.split("/$ref")[0];
              entry.key = $ref;
              logger.warn("Dereffing %s at %s", $ref, entry.path);
              entry.source = defs;
              entry.data = jptr(entry.source, entry.key);
              if (entry.data === false) {
                entry.data = jptr(options3.master, entry.key);
                entry.source = options3.master;
              }
              if (entry.data === false) {
                logger.warn("Missing $ref target", entry.key);
              }
              options3.cache[$ref] = entry;
              entry.data = state.parent[state.pkey] = dereference(jptr(entry.source, entry.key), entry.source, options3);
              if (options3.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[state.pkey][options3.$ref] = $ref;
              entry.resolved = true;
            } else {
              let entry = options3.cache[$ref];
              if (entry.resolved) {
                logger.warn("Patching %s for %s", $ref, entry.path);
                state.parent[state.pkey] = entry.data;
                if (options3.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[state.pkey][options3.$ref] = $ref;
              } else if ($ref === entry.path) {
                throw new Error(`Tight circle at ${entry.path}`);
              } else {
                logger.warn("Unresolved ref");
                state.parent[state.pkey] = jptr(entry.source, entry.path);
                if (state.parent[state.pkey] === false) {
                  state.parent[state.pkey] = jptr(entry.source, entry.key);
                }
                if (options3.$ref && typeof state.parent[state.pkey] === "object" && state.parent[state.pkey] !== null) state.parent[options3.$ref] = $ref;
              }
            }
          }
        });
      }
      return container.data;
    }
    module.exports = {
      dereference
    };
  }
});

// node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify2;
    stringify2.default = stringify2;
    stringify2.stable = deterministicStringify;
    stringify2.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify2(obj, replacer, spacer, options3) {
      if (typeof options3 === "undefined") {
        options3 = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options3);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options3) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options3.depthLimit !== "undefined" && depth > options3.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options3.edgesLimit !== "undefined" && edgeIndex + 1 > options3.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options3);
          }
        } else {
          var keys5 = Object.keys(val);
          for (i = 0; i < keys5.length; i++) {
            var key = keys5[i];
            decirc(val[key], key, i, stack, val, depth, options3);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options3) {
      if (typeof options3 === "undefined") {
        options3 = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options3) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options3) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options3.depthLimit !== "undefined" && depth > options3.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options3.edgesLimit !== "undefined" && edgeIndex + 1 > options3.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options3);
          }
        } else {
          var tmp = {};
          var keys5 = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys5.length; i++) {
            var key = keys5[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options3);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/.pnpm/oas-kit-common@1.0.8/node_modules/oas-kit-common/index.js
var require_oas_kit_common = __commonJS({
  "node_modules/.pnpm/oas-kit-common@1.0.8/node_modules/oas-kit-common/index.js"(exports, module) {
    var sjs = require_fast_safe_stringify();
    var colour = process.env.NODE_DISABLE_COLORS ? { red: "", yellow: "", green: "", normal: "" } : { red: "\x1B[31m", yellow: "\x1B[33;1m", green: "\x1B[32m", normal: "\x1B[0m" };
    function uniqueOnly(value5, index, self) {
      return self.indexOf(value5) === index;
    }
    function hasDuplicates(array7) {
      return new Set(array7).size !== array7.length;
    }
    function allSame(array7) {
      return new Set(array7).size <= 1;
    }
    function deepEquals(obj1, obj2) {
      function _equals(obj12, obj22) {
        return sjs.stringify(obj12) === sjs.stringify(Object.assign({}, obj12, obj22));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    }
    function compressArray(arr) {
      let result = [];
      for (let candidate of arr) {
        let dupe = result.find(function(e, i, a) {
          return deepEquals(e, candidate);
        });
        if (!dupe) result.push(candidate);
      }
      return result;
    }
    function distinctArray(arr) {
      return arr.length === compressArray(arr).length;
    }
    function firstDupe(arr) {
      return arr.find(function(e, i, a) {
        return arr.indexOf(e) < i;
      });
    }
    function hash2(s) {
      let hash3 = 0;
      let chr;
      if (s.length === 0) return hash3;
      for (let i = 0; i < s.length; i++) {
        chr = s.charCodeAt(i);
        hash3 = (hash3 << 5) - hash3 + chr;
        hash3 |= 0;
      }
      return hash3;
    }
    String.prototype.toCamelCase = function camelize2() {
      return this.toLowerCase().replace(/[-_ \/\.](.)/g, function(match17, group1) {
        return group1.toUpperCase();
      });
    };
    var parameterTypeProperties = [
      "format",
      "minimum",
      "maximum",
      "exclusiveMinimum",
      "exclusiveMaximum",
      "minLength",
      "maxLength",
      "multipleOf",
      "minItems",
      "maxItems",
      "uniqueItems",
      "minProperties",
      "maxProperties",
      "additionalProperties",
      "pattern",
      "enum",
      "default"
    ];
    var arrayProperties = [
      "items",
      "minItems",
      "maxItems",
      "uniqueItems"
    ];
    var httpMethods = [
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
      "trace"
    ];
    function sanitise(s) {
      s = s.replace("[]", "Array");
      let components = s.split("/");
      components[0] = components[0].replace(/[^A-Za-z0-9_\-\.]+|\s+/gm, "_");
      return components.join("/");
    }
    function sanitiseAll(s) {
      return sanitise(s.split("/").join("_"));
    }
    module.exports = {
      colour,
      uniqueOnly,
      hasDuplicates,
      allSame,
      distinctArray,
      firstDupe,
      hash: hash2,
      parameterTypeProperties,
      arrayProperties,
      httpMethods,
      sanitise,
      sanitiseAll
    };
  }
});

// node_modules/.pnpm/oas-resolver@2.5.6/node_modules/oas-resolver/index.js
var require_oas_resolver = __commonJS({
  "node_modules/.pnpm/oas-resolver@2.5.6/node_modules/oas-resolver/index.js"(exports, module) {
    var fs = __require("fs");
    var path2 = __require("path");
    var url2 = __require("url");
    var fetch2 = (init_lib(), __toCommonJS(lib_exports));
    var yaml = __require("yaml");
    var jptr = require_jptr().jptr;
    var recurse = require_recurse().recurse;
    var clone3 = require_clone().clone;
    var deRef = require_dereference().dereference;
    var isRef = require_isref().isRef;
    var common = require_oas_kit_common();
    function unique(arr) {
      return [...new Set(arr)];
    }
    function readFileAsync(filename, encoding, options3, pointer, def) {
      return new Promise(function(resolve4, reject) {
        fs.readFile(filename, encoding, function(err, data) {
          if (err) {
            if (options3.ignoreIOErrors && def) {
              if (options3.verbose) console.warn("FAILED", pointer);
              options3.externalRefs[pointer].failed = true;
              resolve4(def);
            } else {
              reject(err);
            }
          } else {
            resolve4(data);
          }
        });
      });
    }
    function resolveAllFragment(obj, context7, src, parentPath, base, options3) {
      let attachPoint = options3.externalRefs[src + parentPath].paths[0];
      let baseUrl = url2.parse(base);
      let seen = {};
      let changes2 = 1;
      while (changes2) {
        changes2 = 0;
        recurse(obj, { identityDetection: true }, function(obj2, key, state) {
          if (isRef(obj2, key)) {
            if (obj2[key].startsWith("#")) {
              if (!seen[obj2[key]] && !obj2.$fixed) {
                let target = clone3(jptr(context7, obj2[key]));
                if (options3.verbose > 1) console.warn((target === false ? common.colour.red : common.colour.green) + "Fragment resolution", obj2[key], common.colour.normal);
                if (target === false) {
                  state.parent[state.pkey] = {};
                  if (options3.fatal) {
                    let ex = new Error("Fragment $ref resolution failed " + obj2[key]);
                    if (options3.promise) options3.promise.reject(ex);
                    else throw ex;
                  }
                } else {
                  changes2++;
                  state.parent[state.pkey] = target;
                  seen[obj2[key]] = state.path.replace("/%24ref", "");
                }
              } else {
                if (!obj2.$fixed) {
                  let newRef = (attachPoint + "/" + seen[obj2[key]]).split("/#/").join("/");
                  state.parent[state.pkey] = { $ref: newRef, "x-miro": obj2[key], $fixed: true };
                  if (options3.verbose > 1) console.warn("Replacing with", newRef);
                  changes2++;
                }
              }
            } else if (baseUrl.protocol) {
              let newRef = url2.resolve(base, obj2[key]).toString();
              if (options3.verbose > 1) console.warn(common.colour.yellow + "Rewriting external url ref", obj2[key], "as", newRef, common.colour.normal);
              obj2["x-miro"] = obj2[key];
              if (options3.externalRefs[obj2[key]]) {
                if (!options3.externalRefs[newRef]) {
                  options3.externalRefs[newRef] = options3.externalRefs[obj2[key]];
                }
                options3.externalRefs[newRef].failed = options3.externalRefs[obj2[key]].failed;
              }
              obj2[key] = newRef;
            } else if (!obj2["x-miro"]) {
              let newRef = url2.resolve(base, obj2[key]).toString();
              let failed2 = false;
              if (options3.externalRefs[obj2[key]]) {
                failed2 = options3.externalRefs[obj2[key]].failed;
              }
              if (!failed2) {
                if (options3.verbose > 1) console.warn(common.colour.yellow + "Rewriting external ref", obj2[key], "as", newRef, common.colour.normal);
                obj2["x-miro"] = obj2[key];
                obj2[key] = newRef;
              }
            }
          }
        });
      }
      recurse(obj, {}, function(obj2, key, state) {
        if (isRef(obj2, key)) {
          if (typeof obj2.$fixed !== "undefined") delete obj2.$fixed;
        }
      });
      if (options3.verbose > 1) console.warn("Finished fragment resolution");
      return obj;
    }
    function filterData(data, options3) {
      if (!options3.filters || !options3.filters.length) return data;
      for (let filter11 of options3.filters) {
        data = filter11(data, options3);
      }
      return data;
    }
    function testProtocol(input, backup) {
      if (input && input.length > 2) return input;
      if (backup && backup.length > 2) return backup;
      return "file:";
    }
    function resolveExternal(root2, pointer, options3, callback) {
      var u = url2.parse(options3.source);
      var base = options3.source.split("\\").join("/").split("/");
      let doc = base.pop();
      if (!doc) base.pop();
      let fragment = "";
      let fnComponents = pointer.split("#");
      if (fnComponents.length > 1) {
        fragment = "#" + fnComponents[1];
        pointer = fnComponents[0];
      }
      base = base.join("/");
      let u2 = url2.parse(pointer);
      let effectiveProtocol = testProtocol(u2.protocol, u.protocol);
      let target;
      if (effectiveProtocol === "file:") {
        target = path2.resolve(base ? base + "/" : "", pointer);
      } else {
        target = url2.resolve(base ? base + "/" : "", pointer);
      }
      if (options3.cache[target]) {
        if (options3.verbose) console.warn("CACHED", target, fragment);
        let context7 = clone3(options3.cache[target]);
        let data = options3.externalRef = context7;
        if (fragment) {
          data = jptr(data, fragment);
          if (data === false) {
            data = {};
            if (options3.fatal) {
              let ex = new Error("Cached $ref resolution failed " + target + fragment);
              if (options3.promise) options3.promise.reject(ex);
              else throw ex;
            }
          }
        }
        data = resolveAllFragment(data, context7, pointer, fragment, target, options3);
        data = filterData(data, options3);
        callback(clone3(data), target, options3);
        return Promise.resolve(data);
      }
      if (options3.verbose) console.warn("GET", target, fragment);
      if (options3.handlers && options3.handlers[effectiveProtocol]) {
        return options3.handlers[effectiveProtocol](base, pointer, fragment, options3).then(function(data) {
          options3.externalRef = data;
          data = filterData(data, options3);
          options3.cache[target] = data;
          callback(data, target, options3);
          return data;
        }).catch(function(ex) {
          if (options3.verbose) console.warn(ex);
          throw ex;
        });
      } else if (effectiveProtocol && effectiveProtocol.startsWith("http")) {
        const fetchOptions = Object.assign({}, options3.fetchOptions, { agent: options3.agent });
        return options3.fetch(target, fetchOptions).then(function(res) {
          if (res.status !== 200) {
            if (options3.ignoreIOErrors) {
              if (options3.verbose) console.warn("FAILED", pointer);
              options3.externalRefs[pointer].failed = true;
              return '{"$ref":"' + pointer + '"}';
            } else {
              throw new Error(`Received status code ${res.status}: ${target}`);
            }
          }
          return res.text();
        }).then(function(data) {
          try {
            let context7 = yaml.parse(data, { schema: "core", prettyErrors: true });
            data = options3.externalRef = context7;
            options3.cache[target] = clone3(data);
            if (fragment) {
              data = jptr(data, fragment);
              if (data === false) {
                data = {};
                if (options3.fatal) {
                  let ex = new Error("Remote $ref resolution failed " + target + fragment);
                  if (options3.promise) options3.promise.reject(ex);
                  else throw ex;
                }
              }
            }
            data = resolveAllFragment(data, context7, pointer, fragment, target, options3);
            data = filterData(data, options3);
          } catch (ex) {
            if (options3.verbose) console.warn(ex);
            if (options3.promise && options3.fatal) options3.promise.reject(ex);
            else throw ex;
          }
          callback(data, target, options3);
          return data;
        }).catch(function(err) {
          if (options3.verbose) console.warn(err);
          options3.cache[target] = {};
          if (options3.promise && options3.fatal) options3.promise.reject(err);
          else throw err;
        });
      } else {
        const def = '{"$ref":"' + pointer + '"}';
        return readFileAsync(target, options3.encoding || "utf8", options3, pointer, def).then(function(data) {
          try {
            let context7 = yaml.parse(data, { schema: "core", prettyErrors: true });
            data = options3.externalRef = context7;
            options3.cache[target] = clone3(data);
            if (fragment) {
              data = jptr(data, fragment);
              if (data === false) {
                data = {};
                if (options3.fatal) {
                  let ex = new Error("File $ref resolution failed " + target + fragment);
                  if (options3.promise) options3.promise.reject(ex);
                  else throw ex;
                }
              }
            }
            data = resolveAllFragment(data, context7, pointer, fragment, target, options3);
            data = filterData(data, options3);
          } catch (ex) {
            if (options3.verbose) console.warn(ex);
            if (options3.promise && options3.fatal) options3.promise.reject(ex);
            else throw ex;
          }
          callback(data, target, options3);
          return data;
        }).catch(function(err) {
          if (options3.verbose) console.warn(err);
          if (options3.promise && options3.fatal) options3.promise.reject(err);
          else throw err;
        });
      }
    }
    function scanExternalRefs(options3) {
      return new Promise(function(res, rej) {
        function inner(obj, key, state) {
          if (obj[key] && isRef(obj[key], "$ref")) {
            let $ref = obj[key].$ref;
            if (!$ref.startsWith("#")) {
              let $extra = "";
              if (!refs[$ref]) {
                let potential = Object.keys(refs).find(function(e, i, a) {
                  return $ref.startsWith(e + "/");
                });
                if (potential) {
                  if (options3.verbose) console.warn("Found potential subschema at", potential);
                  $extra = "/" + ($ref.split("#")[1] || "").replace(potential.split("#")[1] || "");
                  $extra = $extra.split("/undefined").join("");
                  $ref = potential;
                }
              }
              if (!refs[$ref]) {
                refs[$ref] = { resolved: false, paths: [], extras: {}, description: obj[key].description };
              }
              if (refs[$ref].resolved) {
                if (refs[$ref].failed) ; else if (options3.rewriteRefs) {
                  let newRef = refs[$ref].resolvedAt;
                  if (options3.verbose > 1) console.warn("Rewriting ref", $ref, newRef);
                  obj[key]["x-miro"] = $ref;
                  obj[key].$ref = newRef + $extra;
                } else {
                  obj[key] = clone3(refs[$ref].data);
                }
              } else {
                refs[$ref].paths.push(state.path);
                refs[$ref].extras[state.path] = $extra;
              }
            }
          }
        }
        let refs = options3.externalRefs;
        if (options3.resolver.depth > 0 && options3.source === options3.resolver.base) {
          return res(refs);
        }
        recurse(options3.openapi.definitions, { identityDetection: true, path: "#/definitions" }, inner);
        recurse(options3.openapi.components, { identityDetection: true, path: "#/components" }, inner);
        recurse(options3.openapi, { identityDetection: true }, inner);
        res(refs);
      });
    }
    function findExternalRefs(options3) {
      return new Promise(function(res, rej) {
        scanExternalRefs(options3).then(function(refs) {
          for (let ref in refs) {
            if (!refs[ref].resolved) {
              let depth = options3.resolver.depth;
              if (depth > 0) depth++;
              options3.resolver.actions[depth].push(function() {
                return resolveExternal(options3.openapi, ref, options3, function(data, source, options4) {
                  if (!refs[ref].resolved) {
                    let external = {};
                    external.context = refs[ref];
                    external.$ref = ref;
                    external.original = clone3(data);
                    external.updated = data;
                    external.source = source;
                    options4.externals.push(external);
                    refs[ref].resolved = true;
                  }
                  let localOptions = Object.assign({}, options4, {
                    source: "",
                    resolver: {
                      actions: options4.resolver.actions,
                      depth: options4.resolver.actions.length - 1,
                      base: options4.resolver.base
                    }
                  });
                  if (options4.patch && refs[ref].description && !data.description && typeof data === "object") {
                    data.description = refs[ref].description;
                  }
                  refs[ref].data = data;
                  let pointers = unique(refs[ref].paths);
                  pointers = pointers.sort(function(a, b) {
                    const aComp = a.startsWith("#/components/") || a.startsWith("#/definitions/");
                    const bComp = b.startsWith("#/components/") || b.startsWith("#/definitions/");
                    if (aComp && !bComp) return -1;
                    if (bComp && !aComp) return 1;
                    return 0;
                  });
                  for (let ptr of pointers) {
                    if (refs[ref].resolvedAt && ptr !== refs[ref].resolvedAt && ptr.indexOf("x-ms-examples/") < 0) {
                      if (options4.verbose > 1) console.warn("Creating pointer to data at", ptr);
                      jptr(options4.openapi, ptr, { $ref: refs[ref].resolvedAt + refs[ref].extras[ptr], "x-miro": ref + refs[ref].extras[ptr] });
                    } else {
                      if (refs[ref].resolvedAt) {
                        if (options4.verbose > 1) console.warn("Avoiding circular reference");
                      } else {
                        refs[ref].resolvedAt = ptr;
                        if (options4.verbose > 1) console.warn("Creating initial clone of data at", ptr);
                      }
                      let cdata = clone3(data);
                      jptr(options4.openapi, ptr, cdata);
                    }
                  }
                  if (options4.resolver.actions[localOptions.resolver.depth].length === 0) {
                    options4.resolver.actions[localOptions.resolver.depth].push(function() {
                      return findExternalRefs(localOptions);
                    });
                  }
                });
              });
            }
          }
        }).catch(function(ex) {
          if (options3.verbose) console.warn(ex);
          rej(ex);
        });
        let result = { options: options3 };
        result.actions = options3.resolver.actions[options3.resolver.depth];
        res(result);
      });
    }
    var serial = (funcs) => funcs.reduce((promise3, func) => promise3.then((result) => func().then(Array.prototype.concat.bind(result))), Promise.resolve([]));
    function loopReferences(options3, res, rej) {
      options3.resolver.actions.push([]);
      findExternalRefs(options3).then(function(data) {
        serial(data.actions).then(function() {
          if (options3.resolver.depth >= options3.resolver.actions.length) {
            console.warn("Ran off the end of resolver actions");
            return res(true);
          } else {
            options3.resolver.depth++;
            if (options3.resolver.actions[options3.resolver.depth].length) {
              setTimeout(function() {
                loopReferences(data.options, res, rej);
              }, 0);
            } else {
              if (options3.verbose > 1) console.warn(common.colour.yellow + "Finished external resolution!", common.colour.normal);
              if (options3.resolveInternal) {
                if (options3.verbose > 1) console.warn(common.colour.yellow + "Starting internal resolution!", common.colour.normal);
                options3.openapi = deRef(options3.openapi, options3.original, { verbose: options3.verbose - 1 });
                if (options3.verbose > 1) console.warn(common.colour.yellow + "Finished internal resolution!", common.colour.normal);
              }
              recurse(options3.openapi, {}, function(obj, key, state) {
                if (isRef(obj, key)) {
                  if (!options3.preserveMiro) delete obj["x-miro"];
                }
              });
              res(options3);
            }
          }
        }).catch(function(ex) {
          if (options3.verbose) console.warn(ex);
          rej(ex);
        });
      }).catch(function(ex) {
        if (options3.verbose) console.warn(ex);
        rej(ex);
      });
    }
    function setupOptions(options3) {
      if (!options3.cache) options3.cache = {};
      if (!options3.fetch) options3.fetch = fetch2;
      if (options3.source) {
        let srcUrl = url2.parse(options3.source);
        if (!srcUrl.protocol || srcUrl.protocol.length <= 2) {
          options3.source = path2.resolve(options3.source);
        }
      }
      options3.externals = [];
      options3.externalRefs = {};
      options3.rewriteRefs = true;
      options3.resolver = {};
      options3.resolver.depth = 0;
      options3.resolver.base = options3.source;
      options3.resolver.actions = [[]];
    }
    function optionalResolve(options3) {
      setupOptions(options3);
      return new Promise(function(res, rej) {
        if (options3.resolve)
          loopReferences(options3, res, rej);
        else
          res(options3);
      });
    }
    function resolve3(openapi, source, options3) {
      if (!options3) options3 = {};
      options3.openapi = openapi;
      options3.source = source;
      options3.resolve = true;
      setupOptions(options3);
      return new Promise(function(res, rej) {
        loopReferences(options3, res, rej);
      });
    }
    module.exports = {
      optionalResolve,
      resolve: resolve3
    };
  }
});

// node_modules/.pnpm/oas-schema-walker@1.1.5/node_modules/oas-schema-walker/index.js
var require_oas_schema_walker = __commonJS({
  "node_modules/.pnpm/oas-schema-walker@1.1.5/node_modules/oas-schema-walker/index.js"(exports, module) {
    function getDefaultState() {
      return { depth: 0, seen: /* @__PURE__ */ new WeakMap(), top: true, combine: false, allowRefSiblings: false };
    }
    function walkSchema(schema, parent, state, callback) {
      if (typeof state.depth === "undefined") state = getDefaultState();
      if (schema === null || typeof schema === "undefined") return schema;
      if (typeof schema.$ref !== "undefined") {
        let temp = { $ref: schema.$ref };
        if (state.allowRefSiblings && schema.description) {
          temp.description = schema.description;
        }
        callback(temp, parent, state);
        return temp;
      }
      if (state.combine) {
        if (schema.allOf && Array.isArray(schema.allOf) && schema.allOf.length === 1) {
          schema = Object.assign({}, schema.allOf[0], schema);
          delete schema.allOf;
        }
        if (schema.anyOf && Array.isArray(schema.anyOf) && schema.anyOf.length === 1) {
          schema = Object.assign({}, schema.anyOf[0], schema);
          delete schema.anyOf;
        }
        if (schema.oneOf && Array.isArray(schema.oneOf) && schema.oneOf.length === 1) {
          schema = Object.assign({}, schema.oneOf[0], schema);
          delete schema.oneOf;
        }
      }
      callback(schema, parent, state);
      if (state.seen.has(schema)) {
        return schema;
      }
      if (typeof schema === "object" && schema !== null) state.seen.set(schema, true);
      state.top = false;
      state.depth++;
      if (typeof schema.items !== "undefined") {
        state.property = "items";
        walkSchema(schema.items, schema, state, callback);
      }
      if (schema.additionalItems) {
        if (typeof schema.additionalItems === "object") {
          state.property = "additionalItems";
          walkSchema(schema.additionalItems, schema, state, callback);
        }
      }
      if (schema.additionalProperties) {
        if (typeof schema.additionalProperties === "object") {
          state.property = "additionalProperties";
          walkSchema(schema.additionalProperties, schema, state, callback);
        }
      }
      if (schema.properties) {
        for (let prop in schema.properties) {
          let subSchema = schema.properties[prop];
          state.property = "properties/" + prop;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.patternProperties) {
        for (let prop in schema.patternProperties) {
          let subSchema = schema.patternProperties[prop];
          state.property = "patternProperties/" + prop;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.allOf) {
        for (let index in schema.allOf) {
          let subSchema = schema.allOf[index];
          state.property = "allOf/" + index;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.anyOf) {
        for (let index in schema.anyOf) {
          let subSchema = schema.anyOf[index];
          state.property = "anyOf/" + index;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.oneOf) {
        for (let index in schema.oneOf) {
          let subSchema = schema.oneOf[index];
          state.property = "oneOf/" + index;
          walkSchema(subSchema, schema, state, callback);
        }
      }
      if (schema.not) {
        state.property = "not";
        walkSchema(schema.not, schema, state, callback);
      }
      state.depth--;
      return schema;
    }
    module.exports = {
      getDefaultState,
      walkSchema
    };
  }
});

// node_modules/.pnpm/swagger2openapi@7.0.8/node_modules/swagger2openapi/lib/statusCodes.js
var require_statusCodes = __commonJS({
  "node_modules/.pnpm/swagger2openapi@7.0.8/node_modules/swagger2openapi/lib/statusCodes.js"(exports, module) {
    var http2 = __require("http");
    var ours = {
      "default": "Default response",
      "1XX": "Informational",
      "103": "Early hints",
      // not in Node < 10
      "2XX": "Successful",
      "3XX": "Redirection",
      "4XX": "Client Error",
      "5XX": "Server Error",
      "7XX": "Developer Error"
      // April fools RFC
    };
    module.exports = {
      statusCodes: Object.assign({}, ours, http2.STATUS_CODES)
    };
  }
});

// node_modules/.pnpm/swagger2openapi@7.0.8/node_modules/swagger2openapi/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/swagger2openapi@7.0.8/node_modules/swagger2openapi/package.json"(exports, module) {
    module.exports = {
      name: "swagger2openapi",
      version: "7.0.8",
      description: "Convert Swagger 2.0 definitions to OpenApi 3.0 and validate",
      main: "index.js",
      bin: {
        swagger2openapi: "./swagger2openapi.js",
        "oas-validate": "./oas-validate.js",
        boast: "./boast.js"
      },
      funding: "https://github.com/Mermade/oas-kit?sponsor=1",
      scripts: {
        test: "mocha"
      },
      browserify: {
        transform: [
          [
            "babelify",
            {
              presets: [
                "es2015"
              ]
            }
          ]
        ]
      },
      repository: {
        url: "https://github.com/Mermade/oas-kit.git",
        type: "git"
      },
      bugs: {
        url: "https://github.com/mermade/oas-kit/issues"
      },
      author: "Mike Ralphson <mike.ralphson@gmail.com>",
      license: "BSD-3-Clause",
      dependencies: {
        "call-me-maybe": "^1.0.1",
        "node-fetch": "^2.6.1",
        "node-fetch-h2": "^2.3.0",
        "node-readfiles": "^0.2.0",
        "oas-kit-common": "^1.0.8",
        "oas-resolver": "^2.5.6",
        "oas-schema-walker": "^1.1.5",
        "oas-validator": "^5.0.8",
        reftools: "^1.1.9",
        yaml: "^1.10.0",
        yargs: "^17.0.1"
      },
      keywords: [
        "swagger",
        "openapi",
        "openapi2",
        "openapi3",
        "converter",
        "conversion",
        "validator",
        "validation",
        "resolver",
        "lint",
        "linter"
      ],
      gitHead: "b1bba3fc5007e96a991bf2a015cf0534ac36b88b"
    };
  }
});

// node_modules/.pnpm/swagger2openapi@7.0.8/node_modules/swagger2openapi/index.js
var require_swagger2openapi = __commonJS({
  "node_modules/.pnpm/swagger2openapi@7.0.8/node_modules/swagger2openapi/index.js"(exports, module) {
    var fs = __require("fs");
    var url2 = __require("url");
    __require("path");
    var maybe = require_maybe();
    var fetch2 = (init_lib(), __toCommonJS(lib_exports));
    var yaml = __require("yaml");
    var jptr = require_jptr();
    var resolveInternal = jptr.jptr;
    var isRef = require_isref().isRef;
    var clone3 = require_clone().clone;
    var cclone = require_clone().circularClone;
    var recurse = require_recurse().recurse;
    var resolver = require_oas_resolver();
    var sw = require_oas_schema_walker();
    var common = require_oas_kit_common();
    var statusCodes = require_statusCodes().statusCodes;
    var ourVersion = require_package().version;
    var targetVersion = "3.0.0";
    var componentNames;
    var S2OError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "S2OError";
      }
    };
    function throwError(message, options3) {
      let err = new S2OError(message);
      err.options = options3;
      if (options3.promise) {
        options3.promise.reject(err);
      } else {
        throw err;
      }
    }
    function throwOrWarn(message, container, options3) {
      if (options3.warnOnly) {
        container[options3.warnProperty || "x-s2o-warning"] = message;
      } else {
        throwError(message, options3);
      }
    }
    function fixUpSubSchema(schema, parent, options3) {
      if (schema.nullable) options3.patches++;
      if (schema.discriminator && typeof schema.discriminator === "string") {
        schema.discriminator = { propertyName: schema.discriminator };
      }
      if (schema.items && Array.isArray(schema.items)) {
        if (schema.items.length === 0) {
          schema.items = {};
        } else if (schema.items.length === 1) {
          schema.items = schema.items[0];
        } else schema.items = { anyOf: schema.items };
      }
      if (schema.type && Array.isArray(schema.type)) {
        if (options3.patch) {
          options3.patches++;
          if (schema.type.length === 0) {
            delete schema.type;
          } else {
            if (!schema.oneOf) schema.oneOf = [];
            for (let type2 of schema.type) {
              let newSchema = {};
              if (type2 === "null") {
                schema.nullable = true;
              } else {
                newSchema.type = type2;
                for (let prop of common.arrayProperties) {
                  if (typeof schema.prop !== "undefined") {
                    newSchema[prop] = schema[prop];
                    delete schema[prop];
                  }
                }
              }
              if (newSchema.type) {
                schema.oneOf.push(newSchema);
              }
            }
            delete schema.type;
            if (schema.oneOf.length === 0) {
              delete schema.oneOf;
            } else if (schema.oneOf.length < 2) {
              schema.type = schema.oneOf[0].type;
              if (Object.keys(schema.oneOf[0]).length > 1) {
                throwOrWarn("Lost properties from oneOf", schema, options3);
              }
              delete schema.oneOf;
            }
          }
          if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
            schema.type = schema.type[0];
          }
        } else {
          throwError("(Patchable) schema type must not be an array", options3);
        }
      }
      if (schema.type && schema.type === "null") {
        delete schema.type;
        schema.nullable = true;
      }
      if (schema.type === "array" && !schema.items) {
        schema.items = {};
      }
      if (schema.type === "file") {
        schema.type = "string";
        schema.format = "binary";
      }
      if (typeof schema.required === "boolean") {
        if (schema.required && schema.name) {
          if (typeof parent.required === "undefined") {
            parent.required = [];
          }
          if (Array.isArray(parent.required)) parent.required.push(schema.name);
        }
        delete schema.required;
      }
      if (schema.xml && typeof schema.xml.namespace === "string") {
        if (!schema.xml.namespace) delete schema.xml.namespace;
      }
      if (typeof schema.allowEmptyValue !== "undefined") {
        options3.patches++;
        delete schema.allowEmptyValue;
      }
    }
    function fixUpSubSchemaExtensions(schema, parent) {
      if (schema["x-required"] && Array.isArray(schema["x-required"])) {
        if (!schema.required) schema.required = [];
        schema.required = schema.required.concat(schema["x-required"]);
        delete schema["x-required"];
      }
      if (schema["x-anyOf"]) {
        schema.anyOf = schema["x-anyOf"];
        delete schema["x-anyOf"];
      }
      if (schema["x-oneOf"]) {
        schema.oneOf = schema["x-oneOf"];
        delete schema["x-oneOf"];
      }
      if (schema["x-not"]) {
        schema.not = schema["x-not"];
        delete schema["x-not"];
      }
      if (typeof schema["x-nullable"] === "boolean") {
        schema.nullable = schema["x-nullable"];
        delete schema["x-nullable"];
      }
      if (typeof schema["x-discriminator"] === "object" && typeof schema["x-discriminator"].propertyName === "string") {
        schema.discriminator = schema["x-discriminator"];
        delete schema["x-discriminator"];
        for (let entry in schema.discriminator.mapping) {
          let schemaOrRef = schema.discriminator.mapping[entry];
          if (schemaOrRef.startsWith("#/definitions/")) {
            schema.discriminator.mapping[entry] = schemaOrRef.replace("#/definitions/", "#/components/schemas/");
          }
        }
      }
    }
    function fixUpSchema(schema, options3) {
      sw.walkSchema(schema, {}, {}, function(schema2, parent, state) {
        fixUpSubSchemaExtensions(schema2);
        fixUpSubSchema(schema2, parent, options3);
      });
    }
    function getMiroComponentName(ref) {
      if (ref.indexOf("#") >= 0) {
        ref = ref.split("#")[1].split("/").pop();
      } else {
        ref = ref.split("/").pop().split(".")[0];
      }
      return encodeURIComponent(common.sanitise(ref));
    }
    function fixupRefs(obj, key, state) {
      let options3 = state.payload.options;
      if (isRef(obj, key)) {
        if (obj[key].startsWith("#/components/")) ; else if (obj[key] === "#/consumes") {
          delete obj[key];
          state.parent[state.pkey] = clone3(options3.openapi.consumes);
        } else if (obj[key] === "#/produces") {
          delete obj[key];
          state.parent[state.pkey] = clone3(options3.openapi.produces);
        } else if (obj[key].startsWith("#/definitions/")) {
          let keys5 = obj[key].replace("#/definitions/", "").split("/");
          const ref = jptr.jpunescape(keys5[0]);
          let newKey = componentNames.schemas[decodeURIComponent(ref)];
          if (newKey) {
            keys5[0] = newKey;
          } else {
            throwOrWarn("Could not resolve reference " + obj[key], obj, options3);
          }
          obj[key] = "#/components/schemas/" + keys5.join("/");
        } else if (obj[key].startsWith("#/parameters/")) {
          obj[key] = "#/components/parameters/" + common.sanitise(obj[key].replace("#/parameters/", ""));
        } else if (obj[key].startsWith("#/responses/")) {
          obj[key] = "#/components/responses/" + common.sanitise(obj[key].replace("#/responses/", ""));
        } else if (obj[key].startsWith("#")) {
          let target = clone3(jptr.jptr(options3.openapi, obj[key]));
          if (target === false) throwOrWarn("direct $ref not found " + obj[key], obj, options3);
          else if (options3.refmap[obj[key]]) {
            obj[key] = options3.refmap[obj[key]];
          } else {
            let oldRef = obj[key];
            oldRef = oldRef.replace("/properties/headers/", "");
            oldRef = oldRef.replace("/properties/responses/", "");
            oldRef = oldRef.replace("/properties/parameters/", "");
            oldRef = oldRef.replace("/properties/schemas/", "");
            let type2 = "schemas";
            let schemaIndex = oldRef.lastIndexOf("/schema");
            type2 = oldRef.indexOf("/headers/") > schemaIndex ? "headers" : oldRef.indexOf("/responses/") > schemaIndex ? "responses" : oldRef.indexOf("/example") > schemaIndex ? "examples" : oldRef.indexOf("/x-") > schemaIndex ? "extensions" : oldRef.indexOf("/parameters/") > schemaIndex ? "parameters" : "schemas";
            if (type2 === "schemas") {
              fixUpSchema(target, options3);
            }
            if (type2 !== "responses" && type2 !== "extensions") {
              let prefix = type2.substr(0, type2.length - 1);
              if (prefix === "parameter" && target.name && target.name === common.sanitise(target.name)) {
                prefix = encodeURIComponent(target.name);
              }
              let suffix = 1;
              if (obj["x-miro"]) {
                prefix = getMiroComponentName(obj["x-miro"]);
                suffix = "";
              }
              while (jptr.jptr(options3.openapi, "#/components/" + type2 + "/" + prefix + suffix)) {
                suffix = suffix === "" ? 2 : ++suffix;
              }
              let newRef = "#/components/" + type2 + "/" + prefix + suffix;
              let refSuffix = "";
              if (type2 === "examples") {
                target = { value: target };
                refSuffix = "/value";
              }
              jptr.jptr(options3.openapi, newRef, target);
              options3.refmap[obj[key]] = newRef + refSuffix;
              obj[key] = newRef + refSuffix;
            }
          }
        }
        delete obj["x-miro"];
        if (Object.keys(obj).length > 1) {
          const tmpRef = obj[key];
          const inSchema = state.path.indexOf("/schema") >= 0;
          if (options3.refSiblings === "preserve") ; else if (inSchema && options3.refSiblings === "allOf") {
            delete obj.$ref;
            state.parent[state.pkey] = { allOf: [{ $ref: tmpRef }, obj] };
          } else {
            state.parent[state.pkey] = { $ref: tmpRef };
          }
        }
      }
      if (key === "x-ms-odata" && typeof obj[key] === "string" && obj[key].startsWith("#/")) {
        let keys5 = obj[key].replace("#/definitions/", "").replace("#/components/schemas/", "").split("/");
        let newKey = componentNames.schemas[decodeURIComponent(keys5[0])];
        if (newKey) {
          keys5[0] = newKey;
        } else {
          throwOrWarn("Could not resolve reference " + obj[key], obj, options3);
        }
        obj[key] = "#/components/schemas/" + keys5.join("/");
      }
    }
    function dedupeRefs(openapi, options3) {
      for (let ref in options3.refmap) {
        jptr.jptr(openapi, ref, { $ref: options3.refmap[ref] });
      }
    }
    function processSecurity(securityObject) {
      for (let s in securityObject) {
        for (let k in securityObject[s]) {
          let sname = common.sanitise(k);
          if (k !== sname) {
            securityObject[s][sname] = securityObject[s][k];
            delete securityObject[s][k];
          }
        }
      }
    }
    function processSecurityScheme(scheme, options3) {
      if (scheme.type === "basic") {
        scheme.type = "http";
        scheme.scheme = "basic";
      }
      if (scheme.type === "oauth2") {
        let flow2 = {};
        let flowName = scheme.flow;
        if (scheme.flow === "application") flowName = "clientCredentials";
        if (scheme.flow === "accessCode") flowName = "authorizationCode";
        if (typeof scheme.authorizationUrl !== "undefined") flow2.authorizationUrl = scheme.authorizationUrl.split("?")[0].trim() || "/";
        if (typeof scheme.tokenUrl === "string") flow2.tokenUrl = scheme.tokenUrl.split("?")[0].trim() || "/";
        flow2.scopes = scheme.scopes || {};
        scheme.flows = {};
        scheme.flows[flowName] = flow2;
        delete scheme.flow;
        delete scheme.authorizationUrl;
        delete scheme.tokenUrl;
        delete scheme.scopes;
        if (typeof scheme.name !== "undefined") {
          if (options3.patch) {
            options3.patches++;
            delete scheme.name;
          } else {
            throwError("(Patchable) oauth2 securitySchemes should not have name property", options3);
          }
        }
      }
    }
    function keepParameters(value5) {
      return value5 && !value5["x-s2o-delete"];
    }
    function processHeader(header, options3) {
      if (header.$ref) {
        header.$ref = header.$ref.replace("#/responses/", "#/components/responses/");
      } else {
        if (header.type && !header.schema) {
          header.schema = {};
        }
        if (header.type) header.schema.type = header.type;
        if (header.items && header.items.type !== "array") {
          if (header.items.collectionFormat !== header.collectionFormat) {
            throwOrWarn("Nested collectionFormats are not supported", header, options3);
          }
          delete header.items.collectionFormat;
        }
        if (header.type === "array") {
          if (header.collectionFormat === "ssv") {
            throwOrWarn("collectionFormat:ssv is no longer supported for headers", header, options3);
          } else if (header.collectionFormat === "pipes") {
            throwOrWarn("collectionFormat:pipes is no longer supported for headers", header, options3);
          } else if (header.collectionFormat === "multi") {
            header.explode = true;
          } else if (header.collectionFormat === "tsv") {
            throwOrWarn("collectionFormat:tsv is no longer supported", header, options3);
            header["x-collectionFormat"] = "tsv";
          } else {
            header.style = "simple";
          }
          delete header.collectionFormat;
        } else if (header.collectionFormat) {
          if (options3.patch) {
            options3.patches++;
            delete header.collectionFormat;
          } else {
            throwError("(Patchable) collectionFormat is only applicable to header.type array", options3);
          }
        }
        delete header.type;
        for (let prop of common.parameterTypeProperties) {
          if (typeof header[prop] !== "undefined") {
            header.schema[prop] = header[prop];
            delete header[prop];
          }
        }
        for (let prop of common.arrayProperties) {
          if (typeof header[prop] !== "undefined") {
            header.schema[prop] = header[prop];
            delete header[prop];
          }
        }
      }
    }
    function fixParamRef(param, options3) {
      if (param.$ref.indexOf("#/parameters/") >= 0) {
        let refComponents = param.$ref.split("#/parameters/");
        param.$ref = refComponents[0] + "#/components/parameters/" + common.sanitise(refComponents[1]);
      }
      if (param.$ref.indexOf("#/definitions/") >= 0) {
        throwOrWarn("Definition used as parameter", param, options3);
      }
    }
    function attachRequestBody(op, options3) {
      let newOp = {};
      for (let key of Object.keys(op)) {
        newOp[key] = op[key];
        if (key === "parameters") {
          newOp.requestBody = {};
          if (options3.rbname) newOp[options3.rbname] = "";
        }
      }
      newOp.requestBody = {};
      return newOp;
    }
    function processParameter(param, op, path2, method, index, openapi, options3) {
      let result = {};
      let singularRequestBody = true;
      let originalType;
      if (op && op.consumes && typeof op.consumes === "string") {
        if (options3.patch) {
          options3.patches++;
          op.consumes = [op.consumes];
        } else {
          return throwError("(Patchable) operation.consumes must be an array", options3);
        }
      }
      if (!Array.isArray(openapi.consumes)) delete openapi.consumes;
      let consumes = ((op ? op.consumes : null) || (openapi.consumes || [])).filter(common.uniqueOnly);
      if (param && param.$ref && typeof param.$ref === "string") {
        fixParamRef(param, options3);
        let ptr = decodeURIComponent(param.$ref.replace("#/components/parameters/", ""));
        let rbody = false;
        let target = openapi.components.parameters[ptr];
        if ((!target || target["x-s2o-delete"]) && param.$ref.startsWith("#/")) {
          param["x-s2o-delete"] = true;
          rbody = true;
        }
        if (rbody) {
          let ref = param.$ref;
          let newParam = resolveInternal(openapi, param.$ref);
          if (!newParam && ref.startsWith("#/")) {
            throwOrWarn("Could not resolve reference " + ref, param, options3);
          } else {
            if (newParam) param = newParam;
          }
        }
      }
      if (param && (param.name || param.in)) {
        if (typeof param["x-deprecated"] === "boolean") {
          param.deprecated = param["x-deprecated"];
          delete param["x-deprecated"];
        }
        if (typeof param["x-example"] !== "undefined") {
          param.example = param["x-example"];
          delete param["x-example"];
        }
        if (param.in !== "body" && !param.type) {
          if (options3.patch) {
            options3.patches++;
            param.type = "string";
          } else {
            throwError("(Patchable) parameter.type is mandatory for non-body parameters", options3);
          }
        }
        if (param.type && typeof param.type === "object" && param.type.$ref) {
          param.type = resolveInternal(openapi, param.type.$ref);
        }
        if (param.type === "file") {
          param["x-s2o-originalType"] = param.type;
          originalType = param.type;
        }
        if (param.description && typeof param.description === "object" && param.description.$ref) {
          param.description = resolveInternal(openapi, param.description.$ref);
        }
        if (param.description === null) delete param.description;
        let oldCollectionFormat = param.collectionFormat;
        if (param.type === "array" && !oldCollectionFormat) {
          oldCollectionFormat = "csv";
        }
        if (oldCollectionFormat) {
          if (param.type !== "array") {
            if (options3.patch) {
              options3.patches++;
              delete param.collectionFormat;
            } else {
              throwError("(Patchable) collectionFormat is only applicable to param.type array", options3);
            }
          }
          if (oldCollectionFormat === "csv" && (param.in === "query" || param.in === "cookie")) {
            param.style = "form";
            param.explode = false;
          }
          if (oldCollectionFormat === "csv" && (param.in === "path" || param.in === "header")) {
            param.style = "simple";
          }
          if (oldCollectionFormat === "ssv") {
            if (param.in === "query") {
              param.style = "spaceDelimited";
            } else {
              throwOrWarn("collectionFormat:ssv is no longer supported except for in:query parameters", param, options3);
            }
          }
          if (oldCollectionFormat === "pipes") {
            if (param.in === "query") {
              param.style = "pipeDelimited";
            } else {
              throwOrWarn("collectionFormat:pipes is no longer supported except for in:query parameters", param, options3);
            }
          }
          if (oldCollectionFormat === "multi") {
            param.explode = true;
          }
          if (oldCollectionFormat === "tsv") {
            throwOrWarn("collectionFormat:tsv is no longer supported", param, options3);
            param["x-collectionFormat"] = "tsv";
          }
          delete param.collectionFormat;
        }
        if (param.type && param.type !== "body" && param.in !== "formData") {
          if (param.items && param.schema) {
            throwOrWarn("parameter has array,items and schema", param, options3);
          } else {
            if (param.schema) options3.patches++;
            if (!param.schema || typeof param.schema !== "object") param.schema = {};
            param.schema.type = param.type;
            if (param.items) {
              param.schema.items = param.items;
              delete param.items;
              recurse(param.schema.items, null, function(obj, key, state) {
                if (key === "collectionFormat" && typeof obj[key] === "string") {
                  if (oldCollectionFormat && obj[key] !== oldCollectionFormat) {
                    throwOrWarn("Nested collectionFormats are not supported", param, options3);
                  }
                  delete obj[key];
                }
              });
            }
            for (let prop of common.parameterTypeProperties) {
              if (typeof param[prop] !== "undefined") param.schema[prop] = param[prop];
              delete param[prop];
            }
          }
        }
        if (param.schema) {
          fixUpSchema(param.schema, options3);
        }
        if (param["x-ms-skip-url-encoding"]) {
          if (param.in === "query") {
            param.allowReserved = true;
            delete param["x-ms-skip-url-encoding"];
          }
        }
      }
      if (param && param.in === "formData") {
        singularRequestBody = false;
        result.content = {};
        let contentType = "application/x-www-form-urlencoded";
        if (consumes.length && consumes.indexOf("multipart/form-data") >= 0) {
          contentType = "multipart/form-data";
        }
        result.content[contentType] = {};
        if (param.schema) {
          result.content[contentType].schema = param.schema;
          if (param.schema.$ref) {
            result["x-s2o-name"] = decodeURIComponent(param.schema.$ref.replace("#/components/schemas/", ""));
          }
        } else {
          result.content[contentType].schema = {};
          result.content[contentType].schema.type = "object";
          result.content[contentType].schema.properties = {};
          result.content[contentType].schema.properties[param.name] = {};
          let schema = result.content[contentType].schema;
          let target = result.content[contentType].schema.properties[param.name];
          if (param.description) target.description = param.description;
          if (param.example) target.example = param.example;
          if (param.type) target.type = param.type;
          for (let prop of common.parameterTypeProperties) {
            if (typeof param[prop] !== "undefined") target[prop] = param[prop];
          }
          if (param.required === true) {
            if (!schema.required) schema.required = [];
            schema.required.push(param.name);
            result.required = true;
          }
          if (typeof param.default !== "undefined") target.default = param.default;
          if (target.properties) target.properties = param.properties;
          if (param.allOf) target.allOf = param.allOf;
          if (param.type === "array" && param.items) {
            target.items = param.items;
            if (target.items.collectionFormat) delete target.items.collectionFormat;
          }
          if (originalType === "file" || param["x-s2o-originalType"] === "file") {
            target.type = "string";
            target.format = "binary";
          }
          copyExtensions(param, target);
        }
      } else if (param && param.type === "file") {
        if (param.required) result.required = param.required;
        result.content = {};
        result.content["application/octet-stream"] = {};
        result.content["application/octet-stream"].schema = {};
        result.content["application/octet-stream"].schema.type = "string";
        result.content["application/octet-stream"].schema.format = "binary";
        copyExtensions(param, result);
      }
      if (param && param.in === "body") {
        result.content = {};
        if (param.name) result["x-s2o-name"] = (op && op.operationId ? common.sanitiseAll(op.operationId) : "") + ("_" + param.name).toCamelCase();
        if (param.description) result.description = param.description;
        if (param.required) result.required = param.required;
        if (op && options3.rbname && param.name) {
          op[options3.rbname] = param.name;
        }
        if (param.schema && param.schema.$ref) {
          result["x-s2o-name"] = decodeURIComponent(param.schema.$ref.replace("#/components/schemas/", ""));
        } else if (param.schema && param.schema.type === "array" && param.schema.items && param.schema.items.$ref) {
          result["x-s2o-name"] = decodeURIComponent(param.schema.items.$ref.replace("#/components/schemas/", "")) + "Array";
        }
        if (!consumes.length) {
          consumes.push("application/json");
        }
        for (let mimetype of consumes) {
          result.content[mimetype] = {};
          result.content[mimetype].schema = clone3(param.schema || {});
          fixUpSchema(result.content[mimetype].schema, options3);
        }
        copyExtensions(param, result);
      }
      if (Object.keys(result).length > 0) {
        param["x-s2o-delete"] = true;
        if (op) {
          if (op.requestBody && singularRequestBody) {
            op.requestBody["x-s2o-overloaded"] = true;
            let opId = op.operationId || index;
            throwOrWarn("Operation " + opId + " has multiple requestBodies", op, options3);
          } else {
            if (!op.requestBody) {
              op = path2[method] = attachRequestBody(op, options3);
            }
            if (op.requestBody.content && op.requestBody.content["multipart/form-data"] && op.requestBody.content["multipart/form-data"].schema && op.requestBody.content["multipart/form-data"].schema.properties && result.content["multipart/form-data"] && result.content["multipart/form-data"].schema && result.content["multipart/form-data"].schema.properties) {
              op.requestBody.content["multipart/form-data"].schema.properties = Object.assign(op.requestBody.content["multipart/form-data"].schema.properties, result.content["multipart/form-data"].schema.properties);
              op.requestBody.content["multipart/form-data"].schema.required = (op.requestBody.content["multipart/form-data"].schema.required || []).concat(result.content["multipart/form-data"].schema.required || []);
              if (!op.requestBody.content["multipart/form-data"].schema.required.length) {
                delete op.requestBody.content["multipart/form-data"].schema.required;
              }
            } else if (op.requestBody.content && op.requestBody.content["application/x-www-form-urlencoded"] && op.requestBody.content["application/x-www-form-urlencoded"].schema && op.requestBody.content["application/x-www-form-urlencoded"].schema.properties && result.content["application/x-www-form-urlencoded"] && result.content["application/x-www-form-urlencoded"].schema && result.content["application/x-www-form-urlencoded"].schema.properties) {
              op.requestBody.content["application/x-www-form-urlencoded"].schema.properties = Object.assign(op.requestBody.content["application/x-www-form-urlencoded"].schema.properties, result.content["application/x-www-form-urlencoded"].schema.properties);
              op.requestBody.content["application/x-www-form-urlencoded"].schema.required = (op.requestBody.content["application/x-www-form-urlencoded"].schema.required || []).concat(result.content["application/x-www-form-urlencoded"].schema.required || []);
              if (!op.requestBody.content["application/x-www-form-urlencoded"].schema.required.length) {
                delete op.requestBody.content["application/x-www-form-urlencoded"].schema.required;
              }
            } else {
              op.requestBody = Object.assign(op.requestBody, result);
              if (!op.requestBody["x-s2o-name"]) {
                if (op.requestBody.schema && op.requestBody.schema.$ref) {
                  op.requestBody["x-s2o-name"] = decodeURIComponent(op.requestBody.schema.$ref.replace("#/components/schemas/", "")).split("/").join("");
                } else if (op.operationId) {
                  op.requestBody["x-s2o-name"] = common.sanitiseAll(op.operationId);
                }
              }
            }
          }
        }
      }
      if (param && !param["x-s2o-delete"]) {
        delete param.type;
        for (let prop of common.parameterTypeProperties) {
          delete param[prop];
        }
        if (param.in === "path" && (typeof param.required === "undefined" || param.required !== true)) {
          if (options3.patch) {
            options3.patches++;
            param.required = true;
          } else {
            throwError("(Patchable) path parameters must be required:true [" + param.name + " in " + index + "]", options3);
          }
        }
      }
      return op;
    }
    function copyExtensions(src, tgt) {
      for (let prop in src) {
        if (prop.startsWith("x-") && !prop.startsWith("x-s2o")) {
          tgt[prop] = src[prop];
        }
      }
    }
    function processResponse(response, name2, op, openapi, options3) {
      if (!response) return false;
      if (response.$ref && typeof response.$ref === "string") {
        if (response.$ref.indexOf("#/definitions/") >= 0) {
          throwOrWarn("definition used as response: " + response.$ref, response, options3);
        } else {
          if (response.$ref.startsWith("#/responses/")) {
            response.$ref = "#/components/responses/" + common.sanitise(decodeURIComponent(response.$ref.replace("#/responses/", "")));
          }
        }
      } else {
        if (typeof response.description === "undefined" || response.description === null || response.description === "" && options3.patch) {
          if (options3.patch) {
            if (typeof response === "object" && !Array.isArray(response)) {
              options3.patches++;
              response.description = statusCodes[response] || "";
            }
          } else {
            throwError("(Patchable) response.description is mandatory", options3);
          }
        }
        if (typeof response.schema !== "undefined") {
          fixUpSchema(response.schema, options3);
          if (response.schema.$ref && typeof response.schema.$ref === "string" && response.schema.$ref.startsWith("#/responses/")) {
            response.schema.$ref = "#/components/responses/" + common.sanitise(decodeURIComponent(response.schema.$ref.replace("#/responses/", "")));
          }
          if (op && op.produces && typeof op.produces === "string") {
            if (options3.patch) {
              options3.patches++;
              op.produces = [op.produces];
            } else {
              return throwError("(Patchable) operation.produces must be an array", options3);
            }
          }
          if (openapi.produces && !Array.isArray(openapi.produces)) delete openapi.produces;
          let produces = ((op ? op.produces : null) || (openapi.produces || [])).filter(common.uniqueOnly);
          if (!produces.length) produces.push("*/*");
          response.content = {};
          for (let mimetype of produces) {
            response.content[mimetype] = {};
            response.content[mimetype].schema = clone3(response.schema);
            if (response.examples && response.examples[mimetype]) {
              let example = {};
              example.value = response.examples[mimetype];
              response.content[mimetype].examples = {};
              response.content[mimetype].examples.response = example;
              delete response.examples[mimetype];
            }
            if (response.content[mimetype].schema.type === "file") {
              response.content[mimetype].schema = { type: "string", format: "binary" };
            }
          }
          delete response.schema;
        }
        for (let mimetype in response.examples) {
          if (!response.content) response.content = {};
          if (!response.content[mimetype]) response.content[mimetype] = {};
          response.content[mimetype].examples = {};
          response.content[mimetype].examples.response = {};
          response.content[mimetype].examples.response.value = response.examples[mimetype];
        }
        delete response.examples;
        if (response.headers) {
          for (let h in response.headers) {
            if (h.toLowerCase() === "status code") {
              if (options3.patch) {
                options3.patches++;
                delete response.headers[h];
              } else {
                throwError('(Patchable) "Status Code" is not a valid header', options3);
              }
            } else {
              processHeader(response.headers[h], options3);
            }
          }
        }
      }
    }
    function processPaths(container, containerName, options3, requestBodyCache, openapi) {
      for (let p2 in container) {
        let path2 = container[p2];
        if (path2 && path2["x-trace"] && typeof path2["x-trace"] === "object") {
          path2.trace = path2["x-trace"];
          delete path2["x-trace"];
        }
        if (path2 && path2["x-summary"] && typeof path2["x-summary"] === "string") {
          path2.summary = path2["x-summary"];
          delete path2["x-summary"];
        }
        if (path2 && path2["x-description"] && typeof path2["x-description"] === "string") {
          path2.description = path2["x-description"];
          delete path2["x-description"];
        }
        if (path2 && path2["x-servers"] && Array.isArray(path2["x-servers"])) {
          path2.servers = path2["x-servers"];
          delete path2["x-servers"];
        }
        for (let method in path2) {
          if (common.httpMethods.indexOf(method) >= 0 || method === "x-amazon-apigateway-any-method") {
            let op = path2[method];
            if (op && op.parameters && Array.isArray(op.parameters)) {
              if (path2.parameters) {
                for (let param of path2.parameters) {
                  if (typeof param.$ref === "string") {
                    fixParamRef(param, options3);
                    param = resolveInternal(openapi, param.$ref);
                  }
                  let match17 = op.parameters.find(function(e, i, a) {
                    return e.name === param.name && e.in === param.in;
                  });
                  if (!match17 && (param.in === "formData" || param.in === "body" || param.type === "file")) {
                    op = processParameter(param, op, path2, method, p2, openapi, options3);
                    if (options3.rbname && op[options3.rbname] === "") {
                      delete op[options3.rbname];
                    }
                  }
                }
              }
              for (let param of op.parameters) {
                op = processParameter(param, op, path2, method, method + ":" + p2, openapi, options3);
              }
              if (options3.rbname && op[options3.rbname] === "") {
                delete op[options3.rbname];
              }
              if (!options3.debug) {
                if (op.parameters) op.parameters = op.parameters.filter(keepParameters);
              }
            }
            if (op && op.security) processSecurity(op.security);
            if (typeof op === "object") {
              if (!op.responses) {
                let defaultResp = {};
                defaultResp.description = "Default response";
                op.responses = { default: defaultResp };
              }
              for (let r in op.responses) {
                let response = op.responses[r];
                processResponse(response, r, op, openapi, options3);
              }
            }
            if (op && op["x-servers"] && Array.isArray(op["x-servers"])) {
              op.servers = op["x-servers"];
              delete op["x-servers"];
            } else if (op && op.schemes && op.schemes.length) {
              for (let scheme of op.schemes) {
                if (!openapi.schemes || openapi.schemes.indexOf(scheme) < 0) {
                  if (!op.servers) {
                    op.servers = [];
                  }
                  if (Array.isArray(openapi.servers)) {
                    for (let server of openapi.servers) {
                      let newServer = clone3(server);
                      let serverUrl = url2.parse(newServer.url);
                      serverUrl.protocol = scheme;
                      newServer.url = serverUrl.format();
                      op.servers.push(newServer);
                    }
                  }
                }
              }
            }
            if (options3.debug) {
              op["x-s2o-consumes"] = op.consumes || [];
              op["x-s2o-produces"] = op.produces || [];
            }
            if (op) {
              delete op.consumes;
              delete op.produces;
              delete op.schemes;
              if (op["x-ms-examples"]) {
                for (let e in op["x-ms-examples"]) {
                  let example = op["x-ms-examples"][e];
                  let se = common.sanitiseAll(e);
                  if (example.parameters) {
                    for (let p3 in example.parameters) {
                      let value5 = example.parameters[p3];
                      for (let param of (op.parameters || []).concat(path2.parameters || [])) {
                        if (param.$ref) {
                          param = jptr.jptr(openapi, param.$ref);
                        }
                        if (param.name === p3 && !param.example) {
                          if (!param.examples) {
                            param.examples = {};
                          }
                          param.examples[e] = { value: value5 };
                        }
                      }
                    }
                  }
                  if (example.responses) {
                    for (let r in example.responses) {
                      if (example.responses[r].headers) {
                        for (let h in example.responses[r].headers) {
                          let value5 = example.responses[r].headers[h];
                          for (let rh in op.responses[r].headers) {
                            if (rh === h) {
                              let header = op.responses[r].headers[rh];
                              header.example = value5;
                            }
                          }
                        }
                      }
                      if (example.responses[r].body) {
                        openapi.components.examples[se] = { value: clone3(example.responses[r].body) };
                        if (op.responses[r] && op.responses[r].content) {
                          for (let ct in op.responses[r].content) {
                            let contentType = op.responses[r].content[ct];
                            if (!contentType.examples) {
                              contentType.examples = {};
                            }
                            contentType.examples[e] = { $ref: "#/components/examples/" + se };
                          }
                        }
                      }
                    }
                  }
                }
                delete op["x-ms-examples"];
              }
              if (op.parameters && op.parameters.length === 0) delete op.parameters;
              if (op.requestBody) {
                let effectiveOperationId = op.operationId ? common.sanitiseAll(op.operationId) : common.sanitiseAll(method + p2).toCamelCase();
                let rbName = common.sanitise(op.requestBody["x-s2o-name"] || effectiveOperationId || "");
                delete op.requestBody["x-s2o-name"];
                let rbStr = JSON.stringify(op.requestBody);
                let rbHash = common.hash(rbStr);
                if (!requestBodyCache[rbHash]) {
                  let entry = {};
                  entry.name = rbName;
                  entry.body = op.requestBody;
                  entry.refs = [];
                  requestBodyCache[rbHash] = entry;
                }
                let ptr = "#/" + containerName + "/" + encodeURIComponent(jptr.jpescape(p2)) + "/" + method + "/requestBody";
                requestBodyCache[rbHash].refs.push(ptr);
              }
            }
          }
        }
        if (path2 && path2.parameters) {
          for (let p22 in path2.parameters) {
            let param = path2.parameters[p22];
            processParameter(param, null, path2, null, p2, openapi, options3);
          }
          if (!options3.debug && Array.isArray(path2.parameters)) {
            path2.parameters = path2.parameters.filter(keepParameters);
          }
        }
      }
    }
    function main(openapi, options3) {
      let requestBodyCache = {};
      componentNames = { schemas: {} };
      if (openapi.security) processSecurity(openapi.security);
      for (let s in openapi.components.securitySchemes) {
        let sname = common.sanitise(s);
        if (s !== sname) {
          if (openapi.components.securitySchemes[sname]) {
            throwError("Duplicate sanitised securityScheme name " + sname, options3);
          }
          openapi.components.securitySchemes[sname] = openapi.components.securitySchemes[s];
          delete openapi.components.securitySchemes[s];
        }
        processSecurityScheme(openapi.components.securitySchemes[sname], options3);
      }
      for (let s in openapi.components.schemas) {
        let sname = common.sanitiseAll(s);
        let suffix = "";
        if (s !== sname) {
          while (openapi.components.schemas[sname + suffix]) {
            suffix = suffix ? ++suffix : 2;
          }
          openapi.components.schemas[sname + suffix] = openapi.components.schemas[s];
          delete openapi.components.schemas[s];
        }
        componentNames.schemas[s] = sname + suffix;
        fixUpSchema(openapi.components.schemas[sname + suffix], options3);
      }
      options3.refmap = {};
      recurse(openapi, { payload: { options: options3 } }, fixupRefs);
      dedupeRefs(openapi, options3);
      for (let p2 in openapi.components.parameters) {
        let sname = common.sanitise(p2);
        if (p2 !== sname) {
          if (openapi.components.parameters[sname]) {
            throwError("Duplicate sanitised parameter name " + sname, options3);
          }
          openapi.components.parameters[sname] = openapi.components.parameters[p2];
          delete openapi.components.parameters[p2];
        }
        let param = openapi.components.parameters[sname];
        processParameter(param, null, null, null, sname, openapi, options3);
      }
      for (let r in openapi.components.responses) {
        let sname = common.sanitise(r);
        if (r !== sname) {
          if (openapi.components.responses[sname]) {
            throwError("Duplicate sanitised response name " + sname, options3);
          }
          openapi.components.responses[sname] = openapi.components.responses[r];
          delete openapi.components.responses[r];
        }
        let response = openapi.components.responses[sname];
        processResponse(response, sname, null, openapi, options3);
        if (response.headers) {
          for (let h in response.headers) {
            if (h.toLowerCase() === "status code") {
              if (options3.patch) {
                options3.patches++;
                delete response.headers[h];
              } else {
                throwError('(Patchable) "Status Code" is not a valid header', options3);
              }
            } else {
              processHeader(response.headers[h], options3);
            }
          }
        }
      }
      for (let r in openapi.components.requestBodies) {
        let rb = openapi.components.requestBodies[r];
        let rbStr = JSON.stringify(rb);
        let rbHash = common.hash(rbStr);
        let entry = {};
        entry.name = r;
        entry.body = rb;
        entry.refs = [];
        requestBodyCache[rbHash] = entry;
      }
      processPaths(openapi.paths, "paths", options3, requestBodyCache, openapi);
      if (openapi["x-ms-paths"]) {
        processPaths(openapi["x-ms-paths"], "x-ms-paths", options3, requestBodyCache, openapi);
      }
      if (!options3.debug) {
        for (let p2 in openapi.components.parameters) {
          let param = openapi.components.parameters[p2];
          if (param["x-s2o-delete"]) {
            delete openapi.components.parameters[p2];
          }
        }
      }
      if (options3.debug) {
        openapi["x-s2o-consumes"] = openapi.consumes || [];
        openapi["x-s2o-produces"] = openapi.produces || [];
      }
      delete openapi.consumes;
      delete openapi.produces;
      delete openapi.schemes;
      let rbNamesGenerated = [];
      openapi.components.requestBodies = {};
      if (!options3.resolveInternal) {
        let counter6 = 1;
        for (let e in requestBodyCache) {
          let entry = requestBodyCache[e];
          if (entry.refs.length > 1) {
            let suffix = "";
            if (!entry.name) {
              entry.name = "requestBody";
              suffix = counter6++;
            }
            while (rbNamesGenerated.indexOf(entry.name + suffix) >= 0) {
              suffix = suffix ? ++suffix : 2;
            }
            entry.name = entry.name + suffix;
            rbNamesGenerated.push(entry.name);
            openapi.components.requestBodies[entry.name] = clone3(entry.body);
            for (let r in entry.refs) {
              let ref = {};
              ref.$ref = "#/components/requestBodies/" + entry.name;
              jptr.jptr(openapi, entry.refs[r], ref);
            }
          }
        }
      }
      if (openapi.components.responses && Object.keys(openapi.components.responses).length === 0) {
        delete openapi.components.responses;
      }
      if (openapi.components.parameters && Object.keys(openapi.components.parameters).length === 0) {
        delete openapi.components.parameters;
      }
      if (openapi.components.examples && Object.keys(openapi.components.examples).length === 0) {
        delete openapi.components.examples;
      }
      if (openapi.components.requestBodies && Object.keys(openapi.components.requestBodies).length === 0) {
        delete openapi.components.requestBodies;
      }
      if (openapi.components.securitySchemes && Object.keys(openapi.components.securitySchemes).length === 0) {
        delete openapi.components.securitySchemes;
      }
      if (openapi.components.headers && Object.keys(openapi.components.headers).length === 0) {
        delete openapi.components.headers;
      }
      if (openapi.components.schemas && Object.keys(openapi.components.schemas).length === 0) {
        delete openapi.components.schemas;
      }
      if (openapi.components && Object.keys(openapi.components).length === 0) {
        delete openapi.components;
      }
      return openapi;
    }
    function extractServerParameters(server) {
      if (!server || !server.url || typeof server.url !== "string") return server;
      server.url = server.url.split("{{").join("{");
      server.url = server.url.split("}}").join("}");
      server.url.replace(/\{(.+?)\}/g, function(match17, group1) {
        if (!server.variables) {
          server.variables = {};
        }
        server.variables[group1] = { default: "unknown" };
      });
      return server;
    }
    function fixInfo(openapi, options3, reject) {
      if (typeof openapi.info === "undefined" || openapi.info === null) {
        if (options3.patch) {
          options3.patches++;
          openapi.info = { version: "", title: "" };
        } else {
          return reject(new S2OError("(Patchable) info object is mandatory"));
        }
      }
      if (typeof openapi.info !== "object" || Array.isArray(openapi.info)) {
        return reject(new S2OError("info must be an object"));
      }
      if (typeof openapi.info.title === "undefined" || openapi.info.title === null) {
        if (options3.patch) {
          options3.patches++;
          openapi.info.title = "";
        } else {
          return reject(new S2OError("(Patchable) info.title cannot be null"));
        }
      }
      if (typeof openapi.info.version === "undefined" || openapi.info.version === null) {
        if (options3.patch) {
          options3.patches++;
          openapi.info.version = "";
        } else {
          return reject(new S2OError("(Patchable) info.version cannot be null"));
        }
      }
      if (typeof openapi.info.version !== "string") {
        if (options3.patch) {
          options3.patches++;
          openapi.info.version = openapi.info.version.toString();
        } else {
          return reject(new S2OError("(Patchable) info.version must be a string"));
        }
      }
      if (typeof openapi.info.logo !== "undefined") {
        if (options3.patch) {
          options3.patches++;
          openapi.info["x-logo"] = openapi.info.logo;
          delete openapi.info.logo;
        } else return reject(new S2OError("(Patchable) info should not have logo property"));
      }
      if (typeof openapi.info.termsOfService !== "undefined") {
        if (openapi.info.termsOfService === null) {
          if (options3.patch) {
            options3.patches++;
            openapi.info.termsOfService = "";
          } else {
            return reject(new S2OError("(Patchable) info.termsOfService cannot be null"));
          }
        }
        try {
          new URL(openapi.info.termsOfService);
        } catch (ex) {
          if (options3.patch) {
            options3.patches++;
            delete openapi.info.termsOfService;
          } else return reject(new S2OError("(Patchable) info.termsOfService must be a URL"));
        }
      }
    }
    function fixPaths(openapi, options3, reject) {
      if (typeof openapi.paths === "undefined") {
        if (options3.patch) {
          options3.patches++;
          openapi.paths = {};
        } else {
          return reject(new S2OError("(Patchable) paths object is mandatory"));
        }
      }
    }
    function detectObjectReferences(obj, options3) {
      const seen = /* @__PURE__ */ new WeakSet();
      recurse(obj, { identityDetection: true }, function(obj2, key, state) {
        if (typeof obj2[key] === "object" && obj2[key] !== null) {
          if (seen.has(obj2[key])) {
            if (options3.anchors) {
              obj2[key] = clone3(obj2[key]);
            } else {
              throwError("YAML anchor or merge key at " + state.path, options3);
            }
          } else {
            seen.add(obj2[key]);
          }
        }
      });
    }
    function convertObj2(swagger, options3, callback) {
      return maybe(callback, new Promise(function(resolve3, reject) {
        if (!swagger) swagger = {};
        options3.original = swagger;
        if (!options3.text) options3.text = yaml.stringify(swagger);
        options3.externals = [];
        options3.externalRefs = {};
        options3.rewriteRefs = true;
        options3.preserveMiro = true;
        options3.promise = {};
        options3.promise.resolve = resolve3;
        options3.promise.reject = reject;
        options3.patches = 0;
        if (!options3.cache) options3.cache = {};
        if (options3.source) options3.cache[options3.source] = options3.original;
        detectObjectReferences(swagger, options3);
        if (swagger.openapi && typeof swagger.openapi === "string" && swagger.openapi.startsWith("3.")) {
          options3.openapi = cclone(swagger);
          fixInfo(options3.openapi, options3, reject);
          fixPaths(options3.openapi, options3, reject);
          resolver.optionalResolve(options3).then(function() {
            if (options3.direct) {
              return resolve3(options3.openapi);
            } else {
              return resolve3(options3);
            }
          }).catch(function(ex) {
            console.warn(ex);
            reject(ex);
          });
          return;
        }
        if (!swagger.swagger || swagger.swagger != "2.0") {
          return reject(new S2OError("Unsupported swagger/OpenAPI version: " + (swagger.openapi ? swagger.openapi : swagger.swagger)));
        }
        let openapi = options3.openapi = {};
        openapi.openapi = typeof options3.targetVersion === "string" && options3.targetVersion.startsWith("3.") ? options3.targetVersion : targetVersion;
        if (options3.origin) {
          if (!openapi["x-origin"]) {
            openapi["x-origin"] = [];
          }
          let origin = {};
          origin.url = options3.source || options3.origin;
          origin.format = "swagger";
          origin.version = swagger.swagger;
          origin.converter = {};
          origin.converter.url = "https://github.com/mermade/oas-kit";
          origin.converter.version = ourVersion;
          openapi["x-origin"].push(origin);
        }
        openapi = Object.assign(openapi, cclone(swagger));
        delete openapi.swagger;
        recurse(openapi, {}, function(obj, key, state) {
          if (obj[key] === null && !key.startsWith("x-") && key !== "default" && state.path.indexOf("/example") < 0) delete obj[key];
        });
        if (swagger.host) {
          for (let s of Array.isArray(swagger.schemes) ? swagger.schemes : [""]) {
            let server = {};
            let basePath = (swagger.basePath || "").replace(/\/$/, "");
            server.url = (s ? s + ":" : "") + "//" + swagger.host + basePath;
            extractServerParameters(server);
            if (!openapi.servers) openapi.servers = [];
            openapi.servers.push(server);
          }
        } else if (swagger.basePath) {
          let server = {};
          server.url = swagger.basePath;
          extractServerParameters(server);
          if (!openapi.servers) openapi.servers = [];
          openapi.servers.push(server);
        }
        delete openapi.host;
        delete openapi.basePath;
        if (openapi["x-servers"] && Array.isArray(openapi["x-servers"])) {
          openapi.servers = openapi["x-servers"];
          delete openapi["x-servers"];
        }
        if (swagger["x-ms-parameterized-host"]) {
          let xMsPHost = swagger["x-ms-parameterized-host"];
          let server = {};
          server.url = xMsPHost.hostTemplate + (swagger.basePath ? swagger.basePath : "");
          server.variables = {};
          const paramNames = server.url.match(/\{\w+\}/g);
          for (let msp in xMsPHost.parameters) {
            let param = xMsPHost.parameters[msp];
            if (param.$ref) {
              param = clone3(resolveInternal(openapi, param.$ref));
            }
            if (!msp.startsWith("x-")) {
              delete param.required;
              delete param.type;
              delete param.in;
              if (typeof param.default === "undefined") {
                if (param.enum) {
                  param.default = param.enum[0];
                } else {
                  param.default = "none";
                }
              }
              if (!param.name) {
                param.name = paramNames[msp].replace("{", "").replace("}", "");
              }
              server.variables[param.name] = param;
              delete param.name;
            }
          }
          if (!openapi.servers) openapi.servers = [];
          if (xMsPHost.useSchemePrefix === false) {
            openapi.servers.push(server);
          } else {
            swagger.schemes.forEach((scheme) => {
              openapi.servers.push(
                Object.assign({}, server, { url: scheme + "://" + server.url })
              );
            });
          }
          delete openapi["x-ms-parameterized-host"];
        }
        fixInfo(openapi, options3, reject);
        fixPaths(openapi, options3, reject);
        if (typeof openapi.consumes === "string") {
          openapi.consumes = [openapi.consumes];
        }
        if (typeof openapi.produces === "string") {
          openapi.produces = [openapi.produces];
        }
        openapi.components = {};
        if (openapi["x-callbacks"]) {
          openapi.components.callbacks = openapi["x-callbacks"];
          delete openapi["x-callbacks"];
        }
        openapi.components.examples = {};
        openapi.components.headers = {};
        if (openapi["x-links"]) {
          openapi.components.links = openapi["x-links"];
          delete openapi["x-links"];
        }
        openapi.components.parameters = openapi.parameters || {};
        openapi.components.responses = openapi.responses || {};
        openapi.components.requestBodies = {};
        openapi.components.securitySchemes = openapi.securityDefinitions || {};
        openapi.components.schemas = openapi.definitions || {};
        delete openapi.definitions;
        delete openapi.responses;
        delete openapi.parameters;
        delete openapi.securityDefinitions;
        resolver.optionalResolve(options3).then(function() {
          main(options3.openapi, options3);
          if (options3.direct) {
            resolve3(options3.openapi);
          } else {
            resolve3(options3);
          }
        }).catch(function(ex) {
          console.warn(ex);
          reject(ex);
        });
      }));
    }
    function convertStr(str, options3, callback) {
      return maybe(callback, new Promise(function(resolve3, reject) {
        let obj = null;
        let error4 = null;
        try {
          obj = JSON.parse(str);
          options3.text = JSON.stringify(obj, null, 2);
        } catch (ex) {
          error4 = ex;
          try {
            obj = yaml.parse(str, { schema: "core", prettyErrors: true });
            options3.sourceYaml = true;
            options3.text = str;
          } catch (ex2) {
            error4 = ex2;
          }
        }
        if (obj) {
          convertObj2(obj, options3).then((options4) => resolve3(options4)).catch((ex) => reject(ex));
        } else {
          reject(new S2OError(error4 ? error4.message : "Could not parse string"));
        }
      }));
    }
    function convertUrl(url3, options3, callback) {
      return maybe(callback, new Promise(function(resolve3, reject) {
        options3.origin = true;
        if (!options3.source) {
          options3.source = url3;
        }
        if (options3.verbose) {
          console.warn("GET " + url3);
        }
        if (!options3.fetch) {
          options3.fetch = fetch2;
        }
        const fetchOptions = Object.assign({}, options3.fetchOptions, { agent: options3.agent });
        options3.fetch(url3, fetchOptions).then(function(res) {
          if (res.status !== 200) throw new S2OError(`Received status code ${res.status}: ${url3}`);
          return res.text();
        }).then(function(body) {
          convertStr(body, options3).then((options4) => resolve3(options4)).catch((ex) => reject(ex));
        }).catch(function(err) {
          reject(err);
        });
      }));
    }
    function convertFile(filename, options3, callback) {
      return maybe(callback, new Promise(function(resolve3, reject) {
        fs.readFile(filename, options3.encoding || "utf8", function(err, s) {
          if (err) {
            reject(err);
          } else {
            options3.sourceFile = filename;
            convertStr(s, options3).then((options4) => resolve3(options4)).catch((ex) => reject(ex));
          }
        });
      }));
    }
    function convertStream(readable, options3, callback) {
      return maybe(callback, new Promise(function(resolve3, reject) {
        let data = "";
        readable.on("data", function(chunk4) {
          data += chunk4;
        }).on("end", function() {
          convertStr(data, options3).then((options4) => resolve3(options4)).catch((ex) => reject(ex));
        });
      }));
    }
    module.exports = {
      S2OError,
      targetVersion,
      convert: convertObj2,
      convertObj: convertObj2,
      convertUrl,
      convertStr,
      convertFile,
      convertStream
    };
  }
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value5) => () => value5;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date5) => date5.getTime());
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.15.2";
var getCurrentVersion = () => moduleVersion;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
var globalStore;
var globalValue = (id2, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id2)) {
    globalStore.set(id2, compute());
  }
  return globalStore.get(id2);
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
var isTagged = /* @__PURE__ */ dual(2, (self, tag4) => hasProperty(self, "_tag") && self["_tag"] === tag4);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max6) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max6;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out2, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out2[0] = hi;
  out2[1] = lo;
}
function add64(out2, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out2[0] = hi;
  out2[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value5) {
    this.#value = value5;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys5) => {
  let h = 12289;
  for (let i = 0; i < keys5.length; i++) {
    h ^= pipe(string(keys5[i]), combine(hash(o[keys5[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value5) => typeof value5 === "object" && value5 !== null ? cache.includes(value5) ? void 0 : cache.push(value5) && (redactableState.fiberRefs !== void 0 && isRedactable(value5) ? value5[symbolRedactable](redactableState.fiberRefs) : value5) : value5, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context7, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context7;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base3() {
  }
  Base3.prototype = CommitPrototype;
  return Base3;
}();

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value5) => {
  const a = Object.create(SomeProto);
  a.value = value5;
  return a;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};
var fromOption = /* @__PURE__ */ dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var mapBoth = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var match = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Order.js
var make2 = (compare2) => (self, that) => self === that ? 0 : compare2(self, that);
var string2 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var number3 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var boolean = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var getOrElse = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrNull = /* @__PURE__ */ getOrElse(constNull);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
var flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some(b) : none));
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  if (result.done) throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var findFirst = /* @__PURE__ */ dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty = () => constEmpty;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max6 = Math.max(1, Math.floor(n));
  const out2 = new Array(max6);
  for (let i = 0; i < max6; i++) {
    out2[i] = f(i);
  }
  return out2;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var match3 = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self, head5) => [head5, ...self]);
var prependAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));
var append = /* @__PURE__ */ dual(2, (self, last5) => [...self, last5]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as9) => i < 0 || i >= as9.length;
var clamp = (i, as9) => Math.floor(Math.min(Math.max(0, i), as9.length));
var get = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tailNonEmpty = (self) => self.slice(1);
var initNonEmpty = (self) => self.slice(0, -1);
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp(n, input), input.length);
});
var findFirstIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some2(i);
    }
    i++;
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self, f) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var reverse = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out2 = Array.from(self);
  out2.sort(O);
  return out2;
});
var zip = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self, that, f) => {
  const as9 = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as9) && isNonEmptyReadonlyArray(bs)) {
    const out2 = [f(headNonEmpty(as9), headNonEmpty(bs))];
    const len = Math.min(as9.length, bs.length);
    for (let i = 1; i < len; i++) {
      out2[i] = f(as9[i], bs[i]);
    }
    return out2;
  }
  return [];
});
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var splitAt = /* @__PURE__ */ dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var copy = (self) => self.slice();
var unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe2 = dedupeWith(isEquivalent);
      return dedupe2(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
var empty2 = () => [];
var of = (a) => [a];
var map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out2 = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out2.push(inner[j]);
    }
  }
  return out2;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  const as9 = fromIterable(self);
  const out2 = [];
  for (let i = 0; i < as9.length; i++) {
    const o = f(as9[i], i);
    if (isSome2(o)) {
      out2.push(o.value);
    }
  }
  return out2;
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var filter2 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as9 = fromIterable(self);
  const out2 = [];
  for (let i = 0; i < as9.length; i++) {
    if (predicate(as9[i], i)) {
      out2.push(as9[i]);
    }
  }
  return out2;
});
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
var some3 = /* @__PURE__ */ dual(2, (self, predicate) => self.some(predicate));
var unfold = (b, f) => {
  const out2 = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out2.push(a);
    next = b2;
  }
  return out2;
};
var getEquivalence = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out2 = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out2.every((a) => !isEquivalent(r, a))) {
        out2.push(r);
      }
    }
    return out2;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Chunk.js
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence2 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value5, i) => isEquivalent(value5, unsafeGet2(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
var ChunkProto = {
  [TypeId3]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk4 = Object.create(ChunkProto);
  chunk4.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk4.length = 0;
      chunk4.depth = 0;
      chunk4.left = chunk4;
      chunk4.right = chunk4;
      break;
    }
    case "IConcat": {
      chunk4.length = backing.left.length + backing.right.length;
      chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk4.left = backing.left;
      chunk4.right = backing.right;
      break;
    }
    case "IArray": {
      chunk4.length = backing.array.length;
      chunk4.depth = 0;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
    case "ISingleton": {
      chunk4.length = 1;
      chunk4.depth = 0;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
    case "ISlice": {
      chunk4.length = backing.length;
      chunk4.depth = backing.chunk.depth + 1;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
  }
  return chunk4;
};
var isChunk = (u) => hasProperty(u, TypeId3);
var _empty = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty3 = () => _empty;
var make5 = (...as9) => unsafeFromNonEmptyArray(as9);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
var copyToArray = (self, array7, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array7, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array7, initial);
      copyToArray(self.right, array7, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array7[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array7[j] = unsafeGet2(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self) => toReadonlyArray(self).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty;
      self.right = _empty;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
};
var reverse2 = reverseChunk;
var get2 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet2(self, index)));
var unsafeFromArray = (self) => self.length === 0 ? empty3() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet2 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet2(self.left, index) : unsafeGet2(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet2(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
var take = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return _empty;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take(self.right, n - self.left.length)
          });
        }
        return take(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop2(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff8 = that.depth - self.depth;
  if (Math.abs(diff8) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff8 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filter3 = /* @__PURE__ */ dual(2, (self, predicate) => unsafeFromArray(filter2(self, predicate)));
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var head2 = /* @__PURE__ */ get2(0);
var unsafeHead2 = (self) => unsafeGet2(self, 0);
var headNonEmpty2 = unsafeHead2;
var map4 = /* @__PURE__ */ dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map3((a, i) => f(a, i)))));
var tailNonEmpty2 = (self) => drop2(self, 1);
var takeRight = /* @__PURE__ */ dual(2, (self, n) => drop2(self, self.length - n));
var reduce2 = reduce;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error4 = Object.create(proto);
  error4._op = OP_AND;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var Or = (self, that) => {
  const error4 = Object.create(proto);
  error4._op = OP_OR;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var InvalidData = (path2, message, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto);
  error4._op = OP_INVALID_DATA;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Invalid data at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var MissingData = (path2, message, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto);
  error4._op = OP_MISSING_DATA;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Missing data at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var SourceUnavailable = (path2, message, cause2, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto);
  error4._op = OP_SOURCE_UNAVAILABLE;
  error4.path = path2;
  error4.message = message;
  error4.cause = cause2;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Source unavailable at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var Unsupported = (path2, message, options3 = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto);
  error4._op = OP_UNSUPPORTED;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options3.pathDelim));
      return `(Unsupported operation at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context7, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error4 = input.pop();
    switch (error4._op) {
      case OP_AND: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context7, error4.path, error4.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context7, error4.path, error4.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context7, error4.path, error4.message, error4.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context7, error4.path, error4.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._op) {
      case "Left": {
        switch (either7.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.andCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.orCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext(self, void 0, IsMissingDataOnlyReducer);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/ConfigError.js
var isConfigError2 = isConfigError;
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Duration.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match17 = DURATION_REGEX.exec(input);
    if (match17) {
      const [_, valueStr, unit] = match17;
      const value5 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value5);
        case "second":
        case "seconds":
          return seconds(value5);
        case "minute":
        case "minutes":
          return minutes(value5);
        case "hour":
        case "hours":
          return hours(value5);
        case "day":
        case "days":
          return days(value5);
        case "week":
        case "weeks":
          return weeks(value5);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId4]: TypeId4,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make6 = (input) => {
  const duration3 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration3.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration3.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration3.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration3.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration3.value = zeroValue;
  } else {
    duration3.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration3;
};
var isDuration = (u) => hasProperty(u, TypeId4);
var isZero = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make6(0);
var infinity = /* @__PURE__ */ make6(Infinity);
var nanos = (nanos2) => make6(nanos2);
var micros = (micros2) => make6(micros2 * bigint1e3);
var millis = (millis2) => make6(millis2);
var seconds = (seconds2) => make6(seconds2 * 1e3);
var minutes = (minutes2) => make6(minutes2 * 6e4);
var hours = (hours2) => make6(hours2 * 36e5);
var days = (days2) => make6(days2 * 864e5);
var weeks = (weeks2) => make6(weeks2 * 6048e5);
var toMillis = (self) => match4(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match4 = /* @__PURE__ */ dual(2, (self, options3) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options3.onNanos(_self.value.nanos);
    case "Infinity":
      return options3.onMillis(Infinity);
    case "Millis":
      return options3.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self, that, options3) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options3.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options3.onNanos(selfNanos, thatNanos);
  }
  return options3.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var sum = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make6(self2 + that2),
  onNanos: (self2, that2) => make6(self2 + that2)
}));
var lessThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode(self), decode(that)));
var parts = (self) => {
  const duration3 = decode(self);
  if (duration3.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration3);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min4 = sec / bigint60;
  const hr = min4 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min4 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self) => {
  const duration3 = decode(self);
  if (duration3.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration3)) {
    return "0";
  }
  const fragments = parts(duration3);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/stack.js
var make7 = (value5, previous) => ({
  value: value5,
  previous
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate3, at, v, arr) {
  let out2 = arr;
  if (!mutate3) {
    const len = arr.length;
    out2 = new Array(len);
    for (let i = 0; i < len; ++i) out2[i] = arr[i];
  }
  out2[at] = v;
  return out2;
}
function arraySpliceOut(mutate3, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out2 = arr;
  if (mutate3) {
    i = g = at;
  } else {
    out2 = new Array(newLen);
    while (i < at) out2[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out2[g++] = arr[i++];
  if (mutate3) {
    out2.length = newLen;
  }
  return out2;
}
function arraySpliceIn(mutate3, at, v, arr) {
  const len = arr.length;
  if (mutate3) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out2 = new Array(len + 1);
  while (i < at) out2[g++] = arr[i++];
  out2[at] = v;
  while (i < len) out2[++g] = arr[i++];
  return out2;
}

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size13) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size13.value;
    return new LeafNode(edit, hash2, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value5) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value5;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size13.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size13.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash2, new _LeafNode(edit, hash2, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children2) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children2;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list4 = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size13);
      if (list4 === this.children) return this;
      return list4.length > 1 ? new _CollisionNode(edit, this.hash, list4) : list4[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size13.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate3, edit, hash2, list4, f, key, size13) {
    const len = list4.length;
    for (let i = 0; i < len; ++i) {
      const child = list4[i];
      if ("key" in child && equals(key, child.key)) {
        const value5 = child.value;
        const newValue2 = f(value5);
        if (newValue2 === value5) return list4;
        if (isNone2(newValue2)) {
          --size13.value;
          return arraySpliceOut(mutate3, i, list4);
        }
        return arrayUpdate(mutate3, i, new LeafNode(edit, hash2, key, newValue2), list4);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list4;
    ++size13.value;
    return arrayUpdate(mutate3, len, new LeafNode(edit, hash2, key, newValue), list4);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children2) {
    this.edit = edit;
    this.mask = mask;
    this.children = children2;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    const mask = this.mask;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists3 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists3) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash2, key, size13);
      if (!_newChild) return this;
      return children2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children2) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children2));
    }
    const current = children2[indx];
    const child = current.modify(edit, shift2 + SIZE, f, hash2, key, size13);
    if (current === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children2.length <= 2 && isLeafNode(children2[indx ^ 1])) {
        return children2[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children2);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children2);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size13, children2) {
    this.edit = edit;
    this.size = size13;
    this.children = children2;
  }
  modify(edit, shift2, f, hash2, key, size13) {
    let count4 = this.size;
    const children2 = this.children;
    const frag = hashFragment(shift2, hash2);
    const child = children2[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash2, key, size13);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count4;
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count4;
      if (count4 <= MIN_ARRAY_NODE) {
        return pack(edit, count4, frag, children2);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children2);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children2);
    }
    if (canEdit) {
      this.size = count4;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count4, newChildren);
  }
};
function pack(edit, count4, removed, elements) {
  const children2 = new Array(count4 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children2[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children2);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count4 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count4++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count4 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h12, n1, h22, n2) {
  if (h12 === h22) return new CollisionNode(edit, h12, [n2, n1]);
  const subH1 = hashFragment(shift2, h12);
  const subH2 = hashFragment(shift2, h22);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children2);
  }
}
function mergeLeaves(edit, shift2, h12, n1, h22, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h12, n1, h22, n2);
    if (typeof res === "function") {
      stack = make7(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root2, size13) => {
  const map33 = Object.create(HashMapProto);
  map33._editable = editable;
  map33._edit = edit;
  map33._root = root2;
  map33._size = size13;
  return map33;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map33, f) {
    this.map = map33;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children2 = node.children;
      return visitLazyChildren(children2.length, children2, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children2, i, f, cont) => {
  while (i < len) {
    const child = children2[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children2, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty2 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty4 = () => _empty2;
var make8 = (...entries2) => fromIterable3(entries2);
var fromIterable3 = (entries2) => {
  const map33 = beginMutation(empty4());
  for (const entry of entries2) {
    set(map33, entry[0], entry[1]);
  }
  return endMutation(map33);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self) => self && isEmptyNode(self._root);
var get3 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children2 = node.children;
          for (let i = 0, len = children2.length; i < len; ++i) {
            const child = children2[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash2)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self, key, value5) => modifyAt(self, key, () => some2(value5)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys = (self) => new HashMapIterator(self, (key) => key);
var size = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  self._editable = false;
  return self;
};
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
  const size13 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size13);
  return pipe(self, setTree(newRoot, size13.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
var map5 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, empty4(), (map33, value5, key) => set(map33, key, f(value5, key))));
var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, void 0, (_, value5, key) => f(value5, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  const root2 = self._root;
  if (root2._tag === "LeafNode") {
    return isSome2(root2.value) ? f(zero2, root2.value.value, root2.key) : zero2;
  }
  if (root2._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root2.children];
  let children2;
  while (children2 = toVisit.pop()) {
    for (let i = 0, len = children2.length; i < len; ) {
      const child = children2[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set7 = Object.create(HashSetProto);
  set7._keyMap = keyMap;
  return set7;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty3 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty4());
var empty5 = () => _empty3;
var fromIterable4 = (elements) => {
  const set7 = beginMutation2(empty5());
  for (const value5 of elements) {
    add(set7, value5);
  }
  return endMutation2(set7);
};
var make9 = (...elements) => {
  const set7 = beginMutation2(empty5());
  for (const value5 of elements) {
    add(set7, value5);
  }
  return endMutation2(set7);
};
var has2 = /* @__PURE__ */ dual(2, (self, value5) => has(self._keyMap, value5));
var size2 = (self) => size(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  self._keyMap._editable = false;
  return self;
};
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add = /* @__PURE__ */ dual(2, (self, value5) => self._keyMap._editable ? (set(value5, true)(self._keyMap), self) : makeImpl2(set(value5, true)(self._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self, value5) => self._keyMap._editable ? (remove2(value5)(self._keyMap), self) : makeImpl2(remove2(value5)(self._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self, that) => mutate(self, (set7) => {
  for (const value5 of that) {
    remove3(set7, value5);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate(empty5(), (set7) => {
  forEach2(self, (value5) => add(set7, value5));
  for (const value5 of that) {
    add(set7, value5);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self, zero2, f) => reduce3(self._keyMap, zero2, (z, _, a) => f(z, a)));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/HashSet.js
var empty6 = empty5;
var fromIterable5 = fromIterable4;
var make10 = make9;
var has3 = has2;
var size3 = size2;
var add2 = add;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var reduce5 = reduce4;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make11(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag4 = Object.create(TagProto);
  Object.defineProperty(tag4, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag4.key = key;
  return tag4;
};
var Tag = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id2, options3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id2;
  ReferenceClass.defaultValue = options3.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId5]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context7 = Object.create(ContextProto);
  context7.unsafeMap = unsafeMap;
  return context7;
};
var serviceNotFoundError = (tag4) => {
  const error4 = new Error(`Service not found${tag4.key ? `: ${String(tag4.key)}` : ""}`);
  if (tag4.stack) {
    const lines3 = tag4.stack.split("\n");
    if (lines3.length > 2) {
      const afterAt = lines3[2].match(/at (.*)/);
      if (afterAt) {
        error4.message = error4.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error4.stack) {
    const lines3 = error4.stack.split("\n");
    lines3.splice(1, 3);
    error4.stack = lines3.join("\n");
  }
  return error4;
};
var isContext = (u) => hasProperty(u, TypeId5);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty4 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty7 = () => _empty4;
var make11 = (tag4, service2) => makeContext(/* @__PURE__ */ new Map([[tag4.key, service2]]));
var add3 = /* @__PURE__ */ dual(3, (self, tag4, service2) => {
  const map33 = new Map(self.unsafeMap);
  map33.set(tag4.key, service2);
  return makeContext(map33);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag4) => {
  if (defaultValueCache.has(tag4.key)) {
    return defaultValueCache.get(tag4.key);
  }
  const value5 = tag4.defaultValue();
  defaultValueCache.set(tag4.key, value5);
  return value5;
};
var unsafeGetReference = (self, tag4) => {
  return self.unsafeMap.has(tag4.key) ? self.unsafeMap.get(tag4.key) : getDefaultValue(tag4);
};
var unsafeGet3 = /* @__PURE__ */ dual(2, (self, tag4) => {
  if (!self.unsafeMap.has(tag4.key)) {
    if (ReferenceTypeId in tag4) return getDefaultValue(tag4);
    throw serviceNotFoundError(tag4);
  }
  return self.unsafeMap.get(tag4.key);
});
var get4 = unsafeGet3;
var getOption = /* @__PURE__ */ dual(2, (self, tag4) => {
  if (!self.unsafeMap.has(tag4.key)) {
    return isReference(tag4) ? some(getDefaultValue(tag4)) : none;
  }
  return some(self.unsafeMap.get(tag4.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self, that) => {
  const map33 = new Map(self.unsafeMap);
  for (const [tag4, s] of that.unsafeMap) {
    map33.set(tag4, s);
  }
  return makeContext(map33);
});
var omit = (...tags2) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag4 of tags2) {
    newEnv.delete(tag4.key);
  }
  return makeContext(newEnv);
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var isContext2 = isContext;
var isTag2 = isTag;
var empty8 = empty7;
var make12 = make11;
var add4 = add3;
var get5 = get4;
var unsafeGet4 = unsafeGet3;
var getOption2 = getOption;
var merge3 = merge2;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/MutableRef.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = (value5) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value5;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self) => self.current;
var set2 = /* @__PURE__ */ dual(2, (self, value5) => {
  self.current = value5;
  return self;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id2, startTimeMillis) {
    this.id = id2;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = /* @__PURE__ */ new None();
var runtime = (id2, startTimeMillis) => {
  return new Runtime(id2, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
};
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty6();
    }
    case OP_RUNTIME: {
      return make10(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union3(ids(self.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = (id2, startTimeSeconds) => {
  return new Runtime(id2, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var unsafeMake = () => {
  const id2 = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id2 + 1));
  return new Runtime(id2, Date.now());
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var combine3 = combine2;
var combineAll2 = combineAll;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var unsafeMake2 = unsafeMake;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/HashMap.js
var empty9 = empty4;
var make16 = make8;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get7 = get3;
var has4 = has;
var set3 = set;
var keys2 = keys;
var size4 = size;
var modifyAt2 = modifyAt;
var map7 = map5;
var forEach3 = forEach;
var reduce6 = reduce3;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = (self) => fromIterable(self);
var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray3);
var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done8 = false;
    let self = this;
    return {
      next() {
        if (done8) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done8 = true;
          return this.return();
        }
        const value5 = self.head;
        self = self.tail;
        return {
          done: done8,
          value: value5
        };
      },
      return(value5) {
        if (!done8) {
          done8 = true;
        }
        return {
          done: true,
          value: value5
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head5, tail) => {
  const cons3 = Object.create(ConsProto);
  cons3.head = head5;
  cons3.tail = tail;
  return cons3;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId7);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var nil = () => _Nil;
var cons = (head5, tail) => makeCons(head5, tail);
var empty10 = nil;
var of3 = (value5) => makeCons(value5, _Nil);
var appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll2(that, self));
var prepend3 = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
var prependAll2 = /* @__PURE__ */ dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce7 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
  let acc = zero2;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self) => {
  let result = empty10();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};
var Structural = /* @__PURE__ */ function() {
  function Structural2(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as9) => Object.assign(Object.create(StructuralPrototype), as9);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty11 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first3, second) => {
  const o = Object.create(AndThenProto);
  o.first = first3;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = (key, service2) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service2;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update5) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update5;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch9 = empty11();
  for (const [tag4, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag4)) {
      const old = missingServices.get(tag4);
      missingServices.delete(tag4);
      if (!equals(old, newService)) {
        patch9 = combine4(makeUpdateService(tag4, () => newService))(patch9);
      }
    } else {
      missingServices.delete(tag4);
      patch9 = combine4(makeAddService(tag4, newService))(patch9);
    }
  }
  for (const [tag4] of missingServices.entries()) {
    patch9 = combine4(makeRemoveService(tag4))(patch9);
  }
  return patch9;
};
var combine4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
var patch = /* @__PURE__ */ dual(2, (self, context7) => {
  if (self._tag === "Empty") {
    return context7;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context7.unsafeMap);
  while (isNonEmpty(patches)) {
    const head5 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head5._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head5.key, head5.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head5.second), head5.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head5.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head5.key, head5.update(updatedContext.get(head5.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map33 = /* @__PURE__ */ new Map();
  for (const [tag4] of context7.unsafeMap) {
    if (updatedContext.has(tag4)) {
      map33.set(tag4, updatedContext.get(tag4));
      updatedContext.delete(tag4);
    }
  }
  for (const [tag4, s] of updatedContext) {
    map33.set(tag4, s);
  }
  return makeContext(map33);
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance2,
    _Key: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty12 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first3, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first3;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = (value5) => {
  const o = Object.create(AddProto);
  o.value = value5;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = (value5) => {
  const o = Object.create(RemoveProto);
  o.value = value5;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch9] = reduce5([oldValue, empty12()], ([set7, patch10], value5) => {
    if (has3(value5)(set7)) {
      return [remove4(value5)(set7), patch10];
    }
    return [set7, combine5(makeAdd(value5))(patch10)];
  })(newValue);
  return reduce5(patch9, (patch10, value5) => combine5(makeRemove(value5))(patch10))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set7 = oldValue;
  let patches = of2(self);
  while (isNonEmpty(patches)) {
    const head5 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head5._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head5.first)(prepend2(head5.second)(tail));
        break;
      }
      case "Add": {
        set7 = add2(head5.value)(set7);
        patches = tail;
        break;
      }
      case "Remove": {
        set7 = remove4(head5.value)(set7);
        patches = tail;
      }
    }
  }
  return set7;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty13 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first3, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first3;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o = Object.create(AppendProto);
  o.values = values3;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = (index, patch9) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch9;
  return o;
};
var diff3 = (options3) => {
  let i = 0;
  let patch9 = empty13();
  while (i < options3.oldValue.length && i < options3.newValue.length) {
    const oldElement = options3.oldValue[i];
    const newElement = options3.newValue[i];
    const valuePatch = options3.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options3.differ.empty)) {
      patch9 = combine6(patch9, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options3.oldValue.length) {
    patch9 = combine6(patch9, makeSlice(0, i));
  }
  if (i < options3.newValue.length) {
    patch9 = combine6(patch9, makeAppend(drop(i)(options3.newValue)));
  }
  return patch9;
};
var combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ3) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray2(patches)) {
    const head5 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head5._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head5.first, head5.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value5 of head5.values) {
          readonlyArray2.push(value5);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head5.from, head5.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray2[head5.index] = differ3.patch(head5.patch, readonlyArray2[head5.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray2;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make17 = (params) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params.empty;
  differ3.diff = params.diff;
  differ3.combine = params.combine;
  differ3.patch = params.patch;
  return differ3;
};
var environment = () => make17({
  empty: empty11(),
  combine: (first3, second) => combine4(second)(first3),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch9, oldValue) => patch(oldValue)(patch9)
});
var hashSet = () => make17({
  empty: empty12(),
  combine: (first3, second) => combine5(second)(first3),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch9, oldValue) => patch2(oldValue)(patch9)
});
var readonlyArray = (differ3) => make17({
  empty: empty13(),
  combine: (first3, second) => combine6(first3, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ3
  }),
  patch: (patch9, oldValue) => patch3(patch9, oldValue, differ3)
});
var update = () => updateWith((_, a) => a);
var updateWith = (f) => make17({
  empty: identity,
  combine: (first3, second) => {
    if (first3 === identity) {
      return second;
    }
    if (second === identity) {
      return first3;
    }
    return (a) => second(first3(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch9, oldValue) => f(oldValue, patch9(oldValue))
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch9) => patch9 & BIT_MASK;
var enabled = (patch9) => patch9 >> BIT_SHIFT & BIT_MASK;
var make18 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty14 = /* @__PURE__ */ make18(0, 0);
var enable = (flag) => make18(flag, flag);
var disable = (flag) => make18(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self, flag) => make18(active(self) & ~flag, enabled(self)));
var andThen = /* @__PURE__ */ dual(2, (self, that) => self | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self) => isEnabled(self, CooperativeYielding);
var enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled(self, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
var make19 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make19(None2);
var runtimeMetrics = (self) => isEnabled(self, RuntimeMetrics);
var windDown = (self) => isEnabled(self, WindDown);
var diff4 = /* @__PURE__ */ dual(2, (self, that) => make18(self ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self, patch9) => self & (invert(active(patch9)) | enabled(patch9)) | active(patch9) & enabled(patch9));
var differ = /* @__PURE__ */ make17({
  empty: empty14,
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  combine: (first3, second) => andThen(second)(first3),
  patch: (_patch, oldValue) => patch4(oldValue, _patch)
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var enable3 = enable;
var disable2 = disable;
var exclude2 = exclude;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/blockedRequests.js
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var flatten2 = (self) => {
  let current = of3(self);
  let updated = empty10();
  while (1) {
    const [parallel5, sequential5] = reduce7(current, [parallelCollectionEmpty(), empty10()], ([parallel6, sequential6], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel6, par2), appendAll3(sequential6, seq2)];
    });
    updated = merge4(updated, parallel5);
    if (isNil(sequential5)) {
      return reverse3(updated);
    }
    current = sequential5;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel5 = parallelCollectionEmpty();
  let stack = empty10();
  let sequential5 = empty10();
  while (1) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential5 = cons(right3, sequential5);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel5 = parallelCollectionAdd(parallel5, current);
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential5, parallel5) => {
  if (isNil(sequential5)) {
    return of3(parallelCollectionToSequentialCollection(parallel5));
  }
  if (parallelCollectionIsEmpty(parallel5)) {
    return sequential5;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
  const parKeys = parallelCollectionKeys(parallel5);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
};
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map33) {
    this.map = map33;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty9());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce6(self.map, that.map, (map33, value5, key) => set3(map33, key, match2(get7(map33, key), {
  onNone: () => value5,
  onSome: (other) => appendAll2(value5, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty3(self.map);
var parallelCollectionKeys = (self) => Array.from(keys2(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map7(self.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map33) {
    this.map = map33;
  }
};
var sequentialCollectionMake = (map33) => new SequentialImpl(map33);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce6(that.map, self.map, (map33, value5, key) => set3(map33, key, match2(get7(map33, key), {
  onNone: () => empty3(),
  onSome: (a) => appendAll2(a, value5)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys2(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance4 = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto2 = {
  [CauseTypeId]: variance4,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty15 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto2);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error4) => {
  const o = Object.create(proto2);
  o._tag = OP_FAIL;
  o.error = error4;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto2);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId2) => {
  const o = Object.create(proto2);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId2;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto2);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto2);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isEmpty5 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce8(self, true, (acc, cause2) => {
    switch (cause2._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext2(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse2(reduce8(self, empty3(), (list4, cause2) => cause2._tag === OP_FAIL ? some2(pipe(list4, prepend2(cause2.error))) : none2()));
var defects = (self) => reverse2(reduce8(self, empty3(), (list4, cause2) => cause2._tag === OP_DIE ? some2(pipe(list4, prepend2(cause2.defect))) : none2()));
var interruptors = (self) => reduce8(self, empty6(), (set7, cause2) => cause2._tag === OP_INTERRUPT ? some2(pipe(set7, add2(cause2.fiberId))) : none2());
var failureOption = (self) => find(self, (cause2) => cause2._tag === OP_FAIL ? some2(cause2.error) : none2());
var failureOrCause = (self) => {
  const option4 = failureOption(self);
  switch (option4._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option4.value);
    }
  }
};
var flipCauseOption = (self) => match5(self, {
  onEmpty: some2(empty15),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId2) => some2(interrupt(fiberId2)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause2) => cause2._tag === OP_INTERRUPT ? some2(cause2.fiberId) : none2());
var keepDefectsAndElectFailures = (self) => match5(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self) => match5(self, {
  onEmpty: empty15,
  onFail: () => empty15,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match5(self, {
  onEmpty: empty15,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map9 = /* @__PURE__ */ dual(2, (self, f) => flatMap6(self, (e) => fail(f(e))));
var flatMap6 = /* @__PURE__ */ dual(2, (self, f) => match5(self, {
  onEmpty: empty15,
  onFail: (error4) => f(error4),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId2) => interrupt(fiberId2),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty6(), empty3()], ([parallel5, sequential5], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return some2([pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty6(), empty3()], ([parallel5, sequential5], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return some2([pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause2) => {
  return flattenCauseLoop(of2(cause2), empty3());
};
var flattenCauseLoop = (causes, flattened2) => {
  while (1) {
    const [parallel5, sequential5] = pipe(causes, reduce([empty6(), empty3()], ([parallel6, sequential6], cause2) => {
      const [par2, seq2] = evaluateCause(cause2);
      return [pipe(parallel6, union3(par2)), pipe(sequential6, appendAll2(seq2))];
    }));
    const updated = size3(parallel5) > 0 ? pipe(flattened2, prepend2(parallel5)) : flattened2;
    if (isEmpty(sequential5)) {
      return reverse2(updated);
    }
    causes = sequential5;
    flattened2 = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option4 = pf(item);
    switch (option4._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option4;
      }
    }
  }
  return none2();
});
var evaluateCause = (self) => {
  let cause2 = self;
  const stack = [];
  let _parallel = empty6();
  let _sequential = empty3();
  while (cause2 !== void 0) {
    switch (cause2._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add2(_parallel, make5(cause2._tag, cause2.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add2(_parallel, make5(cause2._tag, cause2.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add2(_parallel, make5(cause2._tag, cause2.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause2 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause2.left._tag) {
          case OP_EMPTY: {
            cause2 = cause2.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause2 = sequential(cause2.left.left, sequential(cause2.left.right, cause2.right));
            break;
          }
          case OP_PARALLEL: {
            cause2 = parallel(sequential(cause2.left.left, cause2.right), sequential(cause2.left.right, cause2.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause2.right);
            cause2 = cause2.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match5 = /* @__PURE__ */ dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt2,
  onParallel,
  onSequential
}) => {
  return reduceWithContext2(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error4) => onFail(error4),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId2) => onInterrupt2(fiberId2),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce8 = /* @__PURE__ */ dual(3, (self, zero2, pf) => {
  let accumulator = zero2;
  let cause2 = self;
  const causes = [];
  while (cause2 !== void 0) {
    const option4 = pf(accumulator, cause2);
    accumulator = isSome2(option4) ? option4.value : accumulator;
    switch (cause2._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause2.right);
        cause2 = cause2.left;
        break;
      }
      default: {
        cause2 = void 0;
        break;
      }
    }
    if (cause2 === void 0 && causes.length > 0) {
      cause2 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self, context7, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause2 = input.pop();
    switch (cause2._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context7)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context7, cause2.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context7, cause2.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context7, cause2.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause2.right);
        input.push(cause2.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause2.right);
        input.push(cause2.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either7 = output.pop();
    switch (either7._tag) {
      case "Left": {
        switch (either7.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.sequentialCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value5 = reducer.parallelCase(context7, left3, right3);
            accumulator.push(value5);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either7.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause2, options3) => {
  if (isInterruptedOnly(cause2)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause2).map(function(e) {
    if (options3?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause2, prefix) => {
  const lines3 = cause2.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines3[0]}`;
  for (let i = 1, len = lines3.length; i < len; i++) {
    stack += `
${prefix}${lines3[i]}`;
  }
  if (cause2.cause) {
    stack += ` {
${renderErrorCause(cause2.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span2) => {
  const out2 = [message];
  const lines3 = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines3.length; i++) {
    if (lines3[i].includes(" at new BaseEffectError") || lines3[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines3[i].includes("Generator.next")) {
      break;
    }
    if (lines3[i].includes("effect_internal_function")) {
      break;
    }
    out2.push(lines3[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match17 = false;
          for (const [, location] of locationMatchAll) {
            match17 = true;
            out2.push(`    at ${current.name} (${location})`);
          }
          if (!match17) {
            out2.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out2.push(`    at ${current.name}`);
        }
      } else {
        out2.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out2.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause2) => reduceWithContext2(cause2, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error4) => {
    return [new PrettyError(error4)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect3) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect3
  };
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect3 = new EffectPrimitive("Blocked");
  effect3.effect_instruction_i0 = blockedRequests;
  effect3.effect_instruction_i1 = _continue3;
  return effect3;
};
var runRequestBlock = (blockedRequests) => {
  const effect3 = new EffectPrimitive("RunBlocked");
  effect3.effect_instruction_i0 = blockedRequests;
  return effect3;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch9, op) {
    this.patch = patch9;
    this.op = op;
  }
};
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect3 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect3.effect_instruction_i0 = withRuntime;
  return effect3;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap7(acquire, (a) => flatMap7(exit(suspend(() => restore(use(a)))), (exit4) => {
  return suspend(() => release(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause2) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause2));
        case OP_SUCCESS:
          return failCause(cause2);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self, value5) => flatMap7(self, () => succeed(value5)));
var asVoid = (self) => as(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect3 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect3.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect3.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect3, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect4) {
      if (backingResume) {
        backingResume(effect4);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect4;
      }
    }
    const effect3 = new EffectPrimitive(OP_ASYNC);
    effect3.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect3.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect3, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect3;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
  const effect3 = new EffectPrimitive(OP_ON_FAILURE);
  effect3.effect_instruction_i0 = self;
  effect3.effect_instruction_i1 = f;
  return effect3;
});
var catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause2) => {
  const either7 = failureOrCause(cause2);
  switch (either7._tag) {
    case "Left":
      return predicate(either7.left) ? f(either7.left) : failCause(cause2);
    case "Right":
      return failCause(either7.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause2) => {
  const either7 = failureOrCause(cause2);
  switch (either7._tag) {
    case "Left":
      return pipe(pf(either7.left), getOrElse(() => failCause(cause2)));
    case "Right":
      return failCause(either7.right);
  }
}));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p2) {
        return p2 === spanSymbol || p2 === originalSymbol || p2 in target;
      },
      get(target, p2) {
        if (p2 === spanSymbol) {
          return span2.value;
        }
        if (p2 === originalSymbol) {
          return obj;
        }
        return target[p2];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var either2 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error4) => isObject(error4) && !(spanSymbol in error4) ? withFiberRuntime((fiber) => failCause(fail(capture(error4, currentSpanFromFiber(fiber))))) : failCause(fail(error4));
var failSync = (evaluate2) => flatMap7(sync(evaluate2), fail2);
var failCause = (cause2) => {
  const effect3 = new EffectPrimitiveFailure(OP_FAILURE);
  effect3.effect_instruction_i0 = cause2;
  return effect3;
};
var failCauseSync = (evaluate2) => flatMap7(sync(evaluate2), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap7 = /* @__PURE__ */ dual(2, (self, f) => {
  const effect3 = new EffectPrimitive(OP_ON_SUCCESS);
  effect3.effect_instruction_i0 = self;
  effect3.effect_instruction_i1 = f;
  return effect3;
});
var andThen2 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self) => {
  const effect3 = new EffectPrimitive("OnStep");
  effect3.effect_instruction_i0 = self;
  return effect3;
};
var flatten3 = (self) => flatMap7(self, identity);
var matchCause = /* @__PURE__ */ dual(2, (self, options3) => matchCauseEffect(self, {
  onFailure: (cause2) => succeed(options3.onFailure(cause2)),
  onSuccess: (a) => succeed(options3.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self, options3) => {
  const effect3 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect3.effect_instruction_i0 = self;
  effect3.effect_instruction_i1 = options3.onFailure;
  effect3.effect_instruction_i2 = options3.onSuccess;
  return effect3;
});
var matchEffect = /* @__PURE__ */ dual(2, (self, options3) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const defects2 = defects(cause2);
    if (defects2.length > 0) {
      return failCause(electFailures(cause2));
    }
    const failures2 = failures(cause2);
    if (failures2.length > 0) {
      return options3.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause2);
  },
  onSuccess: options3.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var interrupt2 = /* @__PURE__ */ flatMap7(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = enable3(Interruption);
  effect3.effect_instruction_i1 = () => self;
  return effect3;
};
var intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap7(exit(restore(self)), (exit4) => deferredDone(deferred, exit4))));
var map10 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self, options3) => matchEffect(self, {
  onFailure: (e) => failSync(() => options3.onFailure(e)),
  onSuccess: (a) => sync(() => options3.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const either7 = failureOrCause(cause2);
    switch (either7._tag) {
      case "Left": {
        return failSync(() => f(either7.left));
      }
      case "Right": {
        return failCause(either7.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit4) => exitIsSuccess(exit4) ? void_ : cleanup(exit4.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause2) => isInterruptedOnly(cause2) ? asVoid(cleanup(interruptors(cause2))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var succeed = (value5) => {
  const effect3 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect3.effect_instruction_i0 = value5;
  return effect3;
};
var suspend = (evaluate2) => {
  const effect3 = new EffectPrimitive(OP_COMMIT);
  effect3.commit = evaluate2;
  return effect3;
};
var sync = (thunk) => {
  const effect3 = new EffectPrimitive(OP_SYNC);
  effect3.effect_instruction_i0 = thunk;
  return effect3;
};
var tap = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self, f) => flatMap7(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope4 = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope4)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const defects2 = defects(cause2);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause2)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = disable2(Interruption);
  effect3.effect_instruction_i1 = () => self;
  return effect3;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = disable2(Interruption);
  effect3.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect3;
});
var void_ = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = (patch9) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = patch9;
  effect3.effect_instruction_i1 = void 0;
  return effect3;
};
var whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => {
  if (b) {
    return pipe(self, map10(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options3) => {
  const effect3 = new EffectPrimitive(OP_WHILE);
  effect3.effect_instruction_i0 = options3.while;
  effect3.effect_instruction_i1 = options3.body;
  effect3.effect_instruction_i2 = options3.step;
  return effect3;
};
var fromIterator = (iterator) => suspend(() => {
  const effect3 = new EffectPrimitive(OP_ITERATOR);
  effect3.effect_instruction_i0 = iterator();
  return effect3;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect3 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect3 = x(effect3, ...args2);
  }
  return effect3;
}, "length", {
  value: body.length,
  configurable: true
});
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update5) => {
  const effect3 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect3.effect_instruction_i0 = update5;
  effect3.effect_instruction_i1 = () => self;
  return effect3;
});
var yieldNow = (options3) => {
  const effect3 = new EffectPrimitive(OP_YIELD);
  return typeof options3?.priority !== "undefined" ? withSchedulingPriority(effect3, options3.priority) : effect3;
};
var zip2 = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => map10(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap7(self, () => that));
var zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap7(self, (a) => map10(that, (b) => f(a, b))));
var interruptFiber = (self) => flatMap7(fiberId, (fiberId2) => pipe(self, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId2) => flatMap7(self.interruptAsFork(fiberId2), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap7(fiberRefGet(self), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self, value5) => fiberRefModify(self, () => [void 0, value5]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value5) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value5)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
var fiberRefUnsafeMake = (initial, options3) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options3?.fork ?? identity,
  join: options3?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ3 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options3) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options3.differ.diff(oldValue, newValue),
    combine: (first3, second) => options3.differ.combine(first3, second),
    patch: (patch9) => (oldValue) => options3.differ.patch(patch9, oldValue),
    fork: options3.fork,
    join: options3.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty8()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty15, {
  fork: () => empty15,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty3()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer2) => self.addFinalizer(() => asVoid(finalizer2));
var scopeAddFinalizerExit = (self, finalizer2) => self.addFinalizer(finalizer2);
var scopeClose = (self, exit4) => self.close(exit4);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self, f) => {
  const option4 = pipe(self, failureOption, map2(f));
  switch (option4._tag) {
    case "None": {
      return pipe(defects(self), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id2) => `#${id2}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option4.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto25, tag4) => {
  class Base3 extends YieldableError {
    _tag = tag4;
  }
  Object.assign(Base3.prototype, proto25);
  Base3.prototype.name = tag4;
  return Base3;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration3) => new TimeoutException(`Operation timed out after '${format2(duration3)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {
  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause2, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause2
      });
      this.error = cause2;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self, value5) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value5);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCollectAll = (exits, options3) => exitCollectAllInternal(exits, options3?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error4) => exitFailCause(fail(error4));
var exitFailCause = (cause2) => {
  const effect3 = new EffectPrimitiveFailure(OP_FAILURE);
  effect3.effect_instruction_i0 = cause2;
  return effect3;
};
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map9(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value5) => {
  const effect3 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect3.effect_instruction_i0 = value5;
  return effect3;
};
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list4 = fromIterable2(exits);
  if (!isNonEmpty(list4)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list4), reduce(pipe(headNonEmpty2(list4), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list5, value5) => pipe(list5, prepend2(value5)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk4) => toReadonlyArray(chunk4)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap7(fiberId, (id2) => deferredMakeAs(id2));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self) => asyncInterrupt((resume2) => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self, effect3) => intoDeferred(effect3, self));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect3) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self.state, done(effect3));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect3);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self, exit4) => deferredCompleteWith(self, exit4));
var deferredFail = /* @__PURE__ */ dual(2, (self, error4) => deferredCompleteWith(self, fail2(error4)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self, cause2) => deferredCompleteWith(self, failCause(cause2)));
var deferredInterrupt = (self) => flatMap7(fiberId, (fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
var deferredIsDone = (self) => sync(() => get6(self.state)._tag === OP_STATE_DONE);
var deferredSucceed = /* @__PURE__ */ dual(2, (self, value5) => deferredCompleteWith(self, succeed(value5)));
var deferredUnsafeDone = (self, effect3) => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect3));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect3);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap7(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self, context7) => fiberRefLocally(currentContext, context7)(self));
var provideSomeContext = /* @__PURE__ */ dual(2, (self, context7) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context7))(self));
var mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context7) => provideContext(self, f(context7))));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== void 0 && span2._tag === "Span" ? some2(span2) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options3) => Object.assign(Object.create(NoopSpanProto), options3);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration3) {
    const millis2 = toMillis(duration3);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var ClockImpl = class {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration3) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_), duration3);
      return asVoid(sync(canceler));
    });
  }
};
var make20 = () => new ClockImpl();

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Number.js
var Order = number3;
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};
var round = /* @__PURE__ */ dual(2, (self, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self * factor) / factor;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/RegExp.js
var escape = (string7) => string7.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty16 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path2, patch9) => {
  let input = of3(patch9);
  let output = path2;
  while (isCons(input)) {
    const patch10 = input.head;
    switch (patch10._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch10.first, cons(patch10.second, input.tail));
        break;
      }
      case "MapName": {
        output = map3(output, patch10.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch10.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch10.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = (options3) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options3
});
var makeFlat = (options3) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options3.patch,
  load: (path2, config2, split2 = true) => options3.load(path2, config2, split2),
  enumerateChildren: options3.enumerateChildren
});
var fromFlat = (flat) => make21({
  load: (config2) => flatMap7(fromFlatLoop(flat, empty2(), config2, false), (chunk4) => match2(head(chunk4), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options3) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options3);
  const makePathString = (path2) => pipe(path2, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path2, primitive2, split2 = true) => {
    const pathString = makePathString(path2);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path2, `Expected ${pathString} to exist in the process context`)), flatMap7((value5) => parsePrimitive(value5, path2, primitive2, seqDelim, split2)));
  };
  const enumerateChildren = (path2) => sync(() => {
    const current = getEnv();
    const keys5 = Object.keys(current);
    const keyPaths = keys5.map((value5) => unmakePathString(value5.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path2.length; i++) {
        const pathComponent = pipe(path2, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path2.length, path2.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty16
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path2, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out2 = path2.slice();
    while (op._tag === "Nested") {
      out2.push(op.name);
      op = op.config;
    }
    return out2;
  }
  return path2;
};
var fromFlatLoop = (flat, prefix, config2, split2) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split2));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split2)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split2), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split2));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split2), flatMap7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split2));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.load(prefix2, op, split2), flatMap7((values3) => {
        if (values3.length === 0) {
          const name2 = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name2}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap7(indicesFrom), flatMap7((indices) => {
        if (indices.length === 0) {
          return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
          const flattened2 = flatten(chunkChunk);
          if (flattened2.length === 0) {
            return of(empty2());
          }
          return of(flattened2);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap7((keys5) => {
        return pipe(keys5, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split2)), map10((matrix) => {
          if (matrix.length === 0) {
            return of(empty9());
          }
          return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys5), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split2), either2, flatMap7((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split2), either2, flatMap7((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path2 = pipe(prefix, join("."));
          const fail18 = fromFlatLoopFail(prefix, path2);
          const [lefts, rights] = extend(fail18, fail18, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path2) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path2}" was missing`));
var splitPathString = (text9, delim) => {
  const split2 = text9.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split2;
};
var parsePrimitive = (text9, path2, primitive2, delimiter, split2) => {
  if (!split2) {
    return pipe(primitive2.parse(text9), mapBoth2({
      onFailure: prefixed(path2),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text9, delimiter), forEachSequential((char4) => primitive2.parse(char4.trim())), mapError(prefixed(path2)));
};
var transpose = (array7) => {
  return Object.keys(array7[0]).map((column3) => array7.map((row) => row[column3]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either2, map10(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match17 = str.match(QUOTED_INDEX_REGEX);
  if (match17 !== null) {
    const matchedIndex = match17[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId8]: TypeId8,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options3) {
    return sync(() => {
      console.dir(item, options3);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options3) {
    return options3?.collapsed ? sync(() => console.groupCollapsed(options3?.label)) : sync(() => console.group(options3?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map10(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min4, max6) {
    return map10(this.next, (n) => (max6 - min4) * n + min4);
  }
  nextIntBetween(min4, max6) {
    return sync(() => this.PRNG.integer(max6 - min4) + min4);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap7((buffer3) => {
    const numbers = [];
    for (let i = buffer3.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer3, n - 1, k)))), as(fromIterable2(buffer3)));
  })));
};
var swap = (buffer3, index1, index2) => {
  const tmp = buffer3[index1];
  buffer3[index1] = buffer3[index2];
  buffer3[index2] = tmp;
  return buffer3;
};
var make22 = (seed) => new RandomImpl(hash(seed));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = (options3) => ({
  [TracerTypeId]: TracerTypeId,
  ...options3
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length3) {
    let result = "";
    for (let i = 0; i < length3; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name2, parent, context7, links, startTime, kind) {
    this.name = name2;
    this.parent = parent;
    this.context = context7;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value5) {
    this.attributes.set(key, value5);
  }
  event(name2, startTime, attributes) {
    this.events.push([name2, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = /* @__PURE__ */ make23({
  span: (name2, parent, context7, links, startTime, kind) => new NativeSpan(name2, parent, context7, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options3) => {
  if (options3?.captureStackTrace === false) {
    return options3;
  } else if (options3?.captureStackTrace !== void 0 && typeof options3.captureStackTrace !== "boolean") {
    return options3;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options3,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty8(), /* @__PURE__ */ add4(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add4(consoleTag, defaultConsole), /* @__PURE__ */ add4(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add4(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add4(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration3) => {
  const decodedDuration = decode(duration3);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto3 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make24 = (value5) => {
  const redacted4 = Object.create(proto3);
  redactedRegistry.set(redacted4, value5);
  return redacted4;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto3,
  [SecretTypeId]: SecretTypeId
};
var make25 = (bytes) => {
  const secret4 = Object.create(SecretProto);
  Object.defineProperty(secret4, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret4, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret4, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret4, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret4;
};
var fromString = (text9) => {
  return make25(text9.split("").map((char4) => char4.charCodeAt(0)));
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var isConfig = (u) => hasProperty(u, ConfigTypeId);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Config.js
var isConfig2 = isConfig;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Boolean.js
var not = (self) => !self;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make26 = deferredMake;
var _await = deferredAwait;
var complete = deferredComplete;
var fail4 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var succeed3 = deferredSucceed;
var unsafeDone = deferredUnsafeDone;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
var Class2 = class extends Base2 {
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake3(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty17() {
  return unsafeMake3(/* @__PURE__ */ new Map());
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self, fiberId2, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
  const map33 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map33, childId);
  return new FiberRefsImpl(map33);
});
var unsafeForkAs = (self, map33, fiberId2) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map33.set(fiberRef, stack);
    } else {
      map33.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get8(self, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self, {
  fiberId: fiberId2,
  fiberRef,
  value: value5
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId2, value5]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value5);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value5) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value5)) {
        return;
      } else {
        newStack = [[fiberId2, value5], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value5], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value5]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId2, value5]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value5);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/FiberRefs.js
var get9 = get8;
var getOrDefault2 = getOrDefault;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty18 = empty17;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty19 = {
  _tag: OP_EMPTY2
};
var diff5 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty19;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine7 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self, fiberId2, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head5 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head5._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId2,
          fiberRef: head5.fiberRef,
          value: head5.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head5.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value5 = getOrDefault(fiberRefs3, head5.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId2,
          fiberRef: head5.fiberRef,
          value: head5.fiberRef.patch(head5.patch)(value5)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head5.first)(prepend(head5.second)(tail));
        break;
      }
    }
  }
  return fiberRefs3;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done2 = /* @__PURE__ */ new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/FiberStatus.js
var done3 = done2;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
var fromLiteral = (literal2) => {
  switch (literal2) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Micro.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name2;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name2 = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name2}: ${message}`;
    } else {
      name2 = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name2}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name2;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Die = class extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context7, interruptible5 = true) {
    this.context = context7;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect3) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect3);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap8(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect3) {
    let yielding = false;
    let current = effect3;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap8(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error4) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error4);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol3]: cont
      };
      if (op[symbol3]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value5) {
    this._yielded = value5;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId9]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options3) => ({
  ...MicroProto,
  [identifier]: options3.op,
  [evaluate]: options3.eval ?? defaultEvaluate,
  [successCont]: options3.contA,
  [failureCont]: options3.contE,
  [ensureCont]: options3.ensure
});
var makePrimitive = (options3) => {
  const Proto4 = makePrimitiveProto(options3);
  return function() {
    const self = Object.create(Proto4);
    self[args] = options3.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options3) => {
  const Proto4 = {
    ...makePrimitiveProto(options3),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options3.op,
    get [options3.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options3.op,
        [options3.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options3.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options3.op))(hash(this[args])));
    }
  };
  return function(value5) {
    const self = Object.create(Proto4);
    self[args] = value5;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
};
var succeed4 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed4(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var flatMap8 = /* @__PURE__ */ dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed4;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var setImmediate2 = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate2(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge3(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
};
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
})) {
};
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options3) => {
  const primitive2 = Object.create(OnSuccessAndFailureProto);
  primitive2[args] = self;
  primitive2[successCont] = options3.onSuccess;
  primitive2[failureCont] = options3.onFailure;
  return primitive2;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause2) => flatMap8(f(exitFailCause2(cause2)), () => failCause3(cause2)),
  onSuccess: (a) => flatMap8(f(exitSucceed2(a)), () => succeed4(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var runFork = (effect3, options3) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(new MicroSchedulerDefault()));
  fiber.evaluate(effect3);
  return fiber;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Readable.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Readable");

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var RefImpl = class extends Class2 {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake4 = (value5) => new RefImpl(make13(value5));
var make27 = (value5) => sync(() => unsafeMake4(value5));
var get10 = (self) => self.get;
var set4 = /* @__PURE__ */ dual(2, (self, value5) => self.modify(() => [void 0, value5]));
var modify2 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
var update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
  const result = f(a);
  return [result, result];
}));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Ref.js
var make28 = make27;
var get11 = get10;
var modify3 = modify2;
var set5 = set4;
var update3 = update2;
var updateAndGet2 = updateAndGet;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets = class {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/concurrency.js
var match7 = (concurrency, sequential5, unbounded6, bounded4) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return unbounded6();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded6() : concurrency2 > 1 ? bounded4(concurrency2) : sequential5());
    default:
      return concurrency > 1 ? bounded4(concurrency) : sequential5();
  }
};
var matchSimple = (concurrency, sequential5, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
    default:
      return concurrency > 1 ? concurrent() : sequential5();
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var Clock = clockTag;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/logSpan.js
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now - self.startTime}ms`;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Tracer.js
var ParentSpan = spanTag;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value5) {
    this.key = key;
    this.value = value5;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make29 = (key, value5) => {
  return new MetricLabelImpl(key, value5);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value5]) => set3(acc, key, value5), annotations2));
});
var asSome = (self) => map10(self, some2);
var try_ = (arg) => {
  let evaluate2;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate2 = arg;
  } else {
    evaluate2 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate2));
    } catch (error4) {
      return fail2(onFailure ? internalCall(() => onFailure(error4)) : new UnknownException(error4, "An unknown error occurred in Effect.try"));
    }
  });
};
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag4 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag4) return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag4) return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
  let keys5;
  return catchIf(self, (e) => {
    keys5 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys5.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var diffFiberRefs = (self) => summarized(self, fiberRefs2, diff5);
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse14) => flatMap7(self, (a) => predicate(a) ? succeed(a) : orElse14(a)));
var match8 = /* @__PURE__ */ dual(2, (self, options3) => matchEffect(self, {
  onFailure: (e) => succeed(options3.onFailure(e)),
  onSuccess: (a) => succeed(options3.onSuccess(a))
}));
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== void 0) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === void 0) {
    cause2 = empty15;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_;
  });
};
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var negate = (self) => map10(self, (b) => !b);
var orElseFail = /* @__PURE__ */ dual(2, (self, evaluate2) => orElse2(self, () => failSync(evaluate2)));
var patchFiberRefs = (patch9) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch9, patch6(fiberId2, fiberRefs3)));
var provideService = /* @__PURE__ */ dual(3, (self, tag4, service2) => contextWithEffect((env2) => provideContext(self, add4(env2, tag4, service2))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag4, effect3) => contextWithEffect((env2) => flatMap7(effect3, (service2) => provideContext(self, pipe(env2, add4(tag4, service2))))));
var repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap7(self, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1)));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var summarized = /* @__PURE__ */ dual(3, (self, summary5, f) => flatMap7(summary5, (start4) => flatMap7(self, (value5) => map10(summary5, (end5) => [f(start4, end5), value5]))));
var tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var tryPromise = (arg) => {
  let evaluate2;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate2 = arg;
  } else {
    evaluate2 = arg.try;
    catcher = arg.catch;
  }
  const fail18 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate2.length >= 1) {
    return async_((resolve3, signal) => {
      try {
        evaluate2(signal).then((a) => resolve3(exitSucceed(a)), (e) => resolve3(fail18(e)));
      } catch (e) {
        resolve3(fail18(e));
      }
    });
  }
  return async_((resolve3) => {
    try {
      evaluate2().then((a) => resolve3(exitSucceed(a)), (e) => resolve3(fail18(e)));
    } catch (e) {
      resolve3(fail18(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self, options3) => flatMap7(self, (a) => try_({
  try: () => options3.try(a),
  catch: options3.catch
})));
var unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap7(condition, (b) => b ? succeedNone : asSome(self)));
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map10(self, some2) : succeed(none2())));
var serviceOption = (tag4) => map10(context(), getOption2(tag4));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get5(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
var unsafeMakeSpan = (fiber, name2, options3) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options3.context && get5(options3.context, DisablePropagation);
  const context7 = fiber.getFiberRef(currentContext);
  const parent = options3.parent ? some2(options3.parent) : options3.root ? none2() : filterDisablePropagation(getOption2(context7, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name: name2,
      parent,
      context: add4(options3.context ?? empty8(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer2 = get5(services, tracerTag);
    const clock3 = get5(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get9(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get9(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options3.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options3.links ?? []] : toReadonlyArray(linksFromEnv.value) : options3.links ?? empty2();
    span2 = tracer2.span(name2, parent, options3.context ?? empty8(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, options3.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach3(annotationsFromEnv.value, (value5, key) => span2.attribute(key, value5));
    }
    if (options3.attributes !== void 0) {
      Object.entries(options3.attributes).forEach(([k, v]) => span2.attribute(k, v));
    }
  }
  if (typeof options3.captureStackTrace === "function") {
    spanToTrace.set(span2, options3.captureStackTrace);
  }
  return span2;
};
var endSpan = (span2, exit4, clock3, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, exit4);
});
var useSpan = (name2, ...args2) => {
  const options3 = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate2 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name2, options3);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get5(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate2(span2), (exit4) => endSpan(span2, exit4, clock3, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self, span2) => provideService(self, spanTag, span2));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name2 = dataFirst ? arguments[1] : arguments[0];
  const options3 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name2, options3, (span2) => withParentSpan(self, span2));
  }
  return (self) => useSpan(name2, options3, (span2) => withParentSpan(self, span2));
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Exit.js
var isFailure = exitIsFailure;
var isSuccess = exitIsSuccess;
var all3 = exitCollectAll;
var die3 = exitDie;
var fail5 = exitFail;
var failCause4 = exitFailCause;
var map13 = exitMap;
var mapBoth3 = exitMapBoth;
var match9 = exitMatch;
var succeed5 = exitSucceed;
var void_3 = exitVoid;
var zip4 = exitZip;
var zipRight2 = exitZipRight;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect3) => ({
  _tag: OP_RESUME,
  effect: effect3
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var Global = class {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake5 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var _await2 = (self) => self.await;
var inheritAll = (self) => self.inheritAll;
var interruptAllAs = /* @__PURE__ */ dual(2, (fibers, fiberId2) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId2)), zipRight(pipe(fibers, forEachSequentialDiscard(_await2)))));
var interruptAsFork = /* @__PURE__ */ dual(2, (self, fiberId2) => self.interruptAsFork(fiberId2));
var join2 = (self) => zipLeft(flatten3(self.await), self.inheritAll);
var currentFiberURI = "effect/FiberCurrent";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = (log4) => ({
  [LoggerTypeId]: loggerVariance,
  log: log4,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations: annotations2,
  cause: cause2,
  date: date5,
  fiberId: fiberId2,
  logLevel: logLevel2,
  message,
  spans: spans2
}) => {
  const formatValue = (value5) => value5.match(textOnly) ? value5 : quoteValue(value5);
  const format6 = (label, value5) => `${formatLabel(label)}=${formatValue(value5)}`;
  const append4 = (label, value5) => " " + format6(label, value5);
  let out2 = format6("timestamp", date5.toISOString());
  out2 += append4("level", logLevel2.label);
  out2 += append4("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out2 += append4("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out2 += append4("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans2) {
    out2 += " " + render(date5.getTime())(span2);
  }
  for (const [label, value5] of annotations2) {
    out2 += append4(label, toStringUnknown(value5, whitespace));
  }
  return out2;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var withColor = (text9, ...colors2) => {
  let out2 = "";
  for (let i = 0; i < colors2.length; i++) {
    out2 += `\x1B[${colors2[i]}m`;
  }
  return out2 + text9 + "\x1B[0m";
};
var withColorNoop = (text9, ..._colors) => text9;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date5) => `${date5.getHours().toString().padStart(2, "0")}:${date5.getMinutes().toString().padStart(2, "0")}:${date5.getSeconds().toString().padStart(2, "0")}.${date5.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options3) => {
  const mode = hasProcessStdoutOrDeno ? "tty" : "browser" ;
  const isBrowser = mode === "browser";
  const showColors = processStdoutIsTTY || isBrowser;
  const formatDate2 = defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: options3?.stderr === true
  });
};
var prettyLoggerTty = (options3) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color3 = options3.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context7,
    date: date5,
    fiberId: fiberId2,
    logLevel: logLevel2,
    message: message_,
    spans: spans2
  }) => {
    const services = getOrDefault2(context7, currentServices);
    const console2 = get5(services, consoleTag).unsafe;
    const log4 = options3.stderr === true ? console2.error : console2.log;
    const message = ensure(message_);
    let firstLine = color3(`[${options3.formatDate(date5)}]`, colors.white) + ` ${color3(logLevel2.label, ...logLevelColors[logLevel2._tag])} (${threadName(fiberId2)})`;
    if (isCons(spans2)) {
      const now = date5.getTime();
      const render5 = render(now);
      for (const span2 of spans2) {
        firstLine += " " + render5(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color3(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log4(firstLine);
    if (!processIsBun) console2.group();
    if (!isEmpty5(cause2)) {
      log4(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log4(redact(message[messageIndex]));
      }
    }
    if (size4(annotations2) > 0) {
      for (const [key, value5] of annotations2) {
        log4(color3(`${key}:`, colors.bold, colors.white), redact(value5));
      }
    }
    if (!processIsBun) console2.groupEnd();
  });
};
var prettyLoggerBrowser = (options3) => {
  const color3 = options3.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context7,
    date: date5,
    fiberId: fiberId2,
    logLevel: logLevel2,
    message: message_,
    spans: spans2
  }) => {
    const services = getOrDefault2(context7, currentServices);
    const console2 = get5(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color3}[${options3.formatDate(date5)}]`;
    const firstParams = [];
    if (options3.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color3}${logLevel2.label}${color3} (${threadName(fiberId2)})`;
    if (options3.colors) {
      firstParams.push(logLevelStyle[logLevel2._tag], "");
    }
    if (isCons(spans2)) {
      const now = date5.getTime();
      const render5 = render(now);
      for (const span2 of spans2) {
        firstLine += " " + render5(span2);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color3}${firstMaybeString}`;
        if (options3.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console2.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty5(cause2)) {
      console2.error(pretty(cause2, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console2.log(redact(message[messageIndex]));
      }
    }
    if (size4(annotations2) > 0) {
      for (const [key, value5] of annotations2) {
        const redacted4 = redact(value5);
        if (options3.colors) {
          console2.log(`%c${key}:`, "color:gray", redacted4);
        } else {
          console2.log(`${key}:`, redacted4);
        }
      }
    }
    console2.groupEnd();
  });
};
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable7 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options3) => pipe(makeBy(options3.count - 1, (i) => options3.start * Math.pow(options3.factor, i)), unsafeFromArray, fromIterable7);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var CounterKeyType = class {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = (options3) => new CounterKeyType(options3?.incremental ?? false, options3?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);
var MetricKeyImpl = class {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name2, keyType, description, tags2 = []) {
    this.name = name2;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags2;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name2, options3) => new MetricKeyImpl(name2, counter(options3), fromNullable(options3?.description));
var histogram2 = (name2, boundaries, description) => new MetricKeyImpl(name2, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty20 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var get12 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self.buckets.get(hash2);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove8 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value5 = bucket[i][1];
      if (remove8) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value5);
    }
  }
  return none2();
};
var has5 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get12(self, key)));
var set6 = /* @__PURE__ */ dual(3, (self, key, value5) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value5);
    return self;
  }
  const hash2 = key[symbol]();
  const bucket = self.buckets.get(hash2);
  if (bucket === void 0) {
    self.buckets.set(hash2, [[key, value5]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value5]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count4) {
    this.count = count4;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = /* @__PURE__ */ getEquivalence(equals);
var FrequencyState = class {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value5) {
    this.value = value5;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count4, min4, max6, sum3) {
    this.buckets = buckets;
    this.count = count4;
    this.min = min4;
    this.max = max6;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error4, quantiles, count4, min4, max6, sum3) {
    this.error = error4;
    this.quantiles = quantiles;
    this.count = count4;
    this.min = min4;
    this.max = max6;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = (count4) => new CounterState(count4);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count4) => new GaugeState(count4);
var histogram3 = (options3) => new HistogramState(options3.buckets, options3.count, options3.min, options3.max, options3.sum);
var summary2 = (options3) => new SummaryState(options3.error, options3.quantiles, options3.count, options3.min, options3.max, options3.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make30 = (options3) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options3
});
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value5) => value5 >= bigint03 : (value5) => value5 >= 0 : (_value) => true;
  const update5 = (value5) => {
    if (canUpdate(value5)) {
      sum3 = sum3 + value5;
    }
  };
  return make30({
    get: () => counter3(sum3),
    update: update5,
    modify: update5
  });
};
var frequency3 = (key) => {
  const values3 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update5 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make30({
    get: () => frequency2(values3),
    update: update5,
    modify: update5
  });
};
var gauge3 = (_key, startAt) => {
  let value5 = startAt;
  return make30({
    get: () => gauge2(value5),
    update: (v) => {
      value5 = v;
    },
    modify: (v) => {
      value5 = value5 + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size13 = bounds.length;
  const values3 = new Uint32Array(size13 + 1);
  const boundaries = new Float32Array(size13);
  let count4 = 0;
  let sum3 = 0;
  let min4 = Number.MAX_VALUE;
  let max6 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update5 = (value5) => {
    let from = 0;
    let to = size13;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value5 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value5 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count4 = count4 + 1;
    sum3 = sum3 + value5;
    if (value5 < min4) {
      min4 = value5;
    }
    if (value5 > max6) {
      max6 = value5;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size13);
    let cumulated = 0;
    for (let i = 0; i < size13; i++) {
      const boundary = boundaries[i];
      const value5 = values3[i];
      cumulated = cumulated + value5;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count4,
      min: min4,
      max: max6,
      sum: sum3
    }),
    update: update5,
    modify: update5
  });
};
var summary3 = (key) => {
  const {
    error: error4,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values3 = allocate(maxSize);
  let head5 = 0;
  let count4 = 0;
  let sum3 = 0;
  let min4 = Number.MAX_VALUE;
  let max6 = Number.MIN_VALUE;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values3[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error4, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value5, timestamp) => {
    if (maxSize > 0) {
      head5 = head5 + 1;
      const target = head5 % maxSize;
      values3[target] = [timestamp, value5];
    }
    count4 = count4 + 1;
    sum3 = sum3 + value5;
    if (value5 < min4) {
      min4 = value5;
    }
    if (value5 > max6) {
      max6 = value5;
    }
  };
  return make30({
    get: () => summary2({
      error: error4,
      quantiles: snapshot(Date.now()),
      count: count4,
      min: min4,
      max: max6,
      sum: sum3
    }),
    update: ([value5, timestamp]) => observe(value5, timestamp),
    modify: ([value5, timestamp]) => observe(value5, timestamp)
  });
};
var calculateQuantiles = (error4, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head5 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error4, sampleCount, none2(), 0, head5, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error4, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error4, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error4;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error4;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var unsafeMake6 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty20();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake6(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get12(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const counter6 = counter4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, counter6));
      }
      value5 = counter6;
    }
    return value5;
  }
  getFrequency(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const frequency5 = frequency3(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, frequency5));
      }
      value5 = frequency5;
    }
    return value5;
  }
  getGauge(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const gauge5 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, gauge5));
      }
      value5 = gauge5;
    }
    return value5;
  }
  getHistogram(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, histogram6));
      }
      value5 = histogram6;
    }
    return value5;
  }
  getSummary(key) {
    let value5 = pipe(this.map, get12(key), getOrUndefined);
    if (value5 == null) {
      const summary5 = summary3(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set6(key, summary5));
      }
      value5 = summary5;
    }
    return value5;
  }
};
var make31 = () => {
  return new MetricRegistryImpl();
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect3) => tap(effect3, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name2, options3) => fromMetricKey(counter2(name2, options3));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name2, boundaries, description) => fromMetricKey(histogram2(name2, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self, key, value5) => taggedWithLabels2(self, [make29(key, value5)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
  return make32(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags2) => sync(() => self.unsafeUpdate(input, tags2))));
var complete2 = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map33) => sync(() => {
  if (map33.has(self)) {
    const entry = map33.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var ProxySupervisor = class _ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context7, effect3, parent, fiber) {
    this.underlying.onStart(context7, effect3, parent, fiber);
  }
  onEnd(value5, fiber) {
    this.underlying.onEnd(value5, fiber);
  }
  onEffect(fiber, effect3) {
    this.underlying.onEffect(fiber, effect3);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var Zip = class _Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context7, effect3, parent, fiber) {
    this.left.onStart(context7, effect3, parent, fiber);
    this.right.onStart(context7, effect3, parent, fiber);
  }
  onEnd(value5, fiber) {
    this.left.onEnd(value5, fiber);
    this.right.onEnd(value5, fiber);
  }
  onEffect(fiber, effect3) {
    this.left.onEffect(fiber, effect3);
    this.right.onEffect(fiber, effect3);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var Const = class {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect3) {
    this.effect = effect3;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var fromEffect = (effect3) => {
  return new Const(effect3);
};
var none7 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Differ.js
var make34 = make17;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty23 = {
  _tag: OP_EMPTY3
};
var combine8 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch8 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head5 = headNonEmpty2(patches);
    switch (head5._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head5.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head5.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head5.first)(prepend2(head5.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none7;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet2 = (self) => {
  if (equals(self, none7)) {
    return empty6();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union3(toSet2(self.right)));
    } else {
      return make10(self);
    }
  }
};
var diff7 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty23;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty23, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty23, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
};
var differ2 = /* @__PURE__ */ make34({
  empty: empty23,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value5) => {
    return internalCall(() => cont.effect_instruction_i1(value5));
  },
  ["OnStep"]: (_, _cont, value5) => {
    return exitSucceed(exitSucceed(value5));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value5) => {
    return internalCall(() => cont.effect_instruction_i2(value5));
  },
  [OP_REVERT_FLAGS]: (self, cont, value5) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value5);
    }
  },
  [OP_WHILE]: (self, cont, value5) => {
    internalCall(() => cont.effect_instruction_i2(value5));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self, cont, value5) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value5));
    if (state.done) return exitSucceed(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap7(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten2(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
  const map33 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential5) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map33.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map33);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class2 {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags2 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags2);
      fiberActive.unsafeUpdate(1, tags2);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect3) {
    this.tell(resume(effect3));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status2) => status2);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status2) => {
      if (isDone3(status2)) {
        return state.currentRuntimeFlags;
      }
      return status2.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake5(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status2) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status2)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch9 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch9);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value5) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value5
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope4) {
    const children2 = this._children;
    this._children = null;
    if (children2 !== null && children2.size > 0) {
      for (const child of children2) {
        if (child._exitValue === null) {
          scope4.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone6 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone6 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone6,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags2 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags2);
      fiberActive.unsafeUpdate(-1, tags2);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags2);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags2);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel2 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan2(minimumLogLevel2, logLevel2)) {
      return;
    }
    const spans2 = this.getFiberRef(currentLogSpan);
    const annotations2 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get5(this.getFiberRef(currentServices), clockTag);
      const date5 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel2,
            message,
            cause: cause2,
            context: contextMap,
            spans: spans2,
            annotations: annotations2,
            date: date5
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done3 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect3 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect3 !== null) {
        const eff = effect3;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect3 = null;
            } else {
              effect3 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect3 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect3 = flatMap7(interruption2, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect3 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect3) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect3);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect3));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect3) {
    this.tell(resume(effect3));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch9) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect3) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect3));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet4(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value5 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value5);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value5);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap7(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check2 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check2()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap7(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
};
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get5(services, consoleTag).unsafe.log(self.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations2,
  cause: cause2,
  context: context7,
  fiberId: fiberId2,
  logLevel: logLevel2,
  message
}) => {
  const span2 = getOption2(getOrDefault(context7, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet4(getOrDefault(context7, currentServices), clockTag);
  const attributes = {};
  for (const [key, value5] of annotations2) {
    attributes[key] = value5;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel2.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit4) => release(a, exit4)))));
var addFinalizer = (finalizer2) => withFiberRuntime((runtime5) => {
  const acquireRefs = runtime5.getFiberRefs();
  const acquireFlags = runtime5.currentRuntimeFlags;
  return flatMap7(scope, (scope4) => scopeAddFinalizerExit(scope4, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer2(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var filter6 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options3) => {
  const predicate_ = options3?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
  return matchSimple(options3?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect3, a, i) => zipWith2(effect3, suspend(() => predicate_(a, i)), (list4, b) => b ? [a, ...list4] : list4), sync(() => new Array()))), () => map10(forEach7(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options3), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys5 = Object.keys(input);
  const size13 = keys5.length;
  return [keys5.map((k) => input[k]), some2((values3) => {
    const res = {};
    for (let i = 0; i < size13; i++) {
      res[keys5[i]] = values3[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options3) => {
  const eitherEffects = [];
  for (const effect3 of effects) {
    eitherEffects.push(either2(effect3));
  }
  return flatMap7(forEach7(eitherEffects, identity, {
    concurrency: options3?.concurrency,
    batching: options3?.batching,
    concurrentFinalizers: options3?.concurrentFinalizers
  }), (eithers) => {
    const none12 = none2();
    const size13 = eithers.length;
    const errors = new Array(size13);
    const successes = new Array(size13);
    let errored = false;
    for (let i = 0; i < size13; i++) {
      const either7 = eithers[i];
      if (either7._tag === "Left") {
        errors[i] = some2(either7.left);
        errored = true;
      } else {
        successes[i] = either7.right;
        errors[i] = none12;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options3?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options3) => {
  const eitherEffects = [];
  for (const effect3 of effects) {
    eitherEffects.push(either2(effect3));
  }
  if (options3?.discard) {
    return forEach7(eitherEffects, identity, {
      concurrency: options3?.concurrency,
      batching: options3?.batching,
      discard: true,
      concurrentFinalizers: options3?.concurrentFinalizers
    });
  }
  return map10(forEach7(eitherEffects, identity, {
    concurrency: options3?.concurrency,
    batching: options3?.batching,
    concurrentFinalizers: options3?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all4 = (arg, options3) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options3?.mode === "validate") {
    return allValidate(effects, reconcile, options3);
  } else if (options3?.mode === "either") {
    return allEither(effects, reconcile, options3);
  }
  return options3?.discard !== true && reconcile._tag === "Some" ? map10(forEach7(effects, identity, options3), reconcile.value) : forEach7(effects, identity, options3);
};
var forEach7 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self, f, options3) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options3?.batching === true || options3?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options3?.discard) {
    return match7(options3.concurrency, () => finalizersMaskInternal(sequential3, options3?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options3?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options3?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options3?.concurrency, () => finalizersMaskInternal(sequential3, options3?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options3?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options3?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as9 = fromIterable(self);
  const array7 = new Array(as9.length);
  const fn2 = (a, i) => flatMap7(f(a, i), (b) => sync(() => array7[i] = b));
  return zipRight(forEachConcurrentDiscard(as9, fn2, batching, false), succeed(array7));
});
var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted2 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll2 = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted2 = true;
    interruptAll2();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted2) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap7(yieldNow(), () => flatMap7(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap7(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted2) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit4, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten3(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        let count4 = 0;
        let index = 0;
        const check2 = (index2, hitNext) => (exit4) => {
          count4++;
          if (count4 === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check2(index, true));
          index++;
        };
        processingFiber.addObserver(check2(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self, n, f, batching) => suspend(() => {
  const as9 = fromIterable(self);
  const array7 = new Array(as9.length);
  const fn2 = (a, i) => map10(f(a, i), (b) => array7[i] = b);
  return zipRight(forEachConcurrentDiscard(as9, fn2, batching, false, n), succeed(array7));
});
var forkDaemon = (self) => forkWithScopeOverride(self, globalScope);
var unsafeFork2 = (effect3, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect3, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect3);
  return childFiber;
};
var unsafeForkUnstarted = (effect3, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect3, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect3, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake2();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect3, some2(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var parallelFinalizers = (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self,
  onSome: (scope4) => {
    switch (scope4.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap7(scopeFork(scope4, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self,
  onSome: (scope4) => {
    if (scope4.strategy._tag === "ParallelN" && scope4.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap7(scopeFork(scope4, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope4) => {
    if (concurrentFinalizers === true) {
      const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope4.strategy._tag) {
        case "Parallel":
          return patch9(self(parallelFinalizers));
        case "Sequential":
          return patch9(self(sequentialFinalizers));
        case "ParallelN":
          return patch9(self(parallelNFinalizers(scope4.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f) => flatMap7(scopeTag, f);
var scopedWith = (f) => flatMap7(scopeMake(), (scope4) => onExit(f(scope4), (exit4) => scope4.close(exit4)));
var scopedEffect = (effect3) => flatMap7(scopeMake(), (scope4) => scopeUse(effect3, scope4));
var sequentialFinalizers = (self) => contextWithEffect((context7) => match2(getOption2(context7, scopeTag), {
  onNone: () => self,
  onSome: (scope4) => {
    switch (scope4.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap7(scopeFork(scope4, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options3) => zipWithOptions(self, that, (a, b) => [a, b], options3));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options3) => {
  if (options3?.concurrent !== true && (options3?.batching === void 0 || options3.batching === false)) {
    return zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options3);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options3) => {
  if (options3?.concurrent !== true && (options3?.batching === void 0 || options3.batching === false)) {
    return zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options3);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options3) => map10(all4([self, that], {
  concurrency: options3?.concurrent ? 2 : 1,
  batching: options3?.batching,
  concurrentFinalizers: options3?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope4, fin) => {
  if (scope4.state._tag === "Open") {
    scope4.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap7((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope4 = Object.create(ScopeImplProto);
  scope4.strategy = strategy;
  scope4.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope4;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect3, scope4) => mapInputContext(
  effect3,
  // @ts-expect-error
  merge3(make12(scopeTag, scope4))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect3, scope4) => pipe(effect3, scopeExtend(scope4), onExit((exit4) => scope4.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty23
});
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none7);
var raceWith = /* @__PURE__ */ dual(3, (self, other, options3) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options3.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options3.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options3.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options3.onOtherDone(exit4, loser);
      }
    }
  })
}));
var race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value5) => pipe(right3, interruptAsFiber(parentFiberId), as(value5))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value5) => pipe(left3, interruptAsFiber(parentFiberId), as(value5))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options3) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options3.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options3.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options3.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options3.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self, finalizer2) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer2, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer2, a)
})));
var invokeWithInterrupt = (self, entries2, onInterrupt2) => fiberIdWith((id2) => flatMap7(flatMap7(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries2.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count4) => count4 === 0)) {
      if (entries2.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f) => f());
    cb(exit4);
  });
  const cleanup = entries2.map((r, i) => {
    const observer = (count4) => {
      counts[i] = count4;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id2)));
})));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Cause.js
var empty25 = empty15;
var fail6 = fail;
var die4 = die;
var interrupt4 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map14 = map9;
var squash = causeSquash;
var reduceWithContext3 = reduceWithContext2;
var NoSuchElementException2 = NoSuchElementException;
var pretty2 = pretty;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty26 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make35 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty26;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan2 = /* @__PURE__ */ dual(2, (self, that) => min2(self, that) === self);
var min2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var isEmpty6 = (self) => {
  return self.startMillis >= self.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self, that) => {
  const start4 = Math.max(self.startMillis, that.startMillis);
  const end5 = Math.min(self.endMillis, that.endMillis);
  return make35(start4, end5);
});
var size8 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var after = (startMilliseconds) => {
  return make35(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/ScheduleInterval.js
var make36 = make35;
var empty27 = empty26;
var lessThan3 = lessThan2;
var isEmpty7 = isEmpty6;
var intersect2 = intersect;
var size9 = size8;
var after2 = after;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make37 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty3()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty7(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make37(reverse2(acc));
};
var start = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty27)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty27)).endMillis;
};
var lessThan4 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
var isNonEmpty3 = (self) => {
  return isNonEmpty(self.intervals);
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/ScheduleIntervals.js
var make38 = make37;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan5 = lessThan4;
var isNonEmpty4 = isNonEmpty3;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make38(of2(interval))
  };
};
var done4 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done5 = done4;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork = scopeFork;
var make39 = scopeMake;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var tagged2 = (tag4) => (args2) => {
  const value5 = args2 === void 0 ? Object.create(StructuralPrototype) : struct2(args2);
  value5._tag = tag4;
  return value5;
};
var taggedEnum = () => new Proxy({}, {
  get(_target, tag4, _receiver) {
    if (tag4 === "$is") {
      return isTagged;
    } else if (tag4 === "$match") {
      return taggedMatch;
    }
    return tagged2(tag4);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value6) {
      return cases2[value6._tag](value6);
    };
  }
  const value5 = arguments[0];
  const cases = arguments[1];
  return cases[value5._tag](value5);
}
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = (tag4) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag4;
    }
  };
  O.BaseEffectError.prototype.name = tag4;
  return O.BaseEffectError;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/String.js
var isString2 = isString;
var toUpperCase = (self) => self.toUpperCase();
var capitalize = (self) => {
  if (self.length === 0) return self;
  return toUpperCase(self[0]) + self.slice(1);
};
var trim = (self) => self.trim();
var isNonEmpty5 = (self) => self.length > 0;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var ScheduleImpl = class {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var ScheduleDriverImpl = class {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule2, ref) {
    this.schedule = schedule2;
    this.ref = ref;
  }
  get state() {
    return map10(get10(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap7(get10(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]);
  }
  next(input) {
    return pipe(map10(get10(this.ref), (tuple3) => tuple3[1]), flatMap7((state) => pipe(currentTimeMillis2, flatMap7((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap7(([state2, out2, decision]) => {
      const setState = set4(this.ref, [some2(out2), state2]);
      if (isDone5(decision)) {
        return zipRight(setState, fail2(none2()));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return as(setState, out2);
      }
      return pipe(setState, zipRight(sleep3(millis(millis2))), as(out2));
    }))))));
  }
};
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var addDelay = /* @__PURE__ */ dual(2, (self, f) => addDelayEffect(self, (out2) => sync(() => f(out2))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out2, duration3) => map10(f(out2), (delay2) => sum(duration3, decode(delay2)))));
var check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out2) => sync(() => test(input, out2))));
var checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out2, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out2, done5]);
  }
  return map10(test(input, out2), (cont) => cont ? [state2, out2, decision] : [state2, out2, done5]);
})));
var driver = (self) => pipe(make27([none2(), self.initial]), map10((ref) => new ScheduleDriverImpl(self, ref)));
var intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith2(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap7(([[lState, out2, lDecision], [rState, out22, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out2, lDecision.intervals, rState, out22, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out2, out22], done5]);
}))));
var intersectWithLoop = (self, that, input, lState, out2, lInterval, rState, out22, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out2, out22], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan5(rInterval))) {
    return flatMap7(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out22], done5]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out22, rInterval, f);
    });
  }
  return flatMap7(that.step(end2(rInterval), input, rState), ([rState2, out23, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out2, out23], done5]);
    }
    return intersectWithLoop(self, that, input, lState, out2, lInterval, rState2, out23, decision.intervals, f);
  });
};
var map15 = /* @__PURE__ */ dual(2, (self, f) => mapEffect(self, (out2) => sync(() => f(out2))));
var mapEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out2, decision]) => map10(f(out2), (out22) => [state2, out22, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap7(self.step(now, input, state), ([state2, out2, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out2, decision]);
  }
  const intervals = decision.intervals;
  const delay2 = size9(make36(now, start2(intervals)));
  return map10(f(out2, delay2), (durationInput) => {
    const duration3 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration3);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make36(newStart, newEnd);
    return [state2, out2, continueWith2(newInterval)];
  });
})));
var passthrough = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map10(([state2, _, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out2) => out2 < n);
var spaced = (duration3) => addDelay(forever2, () => duration3);
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out2) => f(out2)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId];
  constructor(error4) {
    this.error = error4;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefail = (self) => catchAllCause(self, (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => failCause(cause2),
  onSome: (error4) => fail2(error4.error)
}));
var repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule2) => repeatOrElse_Effect(self, schedule2, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self, options3) => {
  if (isSchedule(options3)) {
    return repeat_Effect(self, options3);
  }
  const base = options3.schedule ?? passthrough(forever2);
  const withWhile = options3.while ? whileInputEffect(base, (a) => {
    const applied = options3.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options3.until ? untilInputEffect(withWhile, (a) => {
    const applied = options3.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options3.times ? intersect5(withUntil, recurs(options3.times)).pipe(map15((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule2, orElse14) => flatMap7(driver(schedule2), (driver2) => matchEffect(self, {
  onFailure: (error4) => orElse14(error4, none2()),
  onSuccess: (value5) => repeatOrElseEffectLoop(self, driver2, orElse14, value5)
})));
var repeatOrElseEffectLoop = (self, driver2, orElse14, value5) => {
  return matchEffect(driver2.next(value5), {
    onFailure: () => orDie(driver2.last),
    onSuccess: (b) => matchEffect(self, {
      onFailure: (error4) => orElse14(error4, some2(b)),
      onSuccess: (value6) => repeatOrElseEffectLoop(self, driver2, orElse14, value6)
    })
  });
};
var retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self, options3) => {
  if (isSchedule(options3)) {
    return retry_Effect(self, options3);
  }
  const base = options3.schedule ?? forever2;
  const withWhile = options3.while ? whileInputEffect(base, (e) => {
    const applied = options3.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options3.until ? untilInputEffect(withWhile, (e) => {
    const applied = options3.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options3.times ? intersect5(withUntil, recurs(options3.times)) : withUntil;
  return scheduleDefectRefail(retry_Effect(self, withTimes));
});
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse14) => flatMap7(driver(policy), (driver2) => retryOrElse_EffectLoop(self, driver2, orElse14)));
var retryOrElse_EffectLoop = (self, driver2, orElse14) => {
  return catchAll(self, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap7((out2) => orElse14(e, out2))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver2, orElse14)
  }));
};
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap7(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits))));
  withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self)), this.release(n));
  }));
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var forkIn = /* @__PURE__ */ dual(2, (self, scope4) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope4;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer2 = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer2);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self) => scopeWith((scope4) => forkIn(self, scope4));
var timeout = /* @__PURE__ */ dual(2, (self, duration3) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration3),
  duration: duration3
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self, {
  duration: duration3,
  onTimeout
}) => flatten3(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration3
})));
var timeoutTo = /* @__PURE__ */ dual(2, (self, {
  duration: duration3,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration3)), {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var SynchronizedImpl = class extends Class2 {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId10] = TypeId10;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get10(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap7(get10(this.ref), f), flatMap7(([b, a]) => as(set4(this.ref, a), b))));
  }
};
var makeSynchronized = (value5) => sync(() => unsafeMakeSynchronized(value5));
var unsafeMakeSynchronized = (value5) => {
  const ref = unsafeMake4(value5);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Fiber.js
var _await3 = _await2;
var inheritAll2 = inheritAll;
var interrupt5 = interruptFiber;
var interruptAs = interruptAsFiber;
var interruptAllAs2 = interruptAllAs;
var join3 = join2;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime5 = arguments[0];
    return (effect3, ...args2) => f(runtime5, effect3, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime5, self, options3) => {
  const fiberId2 = unsafeMake2();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime5.context]]]];
  if (options3?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options3.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime5.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options3?.updateRefs) {
    fiberRefs3 = options3.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime5.runtimeFlags);
  let effect3 = self;
  if (options3?.scope) {
    effect3 = flatMap7(fork(options3.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none7) {
    supervisor.onStart(runtime5.context, effect3, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime5.runtimeFlags, fiberRuntime);
  if (options3?.immediate === false) {
    fiberRuntime.resume(effect3);
  } else {
    fiberRuntime.start(effect3);
  }
  return fiberRuntime;
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime5, effect3) => {
  const result = unsafeRunSyncExit(runtime5)(effect3);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error4;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head5 = prettyErrors(cause2)[0];
    super(head5?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head5 ? `(FiberFailure) ${head5.name}` : "FiberFailure";
    if (head5?.stack) {
      this.stack = head5.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error4;
};
var fastPath = (effect3) => {
  const op = effect3;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime5, effect3) => {
  const op = fastPath(effect3);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime5)(effect3, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime5, effect3, options3) => new Promise((resolve3) => {
  const op = fastPath(effect3);
  if (op) {
    resolve3(op);
  }
  const fiber = unsafeFork3(runtime5)(effect3);
  fiber.addObserver((exit4) => {
    resolve3(exit4);
  });
  if (options3?.signal !== void 0) {
    if (options3.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options3.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context7, runtimeFlags2, fiberRefs3) {
    this.context = context7;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make40 = (options3) => new RuntimeImpl(options3.context, options3.runtimeFlags, options3.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make19(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make40({
  context: /* @__PURE__ */ empty8(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty18()
});
var updateContext2 = /* @__PURE__ */ dual(2, (self, f) => make40({
  context: f(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}));
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));
var updateEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect((value5) => map10(f(value5), (result) => [void 0, result])));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto5 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer14, scope4) {
    return pipe(modifyEffect(this.ref, (map33) => {
      const inMap = map33.get(layer14);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached3 = pipe(acquire, flatMap7(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope4, release)
        })));
        return succeed([cached3, map33]);
      }
      return pipe(make27(0), flatMap7((observers) => pipe(deferredMake(), flatMap7((deferred) => pipe(make27(() => void_), map10((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap7((innerScope) => pipe(restore(flatMap7(makeBuilder(layer14, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap7((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight(scopeClose(innerScope, exit4)), zipRight(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify2(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope4, (exit5) => pipe(sync(() => map33.delete(layer14)), zipRight(get10(finalizerRef)), flatMap7((finalizer2) => finalizer2(exit5))))), zipRight(deferredSucceed(deferred, exit4.effect_instruction_i0)), as(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit4) => pipe(get10(finalizerRef), flatMap7((finalizer2) => finalizer2(exit4)))];
        return [resource, isFresh(layer14) ? map33 : map33.set(layer14, memoized)];
      }))))));
    }), flatten3);
  }
};
var makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var buildWithScope = /* @__PURE__ */ dual(2, (self, scope4) => flatMap7(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope4)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope4) => flatMap7(makeBuilder(self, scope4), (run10) => provideService(run10(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope4, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope4)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope5) => memoMap.getOrElseMemoize(op.layer, scope5)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope4), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope4),
        onSuccess: (value5) => memoMap.getOrElseMemoize(op.successK(value5), scope4)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope4)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope4));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope4), flatMap7((env2) => pipe(memoMap.getOrElseMemoize(op.second, scope4), provideContext(env2)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope4)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope4));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope4));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope4), zipWith2(memoMap.getOrElseMemoize(op.second, scope4), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope4), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope4), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var context2 = () => fromEffectContext(context());
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const effect3 = tagFirst ? b : a;
  return fromEffectContext(map10(effect3, (service2) => make12(tag4, service2)));
});
function fromEffectContext(effect3) {
  const fromEffect8 = Object.create(proto5);
  fromEffect8._op_layer = OP_FROM_EFFECT;
  fromEffect8.effect = effect3;
  return fromEffect8;
}
var merge5 = /* @__PURE__ */ dual(2, (self, that) => zipWith4(self, that, (a, b) => merge3(a, b)));
var mergeAll2 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge5(final, layers[i]);
  }
  return final;
};
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const effect3 = tagFirst ? b : a;
  return scopedContext(map10(effect3, (service2) => make12(tag4, service2)));
});
var scopedContext = (effect3) => {
  const scoped6 = Object.create(proto5);
  scoped6._op_layer = OP_SCOPED;
  scoped6.effect = effect3;
  return scoped6;
};
var succeed7 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make12(tag4, resource)));
});
var suspend4 = (evaluate2) => {
  const suspend11 = Object.create(proto5);
  suspend11._op_layer = OP_SUSPEND;
  suspend11.evaluate = evaluate2;
  return suspend11;
};
var sync4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const evaluate2 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make12(tag4, evaluate2())));
});
var provide = /* @__PURE__ */ dual(2, (self, that) => suspend4(() => {
  const provideTo = Object.create(proto5);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto5, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll2(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
  const zipWith10 = Object.create(proto5);
  zipWith10._op_layer = OP_PROVIDE_MERGE;
  zipWith10.first = self;
  zipWith10.second = provide(that, self);
  zipWith10.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith10;
});
var zipWith4 = /* @__PURE__ */ dual(3, (self, that, f) => suspend4(() => {
  const zipWith10 = Object.create(proto5);
  zipWith10._op_layer = OP_ZIP_WITH2;
  zipWith10.first = self;
  zipWith10.second = that;
  zipWith10.zipK = f;
  return zipWith10;
}));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer14) => scopedWith((scope4) => flatMap7(buildWithScope(layer14, scope4), (context7) => provideSomeContext(self, context7))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll2(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId13 in source) {
    return flatMap7(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/console.js
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get5(services, consoleTag)));
var error = (...args2) => consoleWith((_) => _.error(...args2));
var log = (...args2) => consoleWith((_) => _.log(...args2));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Console.js
var error2 = error;
var log2 = log;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/MutableList.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId14]: TypeId14,
  [Symbol.iterator]() {
    let done8 = false;
    let head5 = this.head;
    return {
      next() {
        if (done8) {
          return this.return();
        }
        if (head5 == null) {
          done8 = true;
          return this.return();
        }
        const value5 = head5.value;
        head5 = head5.next;
        return {
          done: done8,
          value: value5
        };
      },
      return(value5) {
        if (!done8) {
          done8 = true;
        }
        return {
          done: true,
          value: value5
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value5) => ({
  value: value5,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty29 = () => {
  const list4 = Object.create(MutableListProto);
  list4.head = void 0;
  list4.tail = void 0;
  list4._length = 0;
  return list4;
};
var isEmpty8 = (self) => length(self) === 0;
var length = (self) => self._length;
var append3 = /* @__PURE__ */ dual(2, (self, value5) => {
  const node = makeNode(value5);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head5 = self.head;
  if (head5 !== void 0) {
    remove6(self, head5);
    return head5.value;
  }
  return void 0;
};
var remove6 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    self._length -= 1;
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/MutableQueue.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId15]: TypeId15,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make41 = (capacity3) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty29();
  queue.capacity = capacity3;
  return queue;
};
var bounded = (capacity3) => make41(capacity3);
var unbounded = () => make41(void 0);
var length2 = (self) => length(self.queue);
var isEmpty9 = (self) => isEmpty8(self.queue);
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = /* @__PURE__ */ dual(2, (self, value5) => {
  const queueLength = length(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append3(value5)(self.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self, values3) => {
  const iterator = values3[Symbol.iterator]();
  let next;
  let remainder2 = empty3();
  let offering = true;
  while (offering && (next = iterator.next()) && !next.done) {
    offering = offer(next.value)(self);
  }
  while (next != null && !next.done) {
    remainder2 = prepend2(next.value)(remainder2);
    next = iterator.next();
  }
  return reverse2(remainder2);
});
var poll2 = /* @__PURE__ */ dual(2, (self, def) => {
  if (isEmpty8(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self, n) => {
  let result = empty3();
  let count4 = 0;
  while (count4 < n) {
    const element = poll2(EmptyMutableQueue)(self);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count4 += 1;
  }
  return reverse2(result);
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Effect.js
var isEffect2 = isEffect;
var all5 = all4;
var filter8 = filter6;
var forEach8 = forEach7;
var async2 = async_;
var withFiberRuntime2 = withFiberRuntime;
var fail8 = fail2;
var failSync2 = failSync;
var failCause6 = failCause;
var die5 = die2;
var dieMessage2 = dieMessage;
var gen2 = gen;
var succeed8 = succeed;
var suspend5 = suspend;
var sync5 = sync;
var _void = void_;
var catchAll2 = catchAll;
var catchAllCause2 = catchAllCause;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var ignore2 = ignore;
var retry = retry_combined;
var try_2 = try_;
var tryMap2 = tryMap;
var tryPromise2 = tryPromise;
var interrupt6 = interrupt2;
var interruptible4 = interruptible2;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var as4 = as;
var asVoid2 = asVoid;
var map17 = map10;
var mapBoth4 = mapBoth2;
var mapError2 = mapError;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var scope2 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var fiberIdWith2 = fiberIdWith;
var forkDaemon2 = forkDaemon;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var timeout2 = timeout;
var contextWithEffect2 = contextWithEffect;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceOption2 = serviceOption;
var either3 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var filterOrDieMessage2 = filterOrDieMessage;
var unlessEffect2 = unlessEffect;
var when2 = when;
var flatMap9 = flatMap7;
var flatten5 = flatten3;
var race2 = race;
var raceWith2 = raceWith;
var tap2 = tap;
var tapErrorCause2 = tapErrorCause;
var repeat2 = repeat_combined;
var repeatN2 = repeatN;
var match11 = match8;
var matchCause3 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var logWarning2 = logWarning;
var logError2 = logError;
var annotateLogs2 = annotateLogs;
var orDie2 = orDie;
var orElse5 = orElse2;
var orElseFail2 = orElseFail;
var runtime4 = runtime3;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var runFork2 = unsafeForkEffect;
var runSync = unsafeRunSyncEffect;
var zip6 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight3 = zipRightOptions;
var zipWith5 = zipWithOptions;
var withSpan2 = withSpan;
var makeTagProxy = (TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = (...args2) => andThen2(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen2(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen2(target, (s) => s[prop]);
      Object.assign(fn2, cn);
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(cn));
      cache.set(prop, fn2);
      return fn2;
    }
  });
};
var Tag3 = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen2(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  const name2 = nameOrBody;
  const options3 = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name2](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name2,
        spanOptions: options3,
        errorDef,
        errorCall
      });
    }
  }[name2]);
};
function defineLength(length3, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length3,
    configurable: true
  });
}
function fnApply(options3) {
  let effect3;
  let fnError = void 0;
  if (isGeneratorFunction(options3.body)) {
    effect3 = fromIterator(() => options3.body.apply(options3.self, options3.args));
  } else {
    try {
      effect3 = options3.body.apply(options3.self, options3.args);
    } catch (error4) {
      fnError = error4;
      effect3 = die5(error4);
    }
  }
  if (options3.pipeables.length > 0) {
    try {
      for (const x of options3.pipeables) {
        effect3 = x(effect3, ...options3.args);
      }
    } catch (error4) {
      effect3 = fnError ? failCause6(sequential(die(fnError), die(error4))) : die5(error4);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options3.errorCall.stack) {
      const stackDef = options3.errorDef.stack.trim().split("\n");
      const stackCall = options3.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options3.spanOptions && "captureStackTrace" in options3.spanOptions ? options3.spanOptions : {
    captureStackTrace,
    ...options3.spanOptions
  };
  return withSpan2(effect3, options3.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk = (f) => {
  let done8 = false;
  let a;
  return () => {
    if (done8) {
      return a;
    }
    a = f();
    done8 = true;
    return a;
  };
};
var formatDate = (date5) => {
  try {
    return date5.toISOString();
  } catch {
    return String(date5);
  }
};
var formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name2 = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name2}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name2) => typeof name2 === "string" ? JSON.stringify(name2) : String(name2);
var isNonEmpty6 = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path2) => isNonEmpty6(path2) ? path2.map(formatPathKey).join("") : formatPathKey(path2);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path2, ast) => {
  let out2 = reason;
  if (path2 && isNonEmptyReadonlyArray(path2)) {
    out2 += `
at path: ${formatPath(path2)}`;
  }
  if (details !== void 0) {
    out2 += `
details: ${details}`;
  }
  if (ast) {
    out2 += `
schema (${ast._tag}): ${ast}`;
  }
  return out2;
};
var getSchemaExtendErrorMessage = (x, y, path2) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path2);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteralErrorMessage = (literal2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type2) => getErrorMessage("Duplicate index signature", `${type2} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var Declaration = class {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown3, encodeUnknown2, annotations2 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown3;
    this.encodeUnknown = encodeUnknown2;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = (tag4) => (ast) => ast._tag === tag4;
var Literal = class {
  literal;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Literal";
  constructor(literal2, annotations2 = {}) {
    this.literal = literal2;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var UniqueSymbol = class {
  symbol;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations2 = {}) {
    this.symbol = symbol3;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var NeverKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NeverKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var UnknownKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var AnyKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "AnyKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var StringKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "StringKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
var NumberKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NumberKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
var Type = class {
  type;
  annotations;
  constructor(type2, annotations2 = {}) {
    this.type = type2;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  isOptional;
  constructor(type2, isOptional, annotations2 = {}) {
    super(type2, annotations2);
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations2 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations2;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head5, tail) => {
      const formattedHead = String(head5);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var PropertySignature = class extends OptionalType {
  name;
  isReadonly;
  constructor(name2, type2, isOptional, isReadonly, annotations2) {
    super(type2, isOptional, annotations2);
    this.name = name2;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
var IndexSignature = class {
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type2, isReadonly) {
    this.type = type2;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations2 = {}) {
    this.annotations = annotations2;
    const keys5 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name2 = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys5, name2)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name2));
      }
      keys5[name2] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten6 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten6(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out2 = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out2.push(ast);
        }
        break;
      }
      case "Literal": {
        const type2 = typeof ast.literal;
        switch (type2) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type2];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out2.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out2.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out2.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out2.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out2.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out2.push(ast);
        }
        break;
      }
      default:
        out2.push(ast);
    }
  }
  return out2;
};
var Union = class _Union {
  types;
  annotations;
  static make = (types, annotations2) => {
    return isMembers(types) ? new _Union(types, annotations2) : types.length === 1 ? types[0] : neverKeyword;
  };
  /** @internal */
  static unify = (candidates, annotations2) => {
    return _Union.make(unify(flatten6(candidates)), annotations2);
  };
  /**
   * @since 3.10.0
   */
  _tag = "Union";
  constructor(types, annotations2 = {}) {
    this.types = types;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var mapMembers = (members, f) => members.map(f);
var isMembers = (as9) => as9.length > 1;
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  f;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Suspend";
  constructor(f, annotations2 = {}) {
    this.f = f;
    this.annotations = annotations2;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out2 = toJSONMemoMap.get(ast);
    if (out2) {
      return out2;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out2 = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out2);
    return out2;
  }
};
var Refinement = class {
  from;
  filter;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(from, filter11, annotations2 = {}) {
    this.from = from;
    this.filter = filter11;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations2 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations2;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");
var FinalTransformation = class {
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "FinalTransformation";
  constructor(decode2, encode) {
    this.decode = decode2;
    this.encode = encode;
  }
};
var createTransformationGuard = (tag4) => (ast) => ast._tag === tag4;
var ComposeTransformation = class {
  /**
   * @since 3.10.0
   */
  _tag = "ComposeTransformation";
};
var composeTransformation = /* @__PURE__ */ new ComposeTransformation();
var PropertySignatureTransformation = class {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode2, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode2;
    this.encode = encode;
  }
};
var TypeLiteralTransformation = class {
  propertySignatureTransformations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value5 = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value5[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value5;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type2, capture2) => {
  switch (type2._tag) {
    case "Literal":
      return escape(String(type2.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type2);
    case "Union":
      return type2.types.map((type3) => getTemplateLiteralSpanTypePattern(type3)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type2, s, capture2, top) => {
  if (isUnion(type2)) ; else {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head5 = escape(ast.head);
    pattern2 += head5;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type);
    pattern2 += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern);
    if (span2.literal !== "") {
      const literal2 = escape(span2.literal);
      pattern2 += literal2;
    }
  }
  return pattern2;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast)}$`);
var record = (key, value5) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go2 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value5, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value5, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name2] of key2.enums) {
          propertySignatures.push(new PropertySignature(name2, value5, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value5, false, true));
        break;
      case "Union":
        key2.types.forEach(go2);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go2(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out2 = void 0;
  for (const id2 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
      if (out2 === void 0) {
        out2 = {};
      }
      out2[id2] = annotated.annotations[id2];
    }
  }
  return out2;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out2 = {
    ...annotated.annotations
  };
  for (const id2 of annotationIds) {
    delete out2[id2];
  }
  return out2;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type2 = typeAST(e.type);
        return type2 === e.type ? e : new OptionalType(type2, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type2) => new Type(type2)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p2) => {
        const type2 = typeAST(p2.type);
        return type2 === p2.type ? p2 : new PropertySignature(p2.name, type2, p2.isOptional, p2.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
        const type2 = typeAST(is3.type);
        return type2 === is3.type ? is3 : new IndexSignature(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => void 0,
  onSome: (identifier3) => ({
    [JSONIdentifierAnnotationId]: identifier3
  })
});
function changeMap(as9, f) {
  let changed = false;
  const out2 = allocate(as9.length);
  for (let i = 0; i < as9.length; i++) {
    const a = as9[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out2[i] = fa;
  }
  return changed ? out2 : as9;
}
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type2 = encodedAST_(e.type);
        return type2 === e.type ? e : new OptionalType(type2, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type2 = encodedAST_(ps.type);
        return type2 === ps.type ? ps : new PropertySignature(ps.name, type2, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
        const type2 = encodedAST_(is3.type);
        return type2 === is3.type ? is3 : new IndexSignature(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2));
      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f()), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from);
      const identifier3 = createJSONIdentifierAnnotation(ast);
      return identifier3 ? annotations(from, identifier3) : from;
    }
    case "Transformation": {
      const identifier3 = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier3 ? annotations(ast.from, identifier3) : ast.from);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast);
var toJSONAnnotations = (annotations2) => {
  const out2 = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out2[String(k)] = annotations2[k];
  }
  return out2;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/ParseResult.js
var Pointer = class {
  path;
  actual;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Pointer";
  constructor(path2, actual, issue) {
    this.path = path2;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = void 0;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
var Refinement2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var ParseError = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
  /**
   * @since 3.10.0
   */
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var parseError = (issue) => new ParseError({
  issue
});
var succeed9 = right2;
var fail9 = left2;
var fromOption3 = fromOption2;
var isEither3 = isEither2;
var flatMap10 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? match(self, {
    onLeft: left2,
    onRight: f
  }) : flatMap9(self, f);
});
var map18 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? map(self, f) : map17(self, f);
});
var mapError3 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? mapLeft(self, f) : mapError2(self, f);
});
var mapBoth5 = /* @__PURE__ */ dual(2, (self, options3) => {
  return isEither3(self) ? mapBoth(self, {
    onLeft: options3.onFailure,
    onRight: options3.onSuccess
  }) : mapBoth4(self, options3);
});
var orElse6 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither3(self) ? match(self, {
    onLeft: f,
    onRight: right2
  }) : catchAll2(self, f);
});
var mergeInternalOptions = (options3, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options3;
  }
  if (options3 === void 0) {
    return overrideOptions;
  }
  return {
    ...options3,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options3) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options3, overrideOptions));
};
var getSync = (ast, isDecoding, options3) => {
  const parser = getEither(ast, isDecoding, options3);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getEffect = (ast, isDecoding, options3) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options3, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options3) => getSync(schema.ast, true, options3);
var decodeUnknown = (schema, options3) => getEffect(schema.ast, true, options3);
var encodeUnknownSync = (schema, options3) => getSync(schema.ast, false, options3);
var encodeUnknown = (schema, options3) => getEffect(schema.ast, false, options3);
var decodeSync = decodeUnknownSync;
var validateSync = (schema, options3) => getSync(typeAST(schema.ast), true, options3);
var is = (schema, options3) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options3, overrideOptions)
  }));
};
var encodeSync = encodeUnknownSync;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options3) => raw(i, mergeInternalOptions(options3, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options3) => handleForbidden(orElse6(parserWithOptions(i, options3), decodingFallbackAnnotation.value), ast, i, options3) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options3) => {
          options3 = options3 ?? defaultParseOption;
          const allErrors = options3?.errors === "all";
          const result = flatMap10(orElse6(from(i, options3), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options3, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options3, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options3);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options3) => handleForbidden(flatMap10(from(i, options3), (a) => to(a, options3)), ast, i, options3);
      }
    }
    case "Transformation": {
      const transform3 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options3) => handleForbidden(flatMap10(mapError3(from(i, options3), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap10(mapError3(transform3(a, options3 ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError3(to(i2, options3), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options3);
    }
    case "Declaration": {
      const parse8 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options3) => handleForbidden(parse8(i, options3 ?? defaultParseOption, ast), ast, i, options3);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value5]) => value5 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options3) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options3);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head5, ...tail] = rest;
          for (; i < len - tail.length; i++) {
            const te = head5(input[i], options3);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap9(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options3);
              if (isEither3(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend5(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is3) => [goMemo(is3.parameter, isDecoding), goMemo(is3.type, isDecoding), is3.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is3) => is3.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options3) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options3?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options3?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options3?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options3);
            if (isEither3(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options3?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name2 = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name2);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name2, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name2], options3);
          if (isEither3(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name2, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name2] = te.right;
          } else {
            const nk = stepKey++;
            const index = name2;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap9(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type2 = indexSignature[1];
          const keys5 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys5) {
            const keu = parameter(key, options3);
            if (isEither3(keu) && isRight2(keu)) {
              const vpr = type2(input[key], options3);
              if (isEither3(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap9(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options3?.propertyOrder === "original") {
            const keys5 = inputKeys || ownKeys(input);
            for (const name2 of expectedKeys) {
              if (keys5.indexOf(name2) === -1) {
                keys5.push(name2);
              }
            }
            const out2 = {};
            for (const key of keys5) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out2[key] = output2[key];
              }
            }
            return right2(out2);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend5(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map33 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map33.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options3) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name2 = ownKeys2[i];
              const buckets = searchTree.keys[name2].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name2)) {
                const literal2 = String(input[name2]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name2];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name2, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name2, input, new Type2(literalsUnion, input[name2])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name2];
                const fakePropertySignature = new PropertySignature(name2, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name2, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map33.get(candidate)(input, options3);
          if (isEither3(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend5(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap9(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend5(() => {
            const state = {
              es: copy(es)
            };
            return flatMap9(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get14 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options3) => get14()(a, options3);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out2 = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type2 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type2) && !propertySignature2.isOptional) {
          out2.push([propertySignature2.name, type2]);
        }
      }
      return out2;
    }
    case "TupleType": {
      const out2 = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type2 = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type2) && !element.isOptional) {
          out2.push([i, type2]);
        }
      }
      return out2;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys5 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags2 = getLiterals(member, isDecoding);
    if (tags2.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags2.length; j++) {
        const [key, literal2] = tags2[j];
        const hash2 = String(literal2.literal);
        keys5[key] = keys5[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys5[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags2.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys5,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect3, ast, actual, options3) => {
  if (options3?.isEffectAllowed === true) {
    return effect3;
  }
  if (isEither3(effect3)) {
    return effect3;
  }
  const scheduler = new SyncScheduler();
  const fiber = runFork2(effect3, {
    scheduler
  });
  scheduler.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess(exit4)) {
      return right2(exit4.value);
    }
    const cause2 = exit4.cause;
    if (isFailType2(cause2)) {
      return left2(cause2.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause2)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out2 = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out2 = map18(out2, f);
        }
        return out2;
      };
  }
};
var makeTree = (value5, forest = []) => ({
  value: value5,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map18(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error4) => TreeFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => TreeFormatter.formatIssueSync(error4.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => "ast" in issue ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union11 = messageAnnotation(issue);
    if (isString(union11)) {
      return right2({
        message: union11,
        override: false
      });
    }
    if (isEffect2(union11)) {
      return map17(union11, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union11.message)) {
      return right2({
        message: union11.message,
        override: union11.override
      });
    }
    return map17(union11.message, (message) => ({
      message,
      override: union11.override
    }));
  }
}));
var createParseIssueGuard = (tag4) => (issue) => issue._tag === tag4;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap10(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map18(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map18(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map18(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map18(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map18(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map18(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap10(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty6(issue.issues) ? map18(forEach8(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map18(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/layer/circular.js
var withMinimumLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Layer.js
var effect = fromEffect3;
var merge7 = merge5;
var mergeAll4 = mergeAll2;
var scoped3 = scoped;
var succeed10 = succeed7;
var sync6 = sync4;
var provide3 = provide;
var provideMerge2 = provideMerge;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/cliConfig.js
var make42 = (params) => ({
  ...defaultConfig,
  ...params
});
var Tag4 = /* @__PURE__ */ GenericTag("@effect/cli/CliConfig");
var defaultConfig = {
  isCaseSensitive: false,
  autoCorrectLimit: 2,
  finalCheckBuiltIn: false,
  showAllNames: true,
  showBuiltIns: true,
  showTypes: true
};
var layer = (config2) => succeed10(Tag4, make42(config2));
var normalizeCase = /* @__PURE__ */ dual(2, (self, text9) => self.isCaseSensitive ? text9 : text9.toLowerCase());

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/autoCorrect.js
var levensteinDistance = (first3, second, config2) => {
  if (first3.length === 0 && second.length === 0) {
    return 0;
  }
  if (first3.length === 0) {
    return second.length;
  }
  if (second.length === 0) {
    return first3.length;
  }
  const rowCount = first3.length;
  const columnCount = second.length;
  const matrix = new Array(rowCount);
  const normalFirst = normalizeCase(config2, first3);
  const normalSecond = normalizeCase(config2, second);
  for (let x = 0; x <= rowCount; x++) {
    matrix[x] = new Array(columnCount);
    matrix[x][0] = x;
  }
  for (let y = 0; y <= columnCount; y++) {
    matrix[0][y] = y;
  }
  for (let row = 1; row <= rowCount; row++) {
    for (let col = 1; col <= columnCount; col++) {
      const cost = normalFirst.charAt(row - 1) === normalSecond.charAt(col - 1) ? 0 : 1;
      matrix[row][col] = Math.min(matrix[row][col - 1] + 1, Math.min(matrix[row - 1][col] + 1, matrix[row - 1][col - 1] + cost));
    }
  }
  return matrix[rowCount][columnCount];
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Brand.js
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var nominal = () => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some2(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/FiberRef.js
var currentContext2 = currentContext;
var currentLoggers2 = currentLoggers;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var QueueImpl = class extends Class2 {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map10(this.size, (size13) => size13 <= 0);
  }
  get isFull() {
    return map10(this.size, (size13) => size13 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value5) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value5);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value5);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value5) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value5);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value5);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value5], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values3 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty2;
      const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      });
    });
  }
  takeUpTo(max6) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values3 = this.queue.pollUpTo(max6);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values3);
    }));
  }
  takeBetween(min4, max6) {
    return suspend(() => takeRemainderLoop(this, min4, max6, empty3()));
  }
};
var takeRemainderLoop = (self, min4, max6, acc) => {
  if (max6 < min4) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max6), flatMap7((bs) => {
    const remaining = min4 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self), flatMap7((b) => takeRemainderLoop(self, remaining - 1, max6 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make43(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap7((queue) => make43(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap7((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake7 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make43 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake7(queue, unbounded(), deferred, make13(false), strategy)));
var BackingQueueFromMutableQueue = class {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable2) {
    this.mutable = mutable2;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable2) => new BackingQueueFromMutableQueue(mutable2);
var size10 = (self) => self.size;
var shutdown = (self) => self.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self, value5) => self.offer(value5));
var take2 = (self) => self.take;
var takeUpTo = /* @__PURE__ */ dual(2, (self, max6) => self.takeUpTo(max6));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var BackPressureStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty9(this.putters) && !isEmpty9(takers)) {
      const taker = poll2(takers, void 0);
      const putter = poll2(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap7((fiberId2) => pipe(sync(() => unsafePollAll(this.putters)), flatMap7((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId2), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown3) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown3) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value5 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value5, deferred, true]));
      } else {
        pipe(this.putters, offer([value5, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
  }
};
var DroppingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var SlidingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as9) => {
  return pipe(queue, offerAll(as9));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max6) => {
  return pipe(queue, pollUpTo(max6));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty9(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Queue.js
var bounded3 = bounded2;
var dropping2 = dropping;
var sliding2 = sliding;
var unbounded3 = unbounded2;
var size11 = size10;
var shutdown2 = shutdown;
var offer3 = offer2;
var take3 = take2;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto6 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto6);
  op._tag = OP_CONTINUE2;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var ContinuationKImpl = class {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var ContinuationFinalizerImpl = class {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer2) {
    this.finalizer = finalizer2;
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto7 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto7);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto8 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self, release) => {
  const op = Object.create(proto8);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release;
  return op;
});
var collectElements = (self) => {
  return suspend6(() => {
    const builder = [];
    return flatMap12(pipeTo(self, collectElementsReader(builder)), (value5) => sync7(() => [fromIterable2(builder), value5]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap12(sync7(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail11,
  onDone: succeedNow
});
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self, f, g, h) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self, input) => {
  const op = Object.create(proto8);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self, finalizer2) => {
  const op = Object.create(proto8);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer2;
  return op;
});
var fail11 = (error4) => failCause8(fail6(error4));
var failCause8 = (cause2) => failCauseSync3(() => cause2);
var failCauseSync3 = (evaluate2) => {
  const op = Object.create(proto8);
  op._tag = OP_FAIL3;
  op.error = evaluate2;
  return op;
};
var flatMap12 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f, failCause8);
  return op;
});
var fromEffect4 = (effect3) => {
  const op = Object.create(proto8);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect3;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto8);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var readWith = (options3) => readWithCause({
  onInput: options3.onInput,
  onFailure: (cause2) => match(failureOrCause2(cause2), {
    onLeft: options3.onFailure,
    onRight: failCause8
  }),
  onDone: options3.onDone
});
var readWithCause = (options3) => {
  const op = Object.create(proto8);
  op._tag = OP_READ;
  op.more = options3.onInput;
  op.done = new ContinuationKImpl(options3.onDone, options3.onFailure);
  return op;
};
var succeed11 = (value5) => sync7(() => value5);
var succeedNow = (result) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend6 = (evaluate2) => {
  const op = Object.create(proto8);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate2;
  return op;
};
var sync7 = (evaluate2) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate2;
  return op;
};
var void_5 = /* @__PURE__ */ succeedNow(void 0);
var write = (out2) => {
  const op = Object.create(proto8);
  op._tag = OP_EMIT;
  op.out = out2;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto9 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto9);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto9);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect3) => {
  const op = Object.create(proto9);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect3;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone2) => {
  const op = Object.create(proto9);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone2;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : void 0;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith5(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith5(acc, exit3(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== void 0 && next !== void 0) {
        return zipWith5(acc, exit3(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next !== void 0) {
        return exit3(next);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value5, next) {
    this.value = value5;
    this.next = next;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto10 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value5) => {
  const op = Object.create(proto10);
  op._tag = OP_PULLED;
  op.value = value5;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto10);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap9(bridgeInput.awaitRead(), () => suspend5(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: (value5) => bridgeInput.done(value5)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap9(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause2) => bridgeInput.error(cause2),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause2) => bridgeInput.error(cause2));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap9(forkDaemon2(interruptible4(drainer())), (fiber) => sync5(() => this.addFinalizer((exit4) => flatMap9(interrupt5(fiber), () => suspend5(() => {
                    const effect3 = this.restorePipe(exit4, inputExecutor);
                    return effect3 !== void 0 ? effect3 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync5(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value5) => channel.k(value5), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request) => channel.onPull(request), (value5) => channel.onEmit(value5));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_5;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect3 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect3, {
                  onFailure: (cause2) => {
                    const state = this.doneHalt(cause2);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value5) => {
                    const state = this.doneSucceed(value5);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect3 = this.restorePipe(exit4, previousInput);
                  return effect3 !== void 0 ? effect3 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync5(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read4 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read4.more(emitted);
                  } catch (error4) {
                    this._currentChannel = read4.done.onExit(die3(error4));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit3 = (exit5) => {
                    return read4.done.onExit(exit5);
                  };
                  this._currentChannel = onExit3(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause8(die4(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer2) {
    this._inProgressFinalizer = finalizer2;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next = this._doneStack.pop();
    while (next) {
      if (next._tag === "ContinuationFinalizer") {
        finalizers.push(next.finalizer);
      }
      next = this._doneStack.pop();
    }
    const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect3);
    return effect3;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect3 = currInput.close(exit4);
      return effect3;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer2 = this._inProgressFinalizer;
    if (finalizer2 !== void 0) {
      runInProgressFinalizers = pipe(finalizer2, ensuring2(sync5(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync5(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip6(exit3(ifNotNull(runInProgressFinalizers))),
      zip6(exit3(ifNotNull(closeSelf))),
      map17(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap9((exit5) => suspend5(() => exit5))
    );
  }
  doneSucceed(value5) {
    if (this._doneStack.length === 0) {
      this._done = succeed5(value5);
      this._currentChannel = void 0;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head5.onSuccess(value5);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed5(value5);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed5(value5));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap9(() => sync5(() => this.doneSucceed(value5))));
    return fromEffect5(effect3);
  }
  doneHalt(cause2) {
    if (this._doneStack.length === 0) {
      this._done = failCause4(cause2);
      this._currentChannel = void 0;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head5.onHalt(cause2);
      } catch (error4) {
        this._currentChannel = failCause8(die4(error4));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause4(cause2);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause4(cause2));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap9(() => sync5(() => this.doneHalt(cause2))));
    return fromEffect5(effect3);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause2) => sync5(() => {
        this._currentChannel = failCause8(cause2);
      }),
      onSuccess: (out2) => sync5(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out2, exit4)));
        this._currentChannel = write(out2);
      })
    }));
    return fromEffect5(effect3);
  }
  provide(effect3) {
    if (this._providedEnv === void 0) {
      return effect3;
    }
    return pipe(effect3, provide2(this._providedEnv));
  }
  runEnsuring(ensuring7) {
    this.addFinalizer(ensuring7.finalizer);
    this._currentChannel = ensuring7.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match9(exit4, {
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value5) => this.doneSucceed(value5)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach8((closeFunc) => pipe(sync5(() => closeFunc(subexecutorDone)), flatMap9((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause2) => this.doneHalt(cause2),
      onSuccess: (value5) => this.doneSucceed(value5)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match9({
      onFailure: (cause2) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed5(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed5(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause2) {
    return this.finishSubexecutorWithCloseEffect(failCause4(cause2), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect3) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map17(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map17(() => this.replaceSubexecutor(drain5)));
        }
        this.replaceSubexecutor(drain5);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map13((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed8(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect3) => effect3 !== void 0 ? effect3 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach8(finalizers, (fin) => exit3(fin(exit4))), map17((exits) => pipe(all3(exits), getOrElse(() => void_3))), flatMap9((exit5) => suspend5(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read4 = () => {
    const current = readStack.pop();
    if (current === void 0 || current.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current.onEmit(current.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend5(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend5(() => read4());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read4()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current.onDone(current.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend5(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend5(() => read4());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read4()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current);
        return pipe(current.onEffect(state.effect), catchAllCause2((cause2) => suspend5(() => {
          const doneEffect = current.onDone(failCause4(cause2));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read4()
        }));
      }
      case OP_READ2: {
        readStack.push(current);
        readStack.push(state);
        return suspend5(() => read4());
      }
    }
  };
  return read4();
};
var runIn = /* @__PURE__ */ dual(2, (self, scope4) => {
  const run10 = (channelDeferred, scopeDeferred, scope5) => acquireUseRelease2(sync5(() => new ChannelExecutor(self, void 0, identity)), (exec) => suspend5(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause2(finalize, (cause2) => addFinalizer2(scope5, failCause6(cause2)));
  });
  return uninterruptibleMask3((restore) => all5([fork(scope4, sequential3), make26(), make26()]).pipe(flatMap9(([child, channelDeferred, scopeDeferred]) => restore(run10(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope4), flatMap9((fiber) => scope4.addFinalizer((exit4) => {
    const interruptors3 = isFailure(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone(channelDeferred).pipe(flatMap9((isDone6) => isDone6 ? succeed3(scopeDeferred, void 0).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed3(scopeDeferred, void 0).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt5(fiber)), zipRight3(inheritAll2(fiber)))));
  }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap9(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend5(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause6);
    }
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto11 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Await = (f) => {
  const op = Object.create(proto11);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto12 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto12);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto12);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto12);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto13 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto13);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto13);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match13 = /* @__PURE__ */ dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause2) => ({
  _tag: OP_STATE_ERROR,
  cause: cause2
});
var stateDone = (done8) => ({
  _tag: OP_STATE_DONE2,
  done: done8
});
var SingleProducerAsyncInputImpl = class {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten5(modify3(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId2) => this.error(interrupt4(fiberId2)));
  }
  done(value5) {
    return flatten5(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach8(state.notifyConsumers, (deferred) => succeed3(deferred, left2(value5)), {
            discard: true
          }), stateDone(value5)];
        }
        case OP_STATE_ERROR: {
          return [interrupt6, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt6, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap9(make26(), (deferred) => flatten5(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed3(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt6, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt6, state];
        }
      }
    })));
  }
  error(cause2) {
    return flatten5(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach8(state.notifyConsumers, (deferred) => failCause2(deferred, cause2), {
            discard: true
          }), stateError(cause2)];
        }
        case OP_STATE_ERROR: {
          return [interrupt6, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt6, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause2) => failCause4(map14(cause2, left2)), (elem) => succeed5(elem), (done8) => fail5(right2(done8)));
  }
  takeWith(onError4, onElement, onDone2) {
    return flatMap9(make26(), (deferred) => flatten5(modify3(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight3(succeed3(state.notifyProducer, void 0), matchCause3(_await(deferred), {
            onFailure: onError4,
            onSuccess: match({
              onLeft: onDone2,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause3(_await(deferred), {
            onFailure: onError4,
            onSuccess: match({
              onLeft: onDone2,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed8(onError4(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed8(onDone2(state.done)), state];
        }
      }
    })));
  }
};
var make44 = () => pipe(make26(), flatMap9((deferred) => make28(stateEmpty(deferred))), map17((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap12(fromEffect4(make28(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap2(acquire, (a) => set5(ref, (exit4) => release(a, exit4))))), flatMap12(use), ensuringWith((exit4) => flatMap9(get11(ref), (f) => f(exit4)))));
var concatMap = /* @__PURE__ */ dual(2, (self, f) => concatMapWith(self, f, () => void 0, () => void 0));
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause8,
    onDone: succeed11
  });
  return pipeTo(self, drainer);
};
var ensuring3 = /* @__PURE__ */ dual(2, (self, finalizer2) => ensuringWith(self, () => finalizer2));
var flatten8 = (self) => flatMap12(self, identity);
var fromInput = (input) => unwrap2(input.takeWith(failCause8, (elem) => flatMap12(write(elem), () => fromInput(input)), succeed11));
var identityChannel = () => readWith({
  onInput: (input) => flatMap12(write(input), () => identityChannel()),
  onFailure: fail11,
  onDone: succeedNow
});
var map20 = /* @__PURE__ */ dual(2, (self, f) => flatMap12(self, (a) => sync7(() => f(a))));
var mapOut = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap12(write(f(outElem)), () => reader),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap12(write), flatMap12(() => reader)),
    onFailure: failCause8,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mergeAll5 = (options3) => {
  return (channels) => mergeAllWith(options3)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope4) => gen2(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make44();
  const queueReader = fromInput(input);
  const queue = yield* bounded3(bufferSize);
  yield* addFinalizer2(scope4, shutdown2(queue));
  const cancelers = yield* unbounded3();
  yield* addFinalizer2(scope4, shutdown2(cancelers));
  const lastDone = yield* make28(none2());
  const errorSignal = yield* make26();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope4);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap9(match({
      onLeft: (done8) => succeed8(some2(done8)),
      onRight: (outElem) => as4(offer3(queue, succeed8(right2(outElem))), none2())
    })), repeat2({
      until: (_) => isSome2(_)
    }), flatMap9((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause2((cause2) => isInterrupted2(cause2) ? failCause6(cause2) : offer3(queue, failCause6(cause2)).pipe(zipRight3(succeed3(errorSignal, void 0)), asVoid2)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause2) => offer3(queue, failCause6(cause2)).pipe(zipRight3(succeed8(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as4(interrupt5(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight3(interrupt5(failureAwait), get11(lastDone).pipe(flatMap9(match2({
          onNone: () => offer3(queue, succeed8(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed8(left2(f(lastDone2, outDone))))
        })), as4(false)))
      }),
      onRight: (channel) => match13(mergeStrategy, {
        onBackPressure: () => gen2(function* () {
          const latch = yield* make26();
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap9((pull2) => race2(exit3(evaluatePull(pull2)), exit3(interruptible4(_await(errorSignal))))), flatMap9(identity)));
          yield* succeed3(latch, void 0).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen2(function* () {
          const canceler = yield* make26();
          const latch = yield* make26();
          const size13 = yield* size11(cancelers);
          yield* take3(cancelers).pipe(flatMap9((canceler2) => succeed3(canceler2, void 0)), when2(() => size13 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope5) => toPullIn(pipeTo(queueReader, channel), scope5).pipe(flatMap9((pull2) => exit3(evaluatePull(pull2)).pipe(race2(exit3(interruptible4(_await(errorSignal)))), race2(exit3(interruptible4(_await(canceler)))))), flatMap9(identity)));
          yield* succeed3(latch, void 0).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope4));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat2({
    while: (_) => _
  }), forkIn2(scope4));
  const consumer = pipe(take3(queue), flatten5, matchCause3({
    onFailure: failCause8,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap12(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self, f, options3) => mergeAll5(options3)(mapOut(self, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self, options3) => {
  function merge10(scope4) {
    return gen2(function* () {
      const input = yield* make44();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope4);
      const pullR = yield* toPullIn(pipeTo(queueReader, options3.other), scope4);
      function handleSide(exit4, fiber, pull) {
        return (done8, both2, single) => {
          function onDecision2(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed8(fromEffect4(zipRight3(interrupt5(fiber), op.effect)));
            }
            return map17(_await3(fiber), match9({
              onFailure: (cause2) => fromEffect4(op.f(failCause4(cause2))),
              onSuccess: match({
                onLeft: (done9) => fromEffect4(op.f(succeed5(done9))),
                onRight: (elem) => zipRight4(write(elem), go2(single(op.f)))
              })
            }));
          }
          return match9(exit4, {
            onFailure: (cause2) => onDecision2(done8(failCause4(cause2))),
            onSuccess: match({
              onLeft: (z) => onDecision2(done8(succeed5(z))),
              onRight: (elem) => succeed8(flatMap12(write(elem), () => flatMap12(fromEffect4(forkIn2(interruptible4(pull), scope4)), (leftFiber) => go2(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go2(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap2(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight3(interrupt5(rf), handleSide(leftExit, state.right, pullL)(options3.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight3(interrupt5(lf), handleSide(rightExit, state.left, pullR)(options3.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap2(map17(exit3(pullR), match9({
              onFailure: (cause2) => fromEffect4(state.f(failCause4(cause2))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed5(done8))),
                onRight: (elem) => flatMap12(write(elem), () => go2(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap2(map17(exit3(pullL), match9({
              onFailure: (cause2) => fromEffect4(state.f(failCause4(cause2))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed5(done8))),
                onRight: (elem) => flatMap12(write(elem), () => go2(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope4));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope4));
        return zipWith5(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap12(go2), embedInput(input));
    });
  }
  return unwrapScopedWith(merge10);
});
var pipeToOrFail = /* @__PURE__ */ dual(2, (self, that) => suspend6(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap12(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause8(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap12(() => writer)),
    onFailure: (cause2) => isDieType2(cause2) && isChannelException(cause2.defect) && equals(cause2.defect, channelException) ? fail11(cause2.defect.error) : failCause8(cause2),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var run = (self) => scopedWith2((scope4) => runIn(self, scope4));
var runDrain = (self) => run(drain(self));
var runScoped = (self) => scopeWith2((scope4) => runIn(self, scope4));
var scoped4 = (effect3) => unwrap2(uninterruptibleMask3((restore) => map17(make39(), (scope4) => acquireReleaseOut(tapErrorCause2(restore(extend2(effect3, scope4)), (cause2) => close(scope4, failCause4(cause2))), (_, exit4) => close(scope4, exit4)))));
var scopedWith3 = (f) => unwrapScoped2(map17(scope2, (scope4) => flatMap12(fromEffect4(f(scope4)), write)));
var splitLines = () => suspend6(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk4) => {
    const chunkBuilder = [];
    map4(chunk4, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop2 = readWithCause({
    onInput: (input) => {
      const out2 = splitLinesChunk(input);
      return isEmpty(out2) ? loop2 : flatMap12(write(out2), () => loop2);
    },
    onFailure: (cause2) => stringBuilder.length === 0 ? failCause8(cause2) : flatMap12(write(of2(stringBuilder)), () => failCause8(cause2)),
    onDone: (done8) => stringBuilder.length === 0 ? succeed11(done8) : flatMap12(write(of2(stringBuilder)), () => succeed11(done8))
  });
  return loop2;
});
var toPullIn = /* @__PURE__ */ dual(2, (self, scope4) => zip6(sync5(() => new ChannelExecutor(self, void 0, identity)), runtime4()).pipe(tap2(([executor, runtime5]) => addFinalizerExit(scope4, (exit4) => {
  const finalizer2 = executor.close(exit4);
  return finalizer2 !== void 0 ? provide2(finalizer2, runtime5) : _void;
})), uninterruptible2, map17(([executor]) => suspend5(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause6,
        onSuccess: (done8) => succeed8(left2(done8))
      });
    }
    case OP_EMIT2: {
      return succeed8(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap9(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause2) => failCause6(cause2));
    }
  }
};
var unwrap2 = (channel) => flatten8(fromEffect4(channel));
var unwrapScoped2 = (self) => concatAllWith(scoped4(self), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk4) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk4, unsafeGet2(idx))), flatMap12(() => writeChunkWriter(idx + 1, len, chunk4)));
};
var zip7 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options3) => options3?.concurrent ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend5(() => zip4(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend5(() => zip4(exit1, exit22)))
}) : flatMap12(self, (a) => map20(that, (b) => [a, b])));
var zipRight4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options3) => options3?.concurrent ? map20(zip7(self, that, {
  concurrent: true
}), (tuple3) => tuple3[1]) : flatMap12(self, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var SinkImpl = class {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var suspend7 = (evaluate2) => new SinkImpl(suspend6(() => toChannel(evaluate2())));
var collectAll = () => new SinkImpl(collectAllLoop(empty3()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk4) => collectAllLoop(pipe(acc, appendAll2(chunk4))),
  onFailure: failCause8,
  onDone: () => succeed11(acc)
});
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var foldChunks = (s, contFn, f) => suspend7(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var forEach9 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(forEach8(input, (v) => f(v), {
      discard: true
    })), flatMap12(() => process2)),
    onFailure: failCause8,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect6(self)) : self.channel;
var unwrapScoped3 = (effect3) => new SinkImpl(unwrapScoped2(effect3.pipe(map17((sink) => toChannel(sink)))));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork3;
var runPromiseExit = unsafeRunPromiseExit;
var updateContext3 = updateContext2;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Schedule.js
var spaced2 = spaced;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/stream/emit.js
var make45 = (emit) => {
  const ops = {
    chunk(as9) {
      return this(succeed8(as9));
    },
    die(defect) {
      return this(die5(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend5(() => mapBoth3(exit4, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail8(none2()));
    },
    fail(e) {
      return this(fail8(some2(e)));
    },
    fromEffect(effect3) {
      return this(mapBoth4(effect3, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect3) {
      return this(pipe(effect3, mapError2(some2)));
    },
    halt(cause2) {
      return this(failCause6(pipe(cause2, map14(some2))));
    },
    single(value5) {
      return this(succeed8(of2(value5)));
    }
  };
  return Object.assign(emit, ops);
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var TakeImpl = class {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit4) {
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk3 = (chunk4) => new TakeImpl(succeed5(chunk4));
var done7 = (self) => suspend5(() => self.exit);
var end3 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail5(/* @__PURE__ */ none2()));
var failCause9 = (cause2) => new TakeImpl(failCause4(pipe(cause2, map14(some2))));
var fromPull = (pull) => matchCause3(pull, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: () => end3,
    onSome: failCause9
  }),
  onSuccess: chunk3
});
var match14 = /* @__PURE__ */ dual(2, (self, {
  onEnd: onEnd2,
  onFailure,
  onSuccess
}) => match9(self.exit, {
  onFailure: (cause2) => match2(flipCauseOption2(cause2), {
    onNone: onEnd2,
    onSome: onFailure
  }),
  onSuccess
}));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/stream/pull.js
var end4 = () => fail8(none2());

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var StreamImpl = class {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded3();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded3(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping2(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding2(bufferSize.bufferSize ?? 16);
    default:
      return bounded3(bufferSize.bufferSize ?? 16);
  }
};
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap9((output) => pipe(runtime4(), flatMap9((runtime5) => pipe(register(make45((k) => pipe(fromPull(k), flatMap9((take6) => offer3(output, take6)), asVoid2, runPromiseExit(runtime5)).then((exit4) => {
  if (isFailure(exit4)) {
    if (!isInterrupted2(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight3(make28(false)), flatMap9((ref) => pipe(get11(ref), map17((isDone6) => isDone6 ? end4() : pipe(take3(output), flatMap9(done7), onError2(() => pipe(set5(ref, true), zipRight3(shutdown2(output)))))))))))), scoped5, flatMap14(repeatEffectChunkOption));
var bufferChunks = /* @__PURE__ */ dual(2, (self, options3) => {
  if (options3.strategy === "dropping") {
    return bufferChunksDropping(self, options3.capacity);
  } else if (options3.strategy === "sliding") {
    return bufferChunksSliding(self, options3.capacity);
  }
  const queue = toQueue(self, options3);
  return new StreamImpl(unwrapScoped2(map17(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap12(match14({
      onEnd: () => void_5,
      onFailure: failCause8,
      onSuccess: (value5) => pipe(write(value5), flatMap12(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self, capacity3) => {
  const queue = acquireRelease2(dropping2(capacity3), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self, capacity3) => {
  const queue = acquireRelease2(sliding2(capacity3), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferSignal = (scoped6, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take6) => pipe(get11(ref), tap2(_await), zipRight3(make26()), flatMap9((deferred) => pipe(offer3(queue, [take6, deferred]), zipRight3(set5(ref, deferred)), zipRight3(_await(deferred)))), asVoid2, fromEffect4);
    return readWithCause({
      onInput: (input) => pipe(make26(), flatMap9((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap9((added) => pipe(set5(ref, deferred), when2(() => added))))), asVoid2, fromEffect4, flatMap12(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause9(error4)),
      onDone: () => terminate(end3)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect4(take3(queue)), flatMap12(([take6, deferred]) => zipRight4(fromEffect4(succeed3(deferred, void 0)), match14(take6, {
      onEnd: () => void_5,
      onFailure: failCause8,
      onSuccess: (value5) => pipe(write(value5), flatMap12(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped2(pipe(scoped6, flatMap9((queue) => pipe(make26(), tap2((start4) => succeed3(start4, void 0)), flatMap9((start4) => pipe(make28(start4), flatMap9((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as4(consumer(queue))))))));
};
var flatMap14 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options3) => {
  const bufferSize = options3?.bufferSize ?? 16;
  if (options3?.switch) {
    return matchConcurrency(options3?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options3?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as9) => pipe(as9, map4((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out2) => toChannel2(f(out2)), options3))));
});
var matchConcurrency = (concurrency, sequential5, bounded4) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return bounded4(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded4(concurrency) : sequential5();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out2) => toChannel2(f(out2)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten10 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options3) => flatMap14(self, identity, options3));
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream3) => {
  if ("channel" in stream3) {
    return stream3.channel;
  } else if (isEffect2(stream3)) {
    return toChannel2(fromEffect7(stream3));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromEffect7 = (effect3) => pipe(effect3, mapError2(some2), fromEffectOption);
var fromEffectOption = (effect3) => new StreamImpl(unwrap2(match11(effect3, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail11
  }),
  onSuccess: (a) => write(of2(a))
})));
var mapChunks = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var repeatEffectChunkOption = (effect3) => unfoldChunkEffect(effect3, (effect4) => pipe(map17(effect4, (chunk4) => some2([chunk4, effect4])), catchAll2(match2({
  onNone: () => succeed8(none2()),
  onSome: fail8
}))));
var run3 = /* @__PURE__ */ dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self) => run3(self, collectAll());
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap12(write(chunk3(input)), () => writer),
    onFailure: (cause2) => write(failCause9(cause2)),
    onDone: () => write(end3)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take6) => offer3(queue, take6)), drain, runScoped, asVoid2);
});
var scoped5 = (effect3) => new StreamImpl(ensuring3(scoped4(pipe(effect3, map17(of2))), _void));
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var suspend8 = (stream3) => new StreamImpl(suspend6(() => toChannel2(stream3())));
var toQueue = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options3) => tap2(acquireRelease2(options3?.strategy === "unbounded" ? unbounded3() : options3?.strategy === "dropping" ? dropping2(options3.capacity ?? 2) : options3?.strategy === "sliding" ? sliding2(options3.capacity ?? 2) : bounded3(options3?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
var transduce = /* @__PURE__ */ dual(2, (self, sink) => {
  const newChannel = suspend6(() => {
    const leftovers = {
      ref: empty3()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer3 = suspend6(() => {
      const leftover2 = leftovers.ref;
      if (isEmpty(leftover2)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap12(() => buffer3)),
          onFailure: fail11,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty3();
      return pipe(writeChunk(leftover2), flatMap12(() => buffer3));
    });
    const concatAndGet = (chunk4) => {
      const leftover2 = leftovers.ref;
      const concatenated = appendAll2(leftover2, filter3(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap12(write(input), () => upstreamMarker),
      onFailure: fail11,
      onDone: (done8) => zipRight4(sync7(() => {
        upstreamDone.ref = true;
      }), succeedNow(done8))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap12(([leftover2, z]) => pipe(succeed11([upstreamDone.ref, concatAndGet(leftover2)]), flatMap12(([done8, newLeftovers]) => {
      const nextChannel = done8 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z)), flatMap12(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer3), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var unfoldChunkEffect = (s, f) => suspend8(() => {
  const loop2 = (s2) => unwrap2(map17(f(s2), match2({
    onNone: () => void_5,
    onSome: ([chunk4, s3]) => flatMap12(write(chunk4), () => loop2(s3))
  })));
  return new StreamImpl(loop2(s));
});
var unwrap3 = (effect3) => flatten10(fromEffect7(effect3));
var unwrapScoped4 = (effect3) => flatten10(scoped5(effect3));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Channel.js
var acquireUseRelease4 = acquireUseRelease3;
var embedInput2 = embedInput;
var flatMap15 = flatMap12;
var suspend9 = suspend6;
var void_6 = void_5;
var write2 = write;
var zipRight7 = zipRight4;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Sink.js
var drain3 = drain2;
var foldLeftChunks2 = foldLeftChunks;
var forEach10 = forEach9;
var fromChannel3 = fromChannel;
var unwrapScoped5 = unwrapScoped3;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Stream.js
var asyncScoped2 = asyncScoped;
var bufferChunks2 = bufferChunks;
var fromChannel4 = fromChannel2;
var mapChunks2 = mapChunks;
var run4 = run3;
var runCollect3 = runCollect;
var splitLines3 = splitLines2;
var transduce2 = transduce;
var unwrap5 = unwrap3;
var unwrapScoped6 = unwrapScoped4;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/error.js
var PlatformErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Error/PlatformErrorTypeId");
var make47 = (tag4) => (props) => struct2({
  [PlatformErrorTypeId]: PlatformErrorTypeId,
  _tag: tag4,
  ...props
});
var badArgument = /* @__PURE__ */ make47("BadArgument");
var systemError = /* @__PURE__ */ make47("SystemError");

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Error.js
var BadArgument = badArgument;
var SystemError = systemError;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var Size = (bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes);
var make48 = (impl) => {
  return tag.of({
    ...impl,
    exists: (path2) => pipe(impl.access(path2), as4(true), catchTag2("SystemError", (e) => e.reason === "NotFound" ? succeed8(false) : fail8(e))),
    readFileString: (path2, encoding) => tryMap2(impl.readFile(path2), {
      try: (_) => new TextDecoder(encoding).decode(_),
      catch: () => BadArgument({
        module: "FileSystem",
        method: "readFileString",
        message: "invalid encoding"
      })
    }),
    stream: (path2, options3) => pipe(impl.open(path2, {
      flag: "r"
    }), options3?.offset ? tap2((file3) => file3.seek(options3.offset, "start")) : identity, map17((file3) => stream(file3, options3)), unwrapScoped6),
    sink: (path2, options3) => pipe(impl.open(path2, {
      flag: "w",
      ...options3
    }), map17((file3) => forEach10((_) => file3.writeAll(_))), unwrapScoped5),
    writeFileString: (path2, data, options3) => flatMap9(try_2({
      try: () => new TextEncoder().encode(data),
      catch: () => BadArgument({
        module: "FileSystem",
        method: "writeFileString",
        message: "could not encode string"
      })
    }), (_) => impl.writeFile(path2, _, options3))
  });
};
var stream = (file3, {
  bufferSize = 16,
  bytesToRead: bytesToRead_,
  chunkSize: chunkSize_ = Size(64 * 1024)
} = {}) => {
  const bytesToRead = bytesToRead_ !== void 0 ? Size(bytesToRead_) : void 0;
  const chunkSize = Size(chunkSize_);
  function loop2(totalBytesRead) {
    if (bytesToRead !== void 0 && bytesToRead <= totalBytesRead) {
      return void_6;
    }
    const toRead = bytesToRead !== void 0 && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;
    return flatMap15(file3.readAlloc(toRead), match2({
      onNone: () => void_6,
      onSome: (buf) => flatMap15(write2(of2(buf)), (_) => loop2(totalBytesRead + BigInt(buf.length)))
    }));
  }
  return bufferChunks2(fromChannel4(loop2(BigInt(0))), {
    capacity: bufferSize
  });
};

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/FileSystem.js
var Size2 = Size;
var FileSystem = tag;
var make49 = make48;
var FileTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/FileSystem/File");
var FileDescriptor = /* @__PURE__ */ nominal();
var WatchEventCreate = /* @__PURE__ */ tagged2("Create");
var WatchEventUpdate = /* @__PURE__ */ tagged2("Update");
var WatchEventRemove = /* @__PURE__ */ tagged2("Remove");
var WatchBackend = class extends (/* @__PURE__ */ Tag2("@effect/platform/FileSystem/WatchBackend")()) {
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/files.js
var Ini = __toESM(require_ini(), 1);
var Toml = __toESM(require_toml(), 1);
var fileParsers = {
  json: (content) => JSON.parse(content),
  yaml: (content) => Yaml__namespace.parse(content),
  yml: (content) => Yaml__namespace.parse(content),
  ini: (content) => Ini.parse(content),
  toml: (content) => Toml.parse(content),
  tml: (content) => Toml.parse(content)
};
var readString = (path2) => flatMap9(FileSystem, (fs) => matchEffect2(fs.readFileString(path2), {
  onFailure: (error4) => fail8(`Could not read file (${path2}): ${error4}`),
  onSuccess: (content) => succeed8([path2, content])
}));
var parse5 = (path2, content, format6) => {
  const parser = fileParsers[format6 ?? path2.split(".").pop()];
  if (parser === void 0) {
    return fail8(`Unsupported file format: ${format6}`);
  }
  return try_2({
    try: () => parser(content),
    catch: (e) => `Could not parse ${format6} file (${path2}): ${e}`
  });
};

// node_modules/.pnpm/@effect+typeclass@0.34.2_effect@3.15.2/node_modules/@effect/typeclass/dist/esm/internal/Iterable.js
function reduce13(b, f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.reduce(f, b);
    }
    let result = b;
    for (const n of iterable) {
      result = f(result, n);
    }
    return result;
  };
}
function map23(f) {
  return function(iterable) {
    if (Array.isArray(iterable)) {
      return iterable.map(f);
    }
    return function* () {
      for (const n of iterable) {
        yield f(n);
      }
    }();
  };
}

// node_modules/.pnpm/@effect+typeclass@0.34.2_effect@3.15.2/node_modules/@effect/typeclass/dist/esm/Product.js
var struct3 = (F) => (fields) => {
  const keys5 = Object.keys(fields);
  return F.imap(F.productAll(keys5.map((k) => fields[k])), (values3) => {
    const out2 = {};
    for (let i = 0; i < values3.length; i++) {
      out2[keys5[i]] = values3[i];
    }
    return out2;
  }, (r) => keys5.map((k) => r[k]));
};

// node_modules/.pnpm/@effect+typeclass@0.34.2_effect@3.15.2/node_modules/@effect/typeclass/dist/esm/Semigroup.js
var make50 = (combine12, combineMany = (self, collection) => reduce13(self, combine12)(collection)) => ({
  combine: combine12,
  combineMany
});
var constant2 = (a) => make50(() => a, () => a);
var first2 = () => make50((a) => a, (a) => a);
var imap = /* @__PURE__ */ dual(3, (S, to, from) => make50((self, that) => to(S.combine(from(self), from(that))), (self, collection) => to(S.combineMany(from(self), map23(from)(collection)))));
var product = (self, that) => make50(([xa, xb], [ya, yb]) => [self.combine(xa, ya), that.combine(xb, yb)]);
var productAll = (collection) => {
  return make50((x, y) => {
    const len = Math.min(x.length, y.length);
    const out2 = [];
    let collectionLength = 0;
    for (const s of collection) {
      if (collectionLength >= len) {
        break;
      }
      out2.push(s.combine(x[collectionLength], y[collectionLength]));
      collectionLength++;
    }
    return out2;
  });
};
var productMany = (self, collection) => {
  const semigroup = productAll(collection);
  return make50((x, y) => [self.combine(x[0], y[0]), ...semigroup.combine(x.slice(1), y.slice(1))]);
};
var of5 = constant2;
var Product = {
  of: of5,
  imap,
  product,
  productMany,
  productAll
};
var array4 = () => make50((self, that) => self.concat(that));
var struct4 = /* @__PURE__ */ struct3(Product);

// node_modules/.pnpm/@effect+typeclass@0.34.2_effect@3.15.2/node_modules/@effect/typeclass/dist/esm/Monoid.js
var fromSemigroup = (S, empty39) => ({
  combine: S.combine,
  combineMany: S.combineMany,
  empty: empty39,
  combineAll: (collection) => S.combineMany(empty39, collection)
});
var array5 = () => fromSemigroup(array4(), []);
var struct5 = (fields) => {
  const empty39 = {};
  for (const k in fields) {
    if (Object.prototype.hasOwnProperty.call(fields, k)) {
      empty39[k] = fields[k].empty;
    }
  }
  return fromSemigroup(struct4(fields), empty39);
};

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/internal/color.js
var black = {
  _tag: "Black"
};
var red = {
  _tag: "Red"
};
var green = {
  _tag: "Green"
};
var magenta = {
  _tag: "Magenta"
};
var cyan = {
  _tag: "Cyan"
};
var white = {
  _tag: "White"
};
var toCode = (color3) => {
  switch (color3._tag) {
    case "Black": {
      return 0;
    }
    case "Red": {
      return 1;
    }
    case "Green": {
      return 2;
    }
    case "Yellow": {
      return 3;
    }
    case "Blue": {
      return 4;
    }
    case "Magenta": {
      return 5;
    }
    case "Cyan": {
      return 6;
    }
    case "White": {
      return 7;
    }
  }
};

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/internal/sgr.js
var reset = {
  _tag: "Reset"
};
var setBold = (bold3) => ({
  _tag: "SetBold",
  bold: bold3
});
var setColor = (color3, vivid, layer14) => ({
  _tag: "SetColor",
  color: color3,
  vivid,
  layer: layer14
});
var setItalicized = (italicized3) => ({
  _tag: "SetItalicized",
  italicized: italicized3
});
var setStrikethrough = (strikethrough3) => ({
  _tag: "SetStrikethrough",
  strikethrough: strikethrough3
});
var setUnderlined = (underlined3) => ({
  _tag: "SetUnderlined",
  underlined: underlined3
});
var toCode2 = (self) => {
  switch (self._tag) {
    case "Reset": {
      return 0;
    }
    case "SetBold": {
      return self.bold ? 1 : 22;
    }
    case "SetColor": {
      switch (self.layer) {
        case "foreground": {
          return self.vivid ? 90 + toCode(self.color) : 30 + toCode(self.color);
        }
        case "background": {
          return self.vivid ? 100 + toCode(self.color) : 40 + toCode(self.color);
        }
      }
    }
    case "SetItalicized": {
      return self.italicized ? 3 : 23;
    }
    case "SetStrikethrough": {
      return self.strikethrough ? 9 : 29;
    }
    case "SetUnderlined": {
      return self.underlined ? 4 : 24;
    }
  }
};
var toEscapeSequence = (sgrs) => csi("m", sgrs);
var csi = (controlFunction, sgrs) => {
  const params = Array.from(sgrs).map((sgr) => `${toCode2(sgr)}`).join(";");
  return `\x1B[${params}${controlFunction}`;
};

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/internal/ansi.js
var AnsiSymbolKey = "@effect/printer-ansi/Ansi";
var AnsiTypeId = /* @__PURE__ */ Symbol.for(AnsiSymbolKey);
var make51 = (params) => ({
  ...AnsiMonoid.empty,
  ...params
});
var typeIdSemigroup = /* @__PURE__ */ first2();
var getFirstSomeSemigroup = /* @__PURE__ */ make50((self, that) => isSome2(self) ? self : that);
var AnsiSemigroup = /* @__PURE__ */ struct4({
  [AnsiTypeId]: typeIdSemigroup,
  commands: /* @__PURE__ */ array4(),
  foreground: getFirstSomeSemigroup,
  background: getFirstSomeSemigroup,
  bold: getFirstSomeSemigroup,
  italicized: getFirstSomeSemigroup,
  strikethrough: getFirstSomeSemigroup,
  underlined: getFirstSomeSemigroup
});
var typeIdMonoid = /* @__PURE__ */ fromSemigroup(typeIdSemigroup, AnsiTypeId);
var monoidOrElse = /* @__PURE__ */ fromSemigroup(getFirstSomeSemigroup, /* @__PURE__ */ none2());
var AnsiMonoid = /* @__PURE__ */ struct5({
  [AnsiTypeId]: typeIdMonoid,
  commands: /* @__PURE__ */ array5(),
  foreground: monoidOrElse,
  background: monoidOrElse,
  bold: monoidOrElse,
  italicized: monoidOrElse,
  strikethrough: monoidOrElse,
  underlined: monoidOrElse
});
var none9 = AnsiMonoid.empty;
var ESC = "\x1B[";
var BEL = "\x07";
var SEP = ";";
var bold = /* @__PURE__ */ make51({
  bold: /* @__PURE__ */ some2(/* @__PURE__ */ setBold(true))
});
var italicized = /* @__PURE__ */ make51({
  italicized: /* @__PURE__ */ some2(/* @__PURE__ */ setItalicized(true))
});
var strikethrough = /* @__PURE__ */ make51({
  strikethrough: /* @__PURE__ */ some2(/* @__PURE__ */ setStrikethrough(true))
});
var underlined = /* @__PURE__ */ make51({
  underlined: /* @__PURE__ */ some2(/* @__PURE__ */ setUnderlined(true))
});
var brightColor = (color3) => make51({
  foreground: some2(setColor(color3, true, "foreground"))
});
var color = (color3) => make51({
  foreground: some2(setColor(color3, false, "foreground"))
});
var black2 = /* @__PURE__ */ color(black);
var red2 = /* @__PURE__ */ color(red);
var green2 = /* @__PURE__ */ color(green);
var white2 = /* @__PURE__ */ color(white);
var blackBright = /* @__PURE__ */ brightColor(black);
var cyanBright = /* @__PURE__ */ brightColor(cyan);
var beep = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(BEL)
});
var cursorTo = (column3, row) => {
  if (row === void 0) {
    const command2 = `${ESC}${Math.max(column3 + 1, 0)}G`;
    return make51({
      commands: of(command2)
    });
  }
  const command = `${ESC}${row + 1}${SEP}${Math.max(column3 + 1, 0)}H`;
  return make51({
    commands: of(command)
  });
};
var cursorMove = (column3, row = 0) => {
  let command = "";
  if (row < 0) {
    command += `${ESC}${-row}A`;
  }
  if (row > 0) {
    command += `${ESC}${row}B`;
  }
  if (column3 > 0) {
    command += `${ESC}${column3}C`;
  }
  if (column3 < 0) {
    command += `${ESC}${-column3}D`;
  }
  return make51({
    commands: of(command)
  });
};
var cursorDown = (lines3 = 1) => {
  const command = `${ESC}${lines3}B`;
  return make51({
    commands: of(command)
  });
};
var cursorLeft = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(`${ESC}G`)
});
var cursorSavePosition = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(`${ESC}s`)
});
var cursorRestorePosition = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(`${ESC}u`)
});
var cursorHide = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(`${ESC}?25l`)
});
var cursorShow = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(`${ESC}?25h`)
});
var eraseLines = (rows) => {
  let command = "";
  for (let i = 0; i < rows; i++) {
    command += `${ESC}2K` + (i < rows - 1 ? `${ESC}1A` : "");
  }
  if (rows > 0) {
    command += `${ESC}G`;
  }
  return make51({
    commands: of(command)
  });
};
var eraseLine = /* @__PURE__ */ make51({
  commands: /* @__PURE__ */ of(`${ESC}2K`)
});
var stringify = (self) => stringifyInternal(self);
var combine10 = /* @__PURE__ */ dual(2, (self, that) => combineInternal(self, that));
var combineInternal = (self, that) => AnsiSemigroup.combine(self, that);
var stringifyInternal = (self) => {
  const displaySequence = toEscapeSequence(getSomes([some2(reset), self.foreground, self.background, self.bold, self.italicized, self.strikethrough, self.underlined]));
  const commandSequence = join(self.commands, "");
  return `${displaySequence}${commandSequence}`;
};

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/Ansi.js
var bold2 = bold;
var italicized2 = italicized;
var strikethrough2 = strikethrough;
var underlined2 = underlined;
var color2 = color;
var black3 = black2;
var red3 = red2;
var green3 = green2;
var white3 = white2;
var blackBright2 = blackBright;
var cyanBright2 = cyanBright;
var combine11 = combine10;

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/flatten.js
var FlattenSymbolKey = "@effect/printer/Flatten";
var FlattenTypeId = /* @__PURE__ */ Symbol.for(FlattenSymbolKey);
var protoHash = {
  Flattened: (self) => combine(hash(self.value))(string(FlattenSymbolKey)),
  AlreadyFlat: (_) => combine(string("@effect/printer/Flattened/AlreadyFlat"))(string(FlattenSymbolKey)),
  NeverFlat: (_) => combine(string("@effect/printer/Flattened/NeverFlat"))(string(FlattenSymbolKey))
};
var protoEqual = {
  Flattened: (self, that) => isFlatten(that) && that._tag === "Flattened" && equals(self.value, that.value),
  AlreadyFlat: (_, that) => isFlatten(that) && that._tag === "AlreadyFlat",
  NeverFlat: (_, that) => isFlatten(that) && that._tag === "NeverFlat"
};
var proto14 = {
  [FlattenTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual[this._tag](this, that);
  }
};
var isFlatten = (u) => typeof u === "object" && u != null && FlattenTypeId in u;
var isFlattened = (self) => self._tag === "Flattened";
var isAlreadyFlat = (self) => self._tag === "AlreadyFlat";
var isNeverFlat = (self) => self._tag === "NeverFlat";
var flattened = (value5) => (() => {
  const op = Object.create(proto14);
  op._tag = "Flattened";
  op.value = value5;
  return op;
})();
var alreadyFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto14);
  op._tag = "AlreadyFlat";
  return op;
})();
var neverFlat = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto14);
  op._tag = "NeverFlat";
  return op;
})();
var map24 = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case "Flattened": {
      return flattened(f(self.value));
    }
    case "AlreadyFlat": {
      return alreadyFlat;
    }
    case "NeverFlat": {
      return neverFlat;
    }
  }
});

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/doc.js
var DocSymbolKey = "@effect/printer/Doc";
var DocTypeId = /* @__PURE__ */ Symbol.for(DocSymbolKey);
var protoHash2 = {
  Fail: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Fail")),
  Empty: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Empty")),
  Char: (self) => combine(hash(DocSymbolKey))(string(self.char)),
  Text: (self) => combine(hash(DocSymbolKey))(string(self.text)),
  Line: (_) => combine(hash(DocSymbolKey))(hash("@effect/printer/Doc/Line")),
  FlatAlt: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Cat: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Nest: (self) => combine(hash(DocSymbolKey))(combine(hash(self.indent))(hash(self.doc))),
  Union: (self) => combine(hash(DocSymbolKey))(combine(hash(self.left))(hash(self.right))),
  Column: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  WithPageWidth: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  Nesting: (self) => combine(hash(DocSymbolKey))(hash(self.react)),
  Annotated: (self) => combine(hash(DocSymbolKey))(combine(hash(self.annotation))(hash(self.doc)))
};
var protoEqual2 = {
  Fail: (_, that) => isDoc(that) && that._tag === "Fail",
  Empty: (_, that) => isDoc(that) && that._tag === "Empty",
  Char: (self, that) => isDoc(that) && that._tag === "Char" && self.char === that.char,
  Text: (self, that) => isDoc(that) && that._tag === "Text" && self.text === that.text,
  Line: (_, that) => isDoc(that) && that._tag === "Line",
  FlatAlt: (self, that) => isDoc(that) && that._tag === "FlatAlt" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Cat: (self, that) => isDoc(that) && that._tag === "Cat" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Nest: (self, that) => isDoc(that) && that._tag === "Nest" && self.indent === that.indent && equals(that.doc)(self.doc),
  Union: (self, that) => isDoc(that) && that._tag === "Union" && equals(that.left)(self.left) && equals(that.right)(self.right),
  Column: (self, that) => isDoc(that) && that._tag === "Column" && equals(that.react)(self.react),
  WithPageWidth: (self, that) => isDoc(that) && that._tag === "WithPageWidth" && equals(that.react)(self.react),
  Nesting: (self, that) => isDoc(that) && that._tag === "Nesting" && equals(that.react)(self.react),
  Annotated: (self, that) => isDoc(that) && that._tag === "Annotated" && equals(that.annotation)(self.annotation) && equals(that.doc)(self.doc)
};
var proto15 = {
  [DocTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash2[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual2[this._tag](this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isDoc = (u) => typeof u === "object" && u != null && DocTypeId in u;
var isEmpty11 = (self) => self._tag === "Empty";
var isChar = (self) => self._tag === "Char";
var isText = (self) => self._tag === "Text";
var isCat = (self) => self._tag === "Cat";
var isNest = (self) => self._tag === "Nest";
var char = (char4) => {
  const op = Object.create(proto15);
  op._tag = "Char";
  op.char = char4;
  return op;
};
var text = (text9) => {
  const op = Object.create(proto15);
  op._tag = "Text";
  op.text = text9;
  return op;
};
var flatAlt = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto15);
  op._tag = "FlatAlt";
  op.left = self;
  op.right = that;
  return op;
});
var union9 = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto15);
  op._tag = "Union";
  op.left = self;
  op.right = that;
  return op;
});
var cat = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto15);
  op._tag = "Cat";
  op.left = self;
  op.right = that;
  return op;
});
var empty32 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto15);
  op._tag = "Empty";
  return op;
})();
var fail16 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto15);
  op._tag = "Fail";
  return op;
})();
var hardLine = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto15);
  op._tag = "Line";
  return op;
})();
var line = /* @__PURE__ */ flatAlt(hardLine, /* @__PURE__ */ char(" "));
var lineBreak = /* @__PURE__ */ flatAlt(hardLine, empty32);
var space = /* @__PURE__ */ char(" ");
var cats = (docs) => group2(vcat(docs));
var catWithLine = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(line, that)));
var catWithLineBreak = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(lineBreak, that)));
var catWithSpace = /* @__PURE__ */ dual(2, (self, that) => cat(self, cat(space, that)));
var concatWith = /* @__PURE__ */ dual(2, (docs, f) => matchRight(fromIterable(docs), {
  onEmpty: () => empty32,
  onNonEmpty: (init, last5) => reduceRight(init, last5, (curr, acc) => f(acc, curr))
}));
var vcat = (docs) => concatWith(docs, (left3, right3) => catWithLineBreak(left3, right3));
var hsep = (docs) => concatWith(docs, (left3, right3) => catWithSpace(left3, right3));
var vsep = (docs) => concatWith(docs, (left3, right3) => catWithLine(left3, right3));
var group2 = (self) => {
  switch (self._tag) {
    case "FlatAlt": {
      const flattened2 = changesUponFlattening(self.right);
      switch (flattened2._tag) {
        case "Flattened": {
          return union9(flattened2.value, self.left);
        }
        case "AlreadyFlat": {
          return union9(self.right, self.left);
        }
        case "NeverFlat": {
          return self.left;
        }
      }
    }
    case "Union": {
      return self;
    }
    default: {
      const flattened2 = changesUponFlattening(self);
      return isFlattened(flattened2) ? union9(flattened2.value, self) : self;
    }
  }
};
var column = (react) => {
  const op = Object.create(proto15);
  op._tag = "Column";
  op.react = react;
  return op;
};
var nesting = (react) => {
  const op = Object.create(proto15);
  op._tag = "Nesting";
  op.react = react;
  return op;
};
var pageWidth = (react) => {
  const op = Object.create(proto15);
  op._tag = "WithPageWidth";
  op.react = react;
  return op;
};
var nest = /* @__PURE__ */ dual(2, (self, indent3) => indent3 === 0 ? self : (() => {
  const op = Object.create(proto15);
  op._tag = "Nest";
  op.indent = indent3;
  op.doc = self;
  return op;
})());
var align = (self) => column((position) => nesting((level) => nest(self, position - level)));
var hang = /* @__PURE__ */ dual(2, (self, indent3) => align(nest(self, indent3)));
var indent = /* @__PURE__ */ dual(2, (self, indent3) => hang(cat(spaces(indent3), self), indent3));
var flatten11 = (self) => runSync(flattenSafe(self));
var flattenSafe = (self) => gen2(function* () {
  switch (self._tag) {
    case "Fail": {
      return self;
    }
    case "Empty": {
      return self;
    }
    case "Char": {
      return self;
    }
    case "Text": {
      return self;
    }
    case "Line": {
      return fail16;
    }
    case "FlatAlt": {
      return yield* flattenSafe(self.right);
    }
    case "Cat": {
      const left3 = yield* flattenSafe(self.left);
      const right3 = yield* flattenSafe(self.right);
      return cat(left3, right3);
    }
    case "Nest": {
      const doc = yield* flattenSafe(self.doc);
      return nest(doc, self.indent);
    }
    case "Union": {
      return yield* flattenSafe(self.left);
    }
    case "Column": {
      return column((position) => flatten11(self.react(position)));
    }
    case "WithPageWidth": {
      return pageWidth((pageWidth3) => flatten11(self.react(pageWidth3)));
    }
    case "Nesting": {
      return nesting((level) => flatten11(self.react(level)));
    }
    case "Annotated": {
      const doc = yield* flattenSafe(self.doc);
      return annotate(doc, self.annotation);
    }
  }
});
var changesUponFlattening = (self) => runSync(changesUponFlatteningSafe(self));
var changesUponFlatteningSafe = (self) => gen2(function* () {
  switch (self._tag) {
    case "Fail":
    case "Line": {
      return neverFlat;
    }
    case "Empty":
    case "Char":
    case "Text": {
      return alreadyFlat;
    }
    case "FlatAlt": {
      const doc = yield* flattenSafe(self.right);
      return flattened(doc);
    }
    case "Cat": {
      const left3 = yield* changesUponFlatteningSafe(self.left);
      const right3 = yield* changesUponFlatteningSafe(self.right);
      if (isNeverFlat(left3) || isNeverFlat(right3)) {
        return neverFlat;
      }
      if (isFlattened(left3) && isFlattened(right3)) {
        return flattened(cat(left3.value, right3.value));
      }
      if (isFlattened(left3) && isAlreadyFlat(right3)) {
        return flattened(cat(left3.value, self.right));
      }
      if (isAlreadyFlat(left3) && isFlattened(right3)) {
        return flattened(cat(self.left, right3.value));
      }
      if (isAlreadyFlat(left3) && isAlreadyFlat(right3)) {
        return alreadyFlat;
      }
      throw new Error("[BUG]: Doc.changesUponFlattening - unable to flatten a Cat document - please open an issue at https://github.com/IMax153/contentlayer/issues/new");
    }
    case "Nest": {
      return yield* pipe(changesUponFlatteningSafe(self.doc), map17(map24((doc) => nest(doc, self.indent))));
    }
    case "Union": {
      return flattened(self.left);
    }
    case "Column": {
      const doc = column((position) => runSync(flattenSafe(self.react(position))));
      return flattened(doc);
    }
    case "WithPageWidth": {
      const doc = pageWidth((pageWidth3) => runSync(flattenSafe(self.react(pageWidth3))));
      return flattened(doc);
    }
    case "Nesting": {
      const doc = nesting((level) => runSync(flattenSafe(self.react(level))));
      return flattened(doc);
    }
    case "Annotated": {
      return yield* pipe(changesUponFlatteningSafe(self.doc), map17(map24((doc) => annotate(doc, self.annotation))));
    }
  }
});
var annotate = /* @__PURE__ */ dual(2, (self, annotation) => {
  const op = Object.create(proto15);
  op._tag = "Annotated";
  op.doc = self;
  op.annotation = annotation;
  return op;
});
var spaces = (n) => {
  if (n <= 0) {
    return empty32;
  }
  if (n === 1) {
    return char(" ");
  }
  return text(textSpaces(n));
};
var textSpaces = (n) => {
  let s = "";
  for (let i = 0; i < n; i++) {
    s = s += " ";
  }
  return s;
};

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/docStream.js
var DocStreamSymbolKey = "@effect/printer/DocStream";
var DocStreamTypeId = /* @__PURE__ */ Symbol.for(DocStreamSymbolKey);
var protoHash3 = {
  FailedStream: (_) => pipe(string("@effect/printer/DocStream/FailedStream"), combine(string(DocStreamSymbolKey))),
  EmptyStream: (_) => pipe(string("@effect/printer/DocStream/EmptyStream"), combine(string(DocStreamSymbolKey))),
  CharStream: (self) => pipe(hash("@effect/printer/DocStream/CharStream"), combine(string(DocStreamSymbolKey)), combine(string(self.char)), combine(hash(self.stream))),
  TextStream: (self) => pipe(string("@effect/printer/DocStream/TextStream"), combine(string(DocStreamSymbolKey)), combine(string(self.text)), combine(hash(self.stream))),
  LineStream: (self) => pipe(string("@effect/printer/DocStream/LineStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.stream))),
  PushAnnotationStream: (self) => pipe(string("@effect/printer/DocStream/PopAnnotationStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.annotation)), combine(hash(self.stream))),
  PopAnnotationStream: (self) => pipe(string("@effect/printer/DocStream/PopAnnotationStream"), combine(string(DocStreamSymbolKey)), combine(hash(self.stream)))
};
var protoEqual3 = {
  FailedStream: (self, that) => isDocStream(that) && that._tag === "FailedStream",
  EmptyStream: (self, that) => isDocStream(that) && that._tag === "EmptyStream",
  CharStream: (self, that) => isDocStream(that) && that._tag === "CharStream" && self.char === that.char && equals(self.stream, that.stream),
  TextStream: (self, that) => isDocStream(that) && that._tag === "TextStream" && self.text === that.text && equals(self.stream, that.stream),
  LineStream: (self, that) => isDocStream(that) && that._tag === "LineStream" && equals(self.stream, that.stream),
  PushAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PushAnnotationStream" && equals(self.annotation, that.annotation) && equals(self.stream, that.stream),
  PopAnnotationStream: (self, that) => isDocStream(that) && that._tag === "PopAnnotationStream" && equals(self.stream, that.stream)
};
var proto16 = {
  [DocStreamTypeId]: {
    _A: (_) => _
  },
  [symbol]() {
    return cached(this, protoHash3[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual3[this._tag](this, that);
  }
};
var isDocStream = (u) => typeof u === "object" && u != null && DocStreamTypeId in u;
var isEmptyStream = (self) => self._tag === "EmptyStream";
var isLineStream = (self) => self._tag === "LineStream";
var failed = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto16);
  op._tag = "FailedStream";
  return op;
})();
var empty33 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto16);
  op._tag = "EmptyStream";
  return op;
})();
var char2 = /* @__PURE__ */ dual(2, (self, char4) => {
  const op = Object.create(proto16);
  op._tag = "CharStream";
  op.char = char4;
  op.stream = self;
  return op;
});
var text2 = /* @__PURE__ */ dual(2, (self, text9) => {
  const op = Object.create(proto16);
  op._tag = "TextStream";
  op.text = text9;
  op.stream = self;
  return op;
});
var line2 = /* @__PURE__ */ dual(2, (self, indentation) => {
  const op = Object.create(proto16);
  op._tag = "LineStream";
  op.indentation = indentation;
  op.stream = self;
  return op;
});
var pushAnnotation = /* @__PURE__ */ dual(2, (self, annotation) => {
  const op = Object.create(proto16);
  op._tag = "PushAnnotationStream";
  op.annotation = annotation;
  op.stream = self;
  return op;
});
var popAnnotation = (stream3) => {
  const op = Object.create(proto16);
  op._tag = "PopAnnotationStream";
  op.stream = stream3;
  return op;
};

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/layoutPipeline.js
var nil2 = {
  _tag: "Nil"
};
var cons2 = (indent3, document, pipeline) => ({
  _tag: "Cons",
  indent: indent3,
  document,
  pipeline
});
var undoAnnotation = (pipeline) => ({
  _tag: "UndoAnnotation",
  pipeline
});

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/pageWidth.js
var PageWidthSymbolKey = "@effect/printer/PageWidth";
var PageWidthTypeId = /* @__PURE__ */ Symbol.for(PageWidthSymbolKey);
var protoHash4 = {
  AvailablePerLine: (self) => pipe(hash("@effect/printer/PageWidth/AvailablePerLine"), combine(hash(PageWidthSymbolKey)), combine(hash(self.lineWidth)), combine(hash(self.ribbonFraction))),
  Unbounded: (_) => pipe(hash("@effect/printer/PageWidth/Unbounded"), combine(hash(PageWidthSymbolKey)))
};
var protoEqual4 = {
  AvailablePerLine: (self, that) => isPageWidth(that) && that._tag === "AvailablePerLine" && self.lineWidth === that.lineWidth && self.ribbonFraction === that.ribbonFraction,
  Unbounded: (self, that) => isPageWidth(that) && that._tag === "Unbounded"
};
var proto17 = {
  [PageWidthTypeId]: PageWidthTypeId,
  [symbol]() {
    return cached(this, protoHash4[this._tag](this));
  },
  [symbol2](that) {
    return protoEqual4[this._tag](this, that);
  }
};
var isPageWidth = (u) => typeof u === "object" && u != null && PageWidthTypeId in u;
var availablePerLine = (lineWidth, ribbonFraction) => {
  const op = Object.create(proto17);
  op._tag = "AvailablePerLine";
  op.lineWidth = lineWidth;
  op.ribbonFraction = ribbonFraction;
  return op;
};
var unbounded4 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto17);
  op._tag = "Unbounded";
  return op;
})();
var defaultPageWidth = /* @__PURE__ */ availablePerLine(80, 1);
var remainingWidth = (pageWidth3, ribbonFraction, indentation, currentColumn) => {
  const columnsLeftInLine = pageWidth3 - currentColumn;
  const ribbonWidth = Math.max(0, Math.min(pageWidth3, Math.floor(pageWidth3 * ribbonFraction)));
  const columnsLeftInRibbon = indentation + ribbonWidth - currentColumn;
  return Math.min(columnsLeftInLine, columnsLeftInRibbon);
};

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/layout.js
var options = (pageWidth3) => ({
  pageWidth: pageWidth3
});
var wadlerLeijen = /* @__PURE__ */ dual(3, (self, fits, options3) => runSync(wadlerLeijenSafe(cons2(0, self, nil2), 0, 0, fits, options3)));
var wadlerLeijenSafe = (self, nestingLevel, currentColumn, fits, options3) => {
  const best = (self2, nl, cc) => gen2(function* () {
    switch (self2._tag) {
      case "Nil": {
        return empty33;
      }
      case "Cons": {
        switch (self2.document._tag) {
          case "Fail": {
            return failed;
          }
          case "Empty": {
            return yield* best(self2.pipeline, nl, cc);
          }
          case "Char": {
            const stream3 = yield* best(self2.pipeline, nl, cc + 1);
            return char2(stream3, self2.document.char);
          }
          case "Text": {
            const length3 = self2.document.text.length;
            const stream3 = yield* best(self2.pipeline, nl, cc + length3);
            return text2(stream3, self2.document.text);
          }
          case "Line": {
            const stream3 = yield* best(self2.pipeline, self2.indent, self2.indent);
            const nextIndent = isEmptyStream(stream3) || isLineStream(stream3) ? 0 : self2.indent;
            return line2(stream3, nextIndent);
          }
          case "FlatAlt": {
            const next = cons2(self2.indent, self2.document.left, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Cat": {
            const inner = cons2(self2.indent, self2.document.right, self2.pipeline);
            const outer = cons2(self2.indent, self2.document.left, inner);
            return yield* best(outer, nl, cc);
          }
          case "Nest": {
            const indent3 = self2.indent + self2.document.indent;
            const next = cons2(indent3, self2.document.doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Union": {
            const leftPipeline = cons2(self2.indent, self2.document.left, self2.pipeline);
            const rightPipeline = cons2(self2.indent, self2.document.right, self2.pipeline);
            const left3 = best(leftPipeline, nl, cc);
            const right3 = best(rightPipeline, nl, cc);
            return selectNicer(fits, nl, cc, left3, right3);
          }
          case "Column": {
            const doc = self2.document.react(cc);
            const next = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "WithPageWidth": {
            const doc = self2.document.react(options3.pageWidth);
            const next = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Nesting": {
            const doc = self2.document.react(self2.indent);
            const next = cons2(self2.indent, doc, self2.pipeline);
            return yield* best(next, nl, cc);
          }
          case "Annotated": {
            const undo = undoAnnotation(self2.pipeline);
            const next = cons2(self2.indent, self2.document.doc, undo);
            const stream3 = yield* best(next, nl, cc);
            return pushAnnotation(stream3, self2.document.annotation);
          }
        }
      }
      case "UndoAnnotation": {
        const stream3 = yield* best(self2.pipeline, nestingLevel, currentColumn);
        return popAnnotation(stream3);
      }
    }
  });
  return best(self, nestingLevel, currentColumn);
};
var selectNicer = (fits, lineIndent, currentColumn, left3, right3) => {
  const leftStream = runSync(left3);
  let rightStream = void 0;
  return fits(leftStream, lineIndent, currentColumn, () => rightStream ?? (rightStream = runSync(right3), rightStream)) ? leftStream : rightStream ?? runSync(right3);
};
var compact2 = (self) => runSync(compactSafe(of3(self), 0));
var compactSafe = (docs, i) => gen2(function* () {
  if (isNil(docs)) {
    return empty33;
  }
  const head5 = docs.head;
  const tail = docs.tail;
  switch (head5._tag) {
    case "Fail": {
      return failed;
    }
    case "Empty": {
      return yield* compactSafe(tail, i);
    }
    case "Char": {
      const stream3 = yield* compactSafe(tail, i + 1);
      return char2(stream3, head5.char);
    }
    case "Text": {
      const stream3 = yield* compactSafe(tail, i + head5.text.length);
      return text2(stream3, head5.text);
    }
    case "Line": {
      const stream3 = yield* compactSafe(tail, 0);
      return line2(stream3, 0);
    }
    case "FlatAlt": {
      return yield* compactSafe(cons(head5.left, tail), i);
    }
    case "Cat": {
      const list4 = cons(head5.left, cons(head5.right, tail));
      return yield* compactSafe(list4, i);
    }
    case "Nest": {
      return yield* compactSafe(cons(head5.doc, tail), i);
    }
    case "Union": {
      return yield* compactSafe(cons(head5.right, tail), i);
    }
    case "Column": {
      return yield* compactSafe(cons(head5.react(i), tail), i);
    }
    case "WithPageWidth": {
      return yield* compactSafe(cons(head5.react(unbounded4), tail), i);
    }
    case "Nesting": {
      return yield* compactSafe(cons(head5.react(0), tail), i);
    }
    case "Annotated": {
      return yield* compactSafe(cons(head5.doc, tail), i);
    }
  }
});
var pretty4 = /* @__PURE__ */ dual(2, (self, options3) => {
  const width3 = options3.pageWidth;
  if (width3._tag === "AvailablePerLine") {
    return wadlerLeijen(self, (stream3, indentation, currentColumn) => {
      const remainingWidth2 = remainingWidth(width3.lineWidth, width3.ribbonFraction, indentation, currentColumn);
      return fitsPretty(stream3, remainingWidth2);
    }, options3);
  }
  return unbounded5(self);
});
var fitsPretty = (self, width3) => {
  let w = width3;
  let stream3 = self;
  while (w >= 0) {
    switch (stream3._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream3 = stream3.stream;
        break;
      }
      case "TextStream": {
        w = w - stream3.text.length;
        stream3 = stream3.stream;
        break;
      }
      case "LineStream": {
        return true;
      }
      case "PushAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
    }
  }
  return false;
};
var smart = /* @__PURE__ */ dual(2, (self, options3) => {
  const width3 = options3.pageWidth;
  if (width3._tag === "AvailablePerLine") {
    return wadlerLeijen(self, fitsSmart(width3.lineWidth, width3.ribbonFraction), options3);
  }
  return unbounded5(self);
});
var fitsSmart = (pageWidth3, ribbonFraction) => {
  return (stream3, indentation, currentColumn, comparator) => {
    const availableWidth = remainingWidth(pageWidth3, ribbonFraction, indentation, currentColumn);
    return fitsSmartLoop(stream3, comparator, pageWidth3, currentColumn, availableWidth);
  };
};
var fitsSmartLoop = (self, comparator, pageWidth3, currentColumn, availableWidth) => {
  let minNestingLevel;
  let stream3 = self;
  let w = availableWidth;
  while (w >= 0) {
    switch (stream3._tag) {
      case "FailedStream": {
        return false;
      }
      case "EmptyStream": {
        return true;
      }
      case "CharStream": {
        w = w - 1;
        stream3 = stream3.stream;
        break;
      }
      case "TextStream": {
        w = w - stream3.text.length;
        stream3 = stream3.stream;
        break;
      }
      case "LineStream": {
        if (!minNestingLevel) {
          minNestingLevel = match2(getInitialIndentation(comparator()), {
            // Definitely not a hanging layout. Return the same `minNestingLevel` that
            // subsequent lines with the same indentation use
            onNone: () => currentColumn,
            // Could be a (less wide) hanging layout, so take the minimum of the indent
            // and the current column
            onSome: (value5) => Math.min(value5, currentColumn)
          });
        }
        if (minNestingLevel < stream3.indentation) {
          return false;
        }
        w = pageWidth3 - stream3.indentation;
        stream3 = stream3.stream;
        break;
      }
      case "PushAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
    }
  }
  return false;
};
var getInitialIndentation = (self) => {
  let stream3 = self;
  while (stream3._tag === "LineStream" || stream3._tag === "PushAnnotationStream" || stream3._tag === "PopAnnotationStream") {
    if (stream3._tag === "LineStream") {
      return some2(stream3.indentation);
    }
    stream3 = stream3.stream;
  }
  return none2();
};
var unbounded5 = (self) => wadlerLeijen(self, (stream3) => !failsOnFirstLine(stream3), {
  pageWidth: unbounded4
});
var failsOnFirstLine = (self) => {
  let stream3 = self;
  while (1) {
    switch (stream3._tag) {
      case "FailedStream": {
        return true;
      }
      case "EmptyStream": {
        return false;
      }
      case "CharStream": {
        stream3 = stream3.stream;
        break;
      }
      case "TextStream": {
        stream3 = stream3.stream;
        break;
      }
      case "LineStream": {
        return false;
      }
      case "PushAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
      case "PopAnnotationStream": {
        stream3 = stream3.stream;
        break;
      }
    }
  }
  throw new Error("bug");
};

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/Doc.js
var char3 = char;
var text3 = text;
var empty34 = empty32;
var hardLine2 = hardLine;
var space2 = space;
var cat2 = cat;
var cats2 = cats;
var hsep2 = hsep;
var vsep2 = vsep;
var nest2 = nest;
var align2 = align;
var indent2 = indent;
var annotate2 = annotate;

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/internal/ansiDoc.js
var beep2 = /* @__PURE__ */ annotate2(empty34, beep);
var cursorTo2 = (column3, row) => annotate2(empty34, cursorTo(column3, row));
var cursorMove2 = (column3, row) => annotate2(empty34, cursorMove(column3, row));
var cursorDown2 = (lines3 = 1) => annotate2(empty34, cursorDown(lines3));
var cursorLeft2 = /* @__PURE__ */ annotate2(empty34, cursorLeft);
var cursorSavePosition2 = /* @__PURE__ */ annotate2(empty34, cursorSavePosition);
var cursorRestorePosition2 = /* @__PURE__ */ annotate2(empty34, cursorRestorePosition);
var cursorHide2 = /* @__PURE__ */ annotate2(empty34, cursorHide);
var cursorShow2 = /* @__PURE__ */ annotate2(empty34, cursorShow);
var eraseLines2 = (rows) => annotate2(empty34, eraseLines(rows));
var eraseLine2 = /* @__PURE__ */ annotate2(empty34, eraseLine);

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/PageWidth.js
var defaultPageWidth2 = defaultPageWidth;

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/Layout.js
var options2 = options;
var compact3 = compact2;
var pretty5 = pretty4;
var smart2 = smart;

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/internal/ansiRender.js
var render2 = /* @__PURE__ */ dual(2, (self, config2) => {
  switch (config2.style) {
    case "compact": {
      return renderStream(compact3(self));
    }
    case "pretty": {
      const width3 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream(pretty5(self, options2(width3)));
    }
    case "smart": {
      const width3 = Object.assign({}, defaultPageWidth2, config2.options);
      return renderStream(smart2(self, options2(width3)));
    }
  }
});
var renderStream = (self) => runSync(renderSafe(self, of3(none9)));
var unsafePeek = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePeek - peeked at an empty stack - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return stack.head;
};
var unsafePop = (stack) => {
  if (isNil(stack)) {
    throw new Error("BUG: AnsiRender.unsafePop - popped from an empty stack - please report an issue at https://github.com/Effect-TS/printer/issues");
  }
  return [stack.head, stack.tail];
};
var renderSafe = (self, stack) => {
  switch (self._tag) {
    case "FailedStream": {
      return dieMessage2("BUG: AnsiRender.renderSafe - attempted to render a failed doc stream - please report an issue at https://github.com/Effect-TS/printer/issues");
    }
    case "EmptyStream": {
      return succeed8("");
    }
    case "CharStream": {
      return map17(suspend5(() => renderSafe(self.stream, stack)), (rest) => self.char + rest);
    }
    case "TextStream": {
      return map17(suspend5(() => renderSafe(self.stream, stack)), (rest) => self.text + rest);
    }
    case "LineStream": {
      let indent3 = "\n";
      for (let i = 0; i < self.indentation; i++) {
        indent3 = indent3 += " ";
      }
      return map17(suspend5(() => renderSafe(self.stream, stack)), (rest) => indent3 + rest);
    }
    case "PushAnnotationStream": {
      const currentStyle = unsafePeek(stack);
      const nextStyle = combine10(self.annotation, currentStyle);
      return map17(suspend5(() => renderSafe(self.stream, cons(self.annotation, stack))), (rest) => stringify(nextStyle) + rest);
    }
    case "PopAnnotationStream": {
      const [, styles] = unsafePop(stack);
      const nextStyle = unsafePeek(styles);
      return map17(suspend5(() => renderSafe(self.stream, styles)), (rest) => stringify(nextStyle) + rest);
    }
  }
};

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/AnsiDoc.js
var beep3 = beep2;
var cursorTo3 = cursorTo2;
var cursorMove3 = cursorMove2;
var cursorDown3 = cursorDown2;
var cursorLeft3 = cursorLeft2;
var cursorSavePosition3 = cursorSavePosition2;
var cursorRestorePosition3 = cursorRestorePosition2;
var cursorHide3 = cursorHide2;
var cursorShow3 = cursorShow2;
var eraseLines3 = eraseLines2;
var eraseLine3 = eraseLine2;
var render3 = render2;

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/internal/optimize.js
var optimize2 = /* @__PURE__ */ dual(2, (self, depth) => runSync(optimizeSafe(self, depth)));
var optimizeSafe = (self, depth) => {
  const optimize4 = (self2) => gen2(function* () {
    switch (self2._tag) {
      case "Fail":
      case "Empty":
      case "Char":
      case "Text":
      case "Line": {
        return self2;
      }
      case "FlatAlt": {
        const left3 = yield* optimize4(self2.left);
        const right3 = yield* optimize4(self2.right);
        return flatAlt(left3, right3);
      }
      case "Cat": {
        if (isEmpty11(self2.left)) {
          return yield* optimize4(self2.right);
        }
        if (isEmpty11(self2.right)) {
          return yield* optimize4(self2.left);
        }
        if (isChar(self2.left) && isChar(self2.right)) {
          return text(self2.left.char + self2.right.char);
        }
        if (isText(self2.left) && isChar(self2.right)) {
          return text(self2.left.text + self2.right.char);
        }
        if (isChar(self2.left) && isText(self2.right)) {
          return text(self2.left.char + self2.right.text);
        }
        if (isText(self2.left) && isText(self2.right)) {
          return text(self2.left.text + self2.right.text);
        }
        if (isChar(self2.left) && isCat(self2.right) && isChar(self2.right.left) || isChar(self2.left) && isCat(self2.right) && isText(self2.right.left) || isText(self2.left) && isCat(self2.right) && isChar(self2.right.left) || isText(self2.left) && isCat(self2.right) && isText(self2.right.left)) {
          const inner = yield* optimize4(cat(self2.left, self2.right.left));
          return yield* optimize4(cat(inner, self2.right.right));
        }
        if (isCat(self2.left) && isChar(self2.left.right) || isCat(self2.left) && isText(self2.left.right)) {
          const inner = yield* optimize4(cat(self2.left.right, self2.right));
          return yield* optimize4(cat(self2.left.left, inner));
        }
        const left3 = yield* optimize4(self2.left);
        const right3 = yield* optimize4(self2.right);
        return cat(left3, right3);
      }
      case "Nest": {
        if (self2.indent === 0) {
          return yield* optimize4(self2.doc);
        }
        if (isEmpty11(self2.doc) || isChar(self2.doc) || isText(self2.doc)) {
          return self2.doc;
        }
        if (isNest(self2.doc)) {
          const indent3 = self2.indent + self2.doc.indent;
          return yield* optimize4(nest(self2.doc.doc, indent3));
        }
        return nest(yield* optimize4(self2.doc), self2.indent);
      }
      case "Union": {
        const left3 = yield* optimize4(self2.left);
        const right3 = yield* optimize4(self2.right);
        return union9(left3, right3);
      }
      case "Column": {
        return depth._tag === "Shallow" ? self2 : column((position) => runSync(optimizeSafe(self2.react(position), depth)));
      }
      case "WithPageWidth": {
        return depth._tag === "Shallow" ? self2 : pageWidth((pageWidth3) => runSync(optimizeSafe(self2.react(pageWidth3), depth)));
      }
      case "Nesting": {
        return depth._tag === "Shallow" ? self2 : nesting((level) => runSync(optimizeSafe(self2.react(level), depth)));
      }
      case "Annotated": {
        return annotate(yield* optimize4(self2.doc), self2.annotation);
      }
    }
  });
  return optimize4(self);
};

// node_modules/.pnpm/@effect+printer@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer/dist/esm/Optimize.js
var Deep = {
  _tag: "Deep"
};
var optimize3 = optimize2;

// node_modules/.pnpm/@effect+printer-ansi@0.43.2_@effect+typeclass@0.34.2_effect@3.15.2__effect@3.15.2/node_modules/@effect/printer-ansi/dist/esm/Color.js
var red4 = red;
var magenta3 = magenta;
var cyan3 = cyan;
var white4 = white;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/helpDoc/span.js
var text4 = (value5) => ({
  _tag: "Text",
  value: value5
});
var empty35 = /* @__PURE__ */ text4("");
var space3 = /* @__PURE__ */ text4(" ");
var code = (value5) => highlight(value5, white4);
var error3 = (value5) => highlight(value5, red4);
var highlight = (value5, color3) => ({
  _tag: "Highlight",
  value: typeof value5 === "string" ? text4(value5) : value5,
  color: color3
});
var strong = (value5) => ({
  _tag: "Strong",
  value: typeof value5 === "string" ? text4(value5) : value5
});
var weak = (value5) => ({
  _tag: "Weak",
  value: typeof value5 === "string" ? text4(value5) : value5
});
var isText3 = (self) => self._tag === "Text";
var concat3 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Sequence",
  left: self,
  right: that
}));
var getText = (self) => {
  switch (self._tag) {
    case "Text":
    case "URI": {
      return self.value;
    }
    case "Highlight":
    case "Weak":
    case "Strong": {
      return getText(self.value);
    }
    case "Sequence": {
      return getText(self.left) + getText(self.right);
    }
  }
};
var spans = (spans2) => {
  const elements = fromIterable(spans2);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(concat3, elements[0]);
  }
  return empty35;
};
var isEmpty13 = (self) => size12(self) === 0;
var size12 = (self) => {
  switch (self._tag) {
    case "Text":
    case "URI": {
      return self.value.length;
    }
    case "Highlight":
    case "Strong":
    case "Weak": {
      return size12(self.value);
    }
    case "Sequence": {
      return size12(self.left) + size12(self.right);
    }
  }
};
var toAnsiDoc = (self) => {
  switch (self._tag) {
    case "Highlight": {
      return annotate2(toAnsiDoc(self.value), color2(self.color));
    }
    case "Sequence": {
      return cat2(toAnsiDoc(self.left), toAnsiDoc(self.right));
    }
    case "Strong": {
      return annotate2(toAnsiDoc(self.value), bold2);
    }
    case "Text": {
      return text3(self.value);
    }
    case "URI": {
      return annotate2(text3(self.value), underlined2);
    }
    case "Weak": {
      return annotate2(toAnsiDoc(self.value), black3);
    }
  }
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/helpDoc.js
var isEmpty14 = (helpDoc) => helpDoc._tag === "Empty";
var isHeader = (helpDoc) => helpDoc._tag === "Header";
var isParagraph = (helpDoc) => helpDoc._tag === "Paragraph";
var isDescriptionList = (helpDoc) => helpDoc._tag === "DescriptionList";
var empty36 = {
  _tag: "Empty"
};
var sequence = /* @__PURE__ */ dual(2, (self, that) => {
  if (isEmpty14(self)) {
    return that;
  }
  if (isEmpty14(that)) {
    return self;
  }
  return {
    _tag: "Sequence",
    left: self,
    right: that
  };
});
var blocks = (helpDocs) => {
  const elements = fromIterable(helpDocs);
  if (isNonEmptyReadonlyArray(elements)) {
    return elements.slice(1).reduce(sequence, elements[0]);
  }
  return empty36;
};
var getSpan = (self) => isHeader(self) || isParagraph(self) ? self.value : empty35;
var descriptionList = (definitions) => ({
  _tag: "DescriptionList",
  definitions
});
var enumeration = (elements) => ({
  _tag: "Enumeration",
  elements
});
var h1 = (value5) => ({
  _tag: "Header",
  value: typeof value5 === "string" ? text4(value5) : value5,
  level: 1
});
var p = (value5) => ({
  _tag: "Paragraph",
  value: typeof value5 === "string" ? text4(value5) : value5
});
var mapDescriptionList = /* @__PURE__ */ dual(2, (self, f) => isDescriptionList(self) ? descriptionList(map3(self.definitions, ([span2, helpDoc]) => f(span2, helpDoc))) : self);
var toAnsiDoc2 = (self) => optimize3(toAnsiDocInternal(self), Deep);
var toAnsiText = (self) => render3(toAnsiDoc2(self), {
  style: "pretty"
});
var toAnsiDocInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty34;
    }
    case "Header": {
      return pipe(annotate2(toAnsiDoc(self.value), bold2), cat2(hardLine2));
    }
    case "Paragraph": {
      return pipe(toAnsiDoc(self.value), cat2(hardLine2));
    }
    case "DescriptionList": {
      const definitions = self.definitions.map(([span2, doc]) => cats2([annotate2(toAnsiDoc(span2), bold2), empty34, indent2(toAnsiDocInternal(doc), 2)]));
      return vsep2(definitions);
    }
    case "Enumeration": {
      const elements = self.elements.map((doc) => cat2(text3("- "), toAnsiDocInternal(doc)));
      return indent2(vsep2(elements), 2);
    }
    case "Sequence": {
      return vsep2([toAnsiDocInternal(self.left), toAnsiDocInternal(self.right)]);
    }
  }
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Redacted.js
var make52 = make24;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Struct.js
var pick2 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys5) => {
  const out2 = {};
  for (const k of keys5) {
    if (k in s) {
      out2[k] = s[k];
    }
  }
  return out2;
});
var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys5) => {
  const out2 = {
    ...s
  };
  for (const k of keys5) {
    delete out2[k];
  }
  return out2;
});

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Schema.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make53(ast) {
  return class SchemaClass {
    [TypeId16] = variance5;
    static ast = ast;
    static annotations(annotations2) {
      return make53(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId16] = variance5;
  };
}
var variance5 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out2 = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out2[id2] = annotations2[key];
      delete out2[key];
    }
  }
  return out2;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
function asSchema(schema) {
  return schema;
}
var format4 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make53(encodedAST(schema.ast));
var typeSchema = (schema) => make53(typeAST(schema.ast));
var decodeUnknown2 = (schema, options3) => {
  const decodeUnknown3 = decodeUnknown(schema, options3);
  return (u, overrideOptions) => mapError3(decodeUnknown3(u, overrideOptions), parseError);
};
var isSchema = (u) => hasProperty(u, TypeId16) && isObject(u[TypeId16]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make53(ast) {
    static annotations(annotations2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var declareConstructor = (typeParameters, options3, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options3.decode(...typeParameters2.map(make53)), (...typeParameters2) => options3.encode(...typeParameters2.map(make53)), toASTAnnotations(annotations2)));
var declarePrimitive = (is3, annotations2) => {
  const decodeUnknown3 = () => (input, _, ast) => is3(input) ? succeed9(input) : fail9(new Type2(ast, input));
  const encodeUnknown2 = decodeUnknown3;
  return makeDeclareClass([], new Declaration([], decodeUnknown3, encodeUnknown2, toASTAnnotations(annotations2)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make53(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options3 = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options3, annotations3);
  }
  const is3 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is3, annotations2);
};
var Never = class extends (/* @__PURE__ */ make53(neverKeyword)) {
};
var Unknown = class extends (/* @__PURE__ */ make53(unknownKeyword)) {
};
var String$ = class extends (/* @__PURE__ */ make53(stringKeyword)) {
};
var Number$ = class extends (/* @__PURE__ */ make53(numberKeyword)) {
};
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make53(ast) {
    static annotations(annotations2) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration = class extends OptionalType {
  isReadonly;
  defaultValue;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type2, isOptional, isReadonly, annotations2, defaultValue) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type2 = String(this.type);
    return `PropertySignature<${token}, ${type2}, never, ${token}, ${type2}>`;
  }
};
var ToPropertySignature = class extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type2, isOptional, isReadonly, annotations2, defaultValue) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = (p2) => {
  if (p2 === void 0) {
    return "never";
  }
  if (isString(p2)) {
    return JSON.stringify(p2);
  }
  return String(p2);
};
var PropertySignatureTransformation2 = class {
  from;
  to;
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode2, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode2;
    this.encode = encode;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = (ast, annotations2) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations2
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations2
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var PropertySignatureImpl = class _PropertySignatureImpl {
  ast;
  [TypeId16];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations2) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
  }
  toString() {
    return String(this.ast);
  }
};
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations2) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
  }
};
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys2 = ownKeys(fields);
  const pss = [];
  if (ownKeys2.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys2.length; i++) {
      const key = ownKeys2[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type2 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type2, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type2), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type2, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is3) => {
          issFrom.push(is3);
          issTo.push(new IndexSignature(is3.parameter, typeAST(is3.type), is3.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is3) => iss.push(is3));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out2) => {
  const ownKeys2 = ownKeys(fields);
  for (const key of ownKeys2) {
    const field = fields[key];
    if (out2[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out2[key] = defaultValue();
      }
    }
  }
  return out2;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make53(ast) {
    static annotations(annotations2) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options3) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options3) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys5) {
      return Struct(pick2(fields, ...keys5));
    }
    static omit(...keys5) {
      return Struct(omit3(fields, ...keys5));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var intersectTypeLiterals = (x, y, path2) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name2 = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name2);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type2
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name2, extendAST(type2, ps.type, path2.concat(name2)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path2));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path2) => Union.make(intersectUnionMembers([x], [y], path2));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path2) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path2);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path2))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path2));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path2);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path2))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path2)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path2);
          const to = intersectTypeLiterals(x.to, typeAST(y), path2);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options3, ast, fromI) => map18(transformation.decode(fromA, options3, ast, fromI), (partial2) => ({
                ...fromA,
                ...partial2
              })), (toI, options3, ast, toA) => map18(transformation.encode(toI, options3, ast, toA), (partial2) => ({
                ...toI,
                ...partial2
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path2), intersectTypeLiterals(x.to, y.to, path2), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path2);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path2));
}));
var extend3 = /* @__PURE__ */ dual(2, (self, that) => make53(extendAST(self.ast, that.ast, [])));
var compose3 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose(from.ast, to.ast)));
var suspend10 = (f) => make53(new Suspend(() => f().ast));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter11, ast) {
  return class RefineClass extends make53(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter11;
    static make = (a, options3) => {
      return getDisableValidationMakeOption(options3) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out2, ast, input) => {
  if (isSingle(out2)) {
    return fromFilterPredicateReturnTypeItem(out2, ast, input);
  }
  if (isNonEmptyReadonlyArray(out2)) {
    const issues = filterMap2(out2, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter10(predicate, annotations2) {
  return (self) => {
    function filter11(input, options3, ast2) {
      return toFilterParseIssue(predicate(input, options3, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter11, toASTAnnotations(annotations2));
    return makeRefineClass(self, filter11, ast);
  };
}
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make53(ast) {
    static annotations(annotations2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options3) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options3.decode, options3.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options3) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed9(options3.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed9(options3.encode(toI, toA))
}));
var IntSchemaId2 = IntSchemaId;
var int = (annotations2) => (self) => self.pipe(filter10((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations2
}));
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption3(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed9(String(a))
  });
}
var NumberFromString = class extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
};
var Int = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
};
var toComposite = (eff, onSuccess, ast, actual) => mapBoth5(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations2) => (self) => self.pipe(filter10((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations2
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date5) => `new Date(${JSON.stringify(date5)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
};
var DateFromString = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
};
var Date$ = class extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var getClassTag = (tag4) => withConstructorDefault(propertySignature(Literal2(tag4)), () => tag4);
var TaggedError2 = (identifier3) => (tag4, fieldsOr, annotations2) => {
  class Base3 extends Error3 {
  }
  Base3.prototype.name = tag4;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag4)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: tag4,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations2,
    disableToString: true
  }) {
    static _tag = tag4;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${ownKeys(fields).map((p2) => `${formatPropertyKey(p2)}: ${formatUnknown(this[p2])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out2 = {
    ...a
  };
  for (const key of ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out2[key] = b[key];
  }
  return out2;
};
function getDisableValidationMakeOption(options3) {
  return isBoolean(options3) ? options3 : options3?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations2) => {
  if (annotations2 === void 0) {
    return [];
  } else if (Array.isArray(annotations2)) {
    return annotations2;
  } else {
    return [annotations2];
  }
};
var makeClass = ({
  Base: Base3,
  annotations: annotations2,
  disableToString,
  fields,
  identifier: identifier3,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier3}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations2);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier3,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier3} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier3} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier3} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [JSONIdentifierAnnotationId]: identifier3,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = class extends Base3 {
    constructor(props = {}, options3 = false) {
      props = {
        ...props
      };
      {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options3)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId16] = variance5;
    static get ast() {
      let out2 = astCache.get(this);
      if (out2) {
        return out2;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed9(input) : fail9(new Type2(ast, input)),
        encode: () => (input, options3) => input instanceof this ? succeed9(input) : map18(encodeUnknown(typeSide)(input, options3), (props) => new this(props, true))
      }, {
        identifier: identifier3,
        pretty: (pretty6) => (self) => `${identifier3}(${pretty6(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out2 = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out2);
      return out2;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations3) {
      return make53(this.ast).annotations(annotations3);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier3})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier3;
    static extend(identifier4) {
      return (newFieldsOr, annotations3) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier4,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    static transformOrFail(identifier4) {
      return (newFieldsOr, options3, annotations3) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier4,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    static transformOrFailFrom(identifier4) {
      return (newFields, options3, annotations3) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier4,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options3),
          fields: transformedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier3}({ ${ownKeys(fields).map((p2) => `${formatPropertyKey(p2)}: ${formatUnknown(this[p2])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend10(() => FiberIdEncoded),
  right: suspend10(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId2) => {
  switch (fiberId2._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId2.id}, ${fiberId2.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId2.right)}, ${fiberIdPretty(fiberId2.left)})`;
  }
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = (error4) => Struct({
  _tag: Literal2("Fail"),
  error: error4
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error4, defect) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const suspended3 = suspend10(() => out2);
  const out2 = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format4(error4)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out2;
};
var causeArbitrary = (error4, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error4(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error4) => (cause2) => {
  const f = (cause3) => {
    switch (cause3._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error4(cause3.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause3)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause3.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause3.left)}, ${f(cause3.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause3.left)}, ${f(cause3.right)})`;
    }
  };
  return f(cause2);
};
var causeParse = (decodeUnknown3) => (u, options3, ast) => isCause2(u) ? toComposite(decodeUnknown3(causeEncode(u), options3), causeDecode, ast, u) : fail9(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error4
}) => {
  return declare([error4, defect], {
    decode: (error5, defect2) => causeParse(decodeUnknown(causeEncoded(error5, defect2))),
    encode: (error5, defect2) => causeParse(encodeUnknown(causeEncoded(error5, defect2)))
  }, {
    title: `Cause<${error4.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return empty25;
    case "Fail":
      return fail6(cause2.error);
    case "Die":
      return die4(cause2.defect);
    case "Interrupt":
      return interrupt4(fiberIdDecode(cause2.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause2.left), causeDecode(cause2.right));
    case "Parallel":
      return parallel4(causeDecode(cause2.left), causeDecode(cause2.right));
  }
}
function causeEncode(cause2) {
  switch (cause2._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause2.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause2.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause2.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause2.left),
        right: causeEncode(cause2.right)
      };
  }
}
var Cause = ({
  defect,
  error: error4
}) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const out2 = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out2;
};
var Defect = class extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return String(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Secret.js
var fromString2 = fromString;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/terminal.js
var tag2 = /* @__PURE__ */ GenericTag("@effect/platform/Terminal");

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Terminal.js
var QuitException = class extends (/* @__PURE__ */ TaggedError("QuitException")) {
};
var Terminal = tag2;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/action.js
var Action = /* @__PURE__ */ taggedEnum();

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt.js
var PromptSymbolKey = "@effect/cli/Prompt";
var PromptTypeId = /* @__PURE__ */ Symbol.for(PromptSymbolKey);
var proto18 = {
  ...CommitPrototype2,
  [PromptTypeId]: {
    _Output: (_) => _
  },
  commit() {
    return run5(this);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrompt = (u) => typeof u === "object" && u != null && PromptTypeId in u;
var custom2 = (initialState3, handlers) => {
  const op = Object.create(proto18);
  op._tag = "Loop";
  op.initialState = initialState3;
  op.render = handlers.render;
  op.process = handlers.process;
  op.clear = handlers.clear;
  return op;
};
var map27 = /* @__PURE__ */ dual(2, (self, f) => flatMap17(self, (a) => succeed15(f(a))));
var flatMap17 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto18);
  op._tag = "OnSuccess";
  op.prompt = self;
  op.onSuccess = f;
  return op;
});
var run5 = (self) => flatMap9(Terminal, (terminal) => {
  const op = self;
  switch (op._tag) {
    case "Loop": {
      const makeStateRef = isEffect2(op.initialState) ? op.initialState.pipe(flatMap9(make28)) : make28(op.initialState);
      return makeStateRef.pipe(
        flatMap9((ref) => {
          const loop2 = (action) => get11(ref).pipe(flatMap9((state) => op.render(state, action).pipe(flatMap9((msg) => orDie2(terminal.display(msg))), zipRight3(terminal.readInput), flatMap9((input) => op.process(input, state)), flatMap9((action2) => {
            switch (action2._tag) {
              case "Beep": {
                return loop2(action2);
              }
              case "NextFrame": {
                return op.clear(state, action2).pipe(flatMap9((clear2) => orDie2(terminal.display(clear2))), zipRight3(set5(ref, action2.state)), zipRight3(loop2(action2)));
              }
              case "Submit": {
                return op.clear(state, action2).pipe(flatMap9((clear2) => orDie2(terminal.display(clear2))), zipRight3(op.render(state, action2)), flatMap9((msg) => orDie2(terminal.display(msg))), zipRight3(succeed8(action2.value)));
              }
            }
          }))));
          return get11(ref).pipe(flatMap9((state) => loop2(Action.NextFrame({
            state
          }))));
        }),
        // Always make sure to restore the display of the cursor
        ensuring2(orDie2(terminal.display(render3(cursorShow3, {
          style: "pretty"
        }))))
      );
    }
    case "OnSuccess": {
      return flatMap9(run5(op.prompt), (a) => run5(op.onSuccess(a)));
    }
    case "Succeed": {
      return succeed8(op.value);
    }
  }
});
var succeed15 = (value5) => {
  const op = Object.create(proto18);
  op._tag = "Succeed";
  op.value = value5;
  return op;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/matcher.js
var TypeId17 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var ValueMatcherProto = {
  [TypeId17]: {
    _input: identity,
    _filters: identity,
    _result: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value5) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value5;
  return matcher;
}
var makeWhen = (guard, evaluate2) => ({
  _tag: "When",
  guard,
  evaluate: evaluate2
});
var makePredicate = (pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p2]) => [k, makePredicate(p2)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
};
var value3 = (i) => makeValueMatcher(i, left2(i));
var when4 = (pattern2, f) => (self) => self.add(makeWhen(makePredicate(pattern2), f));
var orElse11 = (f) => (self) => {
  const result = either6(self);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var either6 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case = self.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right2(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right2(_case.evaluate(input));
      }
    }
    return left2(input);
  };
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Match.js
var value4 = value3;
var when5 = when4;
var orElse12 = orElse11;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/ansi-utils.js
var defaultFigures = {
  arrowUp: /* @__PURE__ */ text3("\u2191"),
  arrowDown: /* @__PURE__ */ text3("\u2193"),
  arrowLeft: /* @__PURE__ */ text3("\u2190"),
  arrowRight: /* @__PURE__ */ text3("\u2192"),
  radioOn: /* @__PURE__ */ text3("\u25C9"),
  radioOff: /* @__PURE__ */ text3("\u25EF"),
  checkboxOn: /* @__PURE__ */ text3("\u2612"),
  checkboxOff: /* @__PURE__ */ text3("\u2610"),
  tick: /* @__PURE__ */ text3("\u2714"),
  cross: /* @__PURE__ */ text3("\u2716"),
  ellipsis: /* @__PURE__ */ text3("\u2026"),
  pointerSmall: /* @__PURE__ */ text3("\u203A"),
  line: /* @__PURE__ */ text3("\u2500"),
  pointer: /* @__PURE__ */ text3("\u276F")
};
var windowsFigures = {
  arrowUp: defaultFigures.arrowUp,
  arrowDown: defaultFigures.arrowDown,
  arrowLeft: defaultFigures.arrowLeft,
  arrowRight: defaultFigures.arrowRight,
  radioOn: /* @__PURE__ */ text3("(*)"),
  radioOff: /* @__PURE__ */ text3("( )"),
  checkboxOn: /* @__PURE__ */ text3("[*]"),
  checkboxOff: /* @__PURE__ */ text3("[ ]"),
  tick: /* @__PURE__ */ text3("\u221A"),
  cross: /* @__PURE__ */ text3("\xD7"),
  ellipsis: /* @__PURE__ */ text3("..."),
  pointerSmall: /* @__PURE__ */ text3("\xBB"),
  line: /* @__PURE__ */ text3("\u2500"),
  pointer: /* @__PURE__ */ text3(">")
};
var figures = /* @__PURE__ */ map17(/* @__PURE__ */ sync5(() => process.platform === "win32"), (isWindows) => isWindows ? windowsFigures : defaultFigures);
function eraseText(text9, columns) {
  if (columns === 0) {
    return cat2(eraseLine3, cursorTo3(0));
  }
  let rows = 0;
  const lines3 = text9.split(/\r?\n/);
  for (const line4 of lines3) {
    rows += 1 + Math.floor(Math.max(line4.length - 1, 0) / columns);
  }
  return eraseLines3(rows);
}
function lines(prompt3, columns) {
  const lines3 = prompt3.split(/\r?\n/);
  return columns === 0 ? lines3.length : pipe(map3(lines3, (line4) => Math.ceil(line4.length / columns)), reduce(0, (left3, right3) => left3 + right3));
}

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/date.js
var renderBeep = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty34,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX = /\r?\n/;
function renderError(state, pointer) {
  return match2(state.error, {
    onNone: () => empty34,
    onSome: (error4) => {
      const errorLines = error4.split(NEWLINE_REGEX);
      if (isNonEmptyReadonlyArray(errorLines)) {
        const annotateLine = (line4) => annotate2(text3(line4), combine11(italicized2, red3));
        const prefix = cat2(annotate2(pointer, red3), space2);
        const lines3 = map3(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
      return empty34;
    }
  });
}
function renderParts(state, submitted = false) {
  return reduce(state.dateParts, empty34, (doc, part, currentIndex) => {
    const partDoc = text3(part.toString());
    if (currentIndex === state.cursor && !submitted) {
      const annotation = combine11(underlined2, cyanBright2);
      return cat2(doc, annotate2(partDoc, annotation));
    }
    return cat2(doc, partDoc);
  });
}
function renderOutput(leadingSymbol, trailingSymbol, parts2, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, parts2]),
    onNonEmpty: (promptLines) => {
      const lines3 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(parts2));
    }
  });
}
function renderNextFrame(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const parts2 = renderParts(state);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    const errorMsg = renderError(state, figures2.pointerSmall);
    return cursorHide3.pipe(cat2(promptMsg), cat2(errorMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const parts2 = renderParts(state, true);
    const promptMsg = renderOutput(leadingSymbol, trailingSymbol, parts2, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processUp(state) {
  state.dateParts[state.cursor].increment();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processDown(state) {
  state.dateParts[state.cursor].decrement();
  return Action.NextFrame({
    state: {
      ...state,
      typed: ""
    }
  });
}
function processCursorLeft(state) {
  const previousPart = state.dateParts[state.cursor].previousPart();
  return match2(previousPart, {
    onNone: () => Action.Beep(),
    onSome: (previous) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(previous)
      }
    })
  });
}
function processCursorRight(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  return match2(nextPart, {
    onNone: () => Action.Beep(),
    onSome: (next) => Action.NextFrame({
      state: {
        ...state,
        typed: "",
        cursor: state.dateParts.indexOf(next)
      }
    })
  });
}
function processNext(state) {
  const nextPart = state.dateParts[state.cursor].nextPart();
  const cursor = match2(nextPart, {
    onNone: () => state.dateParts.findIndex((part) => !part.isToken()),
    onSome: (next) => state.dateParts.indexOf(next)
  });
  return Action.NextFrame({
    state: {
      ...state,
      cursor
    }
  });
}
function defaultProcessor(value5, state) {
  if (/\d/.test(value5)) {
    const typed = state.typed + value5;
    state.dateParts[state.cursor].setValue(typed);
    return Action.NextFrame({
      state: {
        ...state,
        typed
      }
    });
  }
  return Action.Beep();
}
var defaultLocales = {
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
};
function handleRender(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep),
      NextFrame: ({
        state: state2
      }) => renderNextFrame(state2, options3),
      Submit: () => renderSubmission(state, options3)
    });
  };
}
function handleProcess(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "left": {
        return succeed8(processCursorLeft(state));
      }
      case "right": {
        return succeed8(processCursorRight(state));
      }
      case "k":
      case "up": {
        return succeed8(processUp(state));
      }
      case "j":
      case "down": {
        return succeed8(processDown(state));
      }
      case "tab": {
        return succeed8(processNext(state));
      }
      case "enter":
      case "return": {
        return match11(options3.validate(state.value), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              error: some2(error4)
            }
          }),
          onSuccess: (value5) => Action.Submit({
            value: value5
          })
        });
      }
      default: {
        const value5 = getOrElse(input.input, () => "");
        return succeed8(defaultProcessor(value5, state));
      }
    }
  };
}
var date2 = (options3) => {
  const opts = {
    initial: /* @__PURE__ */ new Date(),
    dateMask: "YYYY-MM-DD HH:mm:ss",
    validate: succeed8,
    ...options3,
    locales: {
      ...defaultLocales,
      ...options3.locales
    }
  };
  const dateParts = makeDateParts(opts.dateMask, opts.initial, opts.locales);
  const initialCursorPosition = dateParts.findIndex((part) => !part.isToken());
  const initialState3 = {
    dateParts,
    typed: "",
    cursor: initialCursorPosition,
    value: opts.initial,
    error: none2()
  };
  return custom2(initialState3, {
    render: handleRender(opts),
    process: handleProcess(opts),
    clear: handleClear(opts)
  });
};
var DATE_PART_REGEX = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
var regexGroups = {
  1: ({
    token,
    ...opts
  }) => new Token({
    token: token.replace(/\\(.)/g, "$1"),
    ...opts
  }),
  2: (opts) => new Day(opts),
  3: (opts) => new Month(opts),
  4: (opts) => new Year(opts),
  5: (opts) => new Meridiem(opts),
  6: (opts) => new Hours(opts),
  7: (opts) => new Minutes(opts),
  8: (opts) => new Seconds(opts),
  9: (opts) => new Milliseconds(opts)
};
var makeDateParts = (dateMask, date5, locales) => {
  const parts2 = [];
  let result = null;
  while (result = DATE_PART_REGEX.exec(dateMask)) {
    const match17 = result.shift();
    const index = result.findIndex((group4) => group4 !== void 0);
    if (index in regexGroups) {
      const token = result[index] || match17;
      parts2.push(regexGroups[index]({
        token,
        date: date5,
        parts: parts2,
        locales
      }));
    } else {
      parts2.push(new Token({
        token: result[index] || match17,
        date: date5,
        parts: parts2,
        locales
      }));
    }
  }
  const orderedParts = parts2.reduce((array7, element) => {
    const lastElement = array7[array7.length - 1];
    if (element.isToken() && lastElement !== void 0 && lastElement.isToken()) {
      lastElement.setValue(element.token);
    } else {
      array7.push(element);
    }
    return array7;
  }, empty2());
  parts2.splice(0, parts2.length, ...orderedParts);
  return parts2;
};
var DatePart = class {
  token;
  date;
  parts;
  locales;
  constructor(params) {
    this.token = params.token;
    this.locales = params.locales;
    this.date = params.date || /* @__PURE__ */ new Date();
    this.parts = params.parts || [this];
  }
  /**
   * Returns `true` if this `DatePart` is a `Token`, `false` otherwise.
   */
  isToken() {
    return false;
  }
  /**
   * Retrieves the next date part in the list of parts.
   */
  nextPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findFirst2(this.parts.slice(currentPartIndex + 1), (part) => !part.isToken())));
  }
  /**
   * Retrieves the previous date part in the list of parts.
   */
  previousPart() {
    return findFirstIndex(this.parts, (part) => part === this).pipe(flatMap((currentPartIndex) => findLast(this.parts.slice(0, currentPartIndex), (part) => !part.isToken())));
  }
  toString() {
    return String(this.date);
  }
};
var Token = class extends DatePart {
  increment() {
  }
  decrement() {
  }
  setValue(value5) {
    this.token = this.token + value5;
  }
  isToken() {
    return true;
  }
  toString() {
    return this.token;
  }
};
var Milliseconds = class extends DatePart {
  increment() {
    this.date.setMilliseconds(this.date.getMilliseconds() + 1);
  }
  decrement() {
    this.date.setMilliseconds(this.date.getMilliseconds() - 1);
  }
  setValue(value5) {
    this.date.setMilliseconds(Number.parseInt(value5.slice(-this.token.length)));
  }
  toString() {
    const millis2 = `${this.date.getMilliseconds()}`;
    return millis2.padStart(4, "0").substring(0, this.token.length);
  }
};
var Seconds = class extends DatePart {
  increment() {
    this.date.setSeconds(this.date.getSeconds() + 1);
  }
  decrement() {
    this.date.setSeconds(this.date.getSeconds() - 1);
  }
  setValue(value5) {
    this.date.setSeconds(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const seconds2 = `${this.date.getSeconds()}`;
    return this.token.length > 1 ? seconds2.padStart(2, "0") : seconds2;
  }
};
var Minutes = class extends DatePart {
  increment() {
    this.date.setMinutes(this.date.getMinutes() + 1);
  }
  decrement() {
    this.date.setMinutes(this.date.getMinutes() - 1);
  }
  setValue(value5) {
    this.date.setMinutes(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const minutes2 = `${this.date.getMinutes()}`;
    return this.token.length > 1 ? minutes2.padStart(2, "0") : minutes2;
  }
};
var Hours = class extends DatePart {
  increment() {
    this.date.setHours(this.date.getHours() + 1);
  }
  decrement() {
    this.date.setHours(this.date.getHours() - 1);
  }
  setValue(value5) {
    this.date.setHours(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const hours2 = /h/.test(this.token) ? this.date.getHours() % 12 || 12 : this.date.getHours();
    return this.token.length > 1 ? `${hours2}`.padStart(2, "0") : `${hours2}`;
  }
};
var Day = class extends DatePart {
  increment() {
    this.date.setDate(this.date.getDate() + 1);
  }
  decrement() {
    this.date.setDate(this.date.getDate() - 1);
  }
  setValue(value5) {
    this.date.setDate(Number.parseInt(value5.slice(-2)));
  }
  toString() {
    const date5 = this.date.getDate();
    const day = this.date.getDay();
    return value4(this.token).pipe(when5("DD", () => `${date5}`.padStart(2, "0")), when5("Do", () => `${date5}${this.ordinalIndicator(date5)}`), when5("d", () => `${day + 1}`), when5("ddd", () => this.locales.weekdaysShort[day]), when5("dddd", () => this.locales.weekdays[day]), orElse12(() => `${date5}`));
  }
  ordinalIndicator(day) {
    return value4(day % 10).pipe(when5(1, () => "st"), when5(2, () => "nd"), when5(3, () => "rd"), orElse12(() => "th"));
  }
};
var Month = class extends DatePart {
  increment() {
    this.date.setMonth(this.date.getMonth() + 1);
  }
  decrement() {
    this.date.setMonth(this.date.getMonth() - 1);
  }
  setValue(value5) {
    const month = Number.parseInt(value5.slice(-2)) - 1;
    this.date.setMonth(month < 0 ? 0 : month);
  }
  toString() {
    const month = this.date.getMonth();
    return value4(this.token.length).pipe(when5(2, () => `${month + 1}`.padStart(2, "0")), when5(3, () => this.locales.monthsShort[month]), when5(4, () => this.locales.months[month]), orElse12(() => `${month + 1}`));
  }
};
var Year = class extends DatePart {
  increment() {
    this.date.setFullYear(this.date.getFullYear() + 1);
  }
  decrement() {
    this.date.setFullYear(this.date.getFullYear() - 1);
  }
  setValue(value5) {
    this.date.setFullYear(Number.parseInt(value5.slice(-4)));
  }
  toString() {
    const year = `${this.date.getFullYear()}`.padStart(4, "0");
    return this.token.length === 2 ? year.substring(-2) : year;
  }
};
var Meridiem = class extends DatePart {
  increment() {
    this.date.setHours((this.date.getHours() + 12) % 24);
  }
  decrement() {
    this.increment();
  }
  setValue(_value) {
  }
  toString() {
    const meridiem = this.date.getHours() > 12 ? "pm" : "am";
    return /A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
  }
};

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/path.js
var TypeId18 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Path.js
var TypeId19 = TypeId18;
var Path2 = Path;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/utils.js
var entriesToDisplay = (cursor, total, maxVisible) => {
  const max6 = maxVisible === void 0 ? total : maxVisible;
  let startIndex = Math.min(total - max6, cursor - Math.floor(max6 / 2));
  if (startIndex < 0) {
    startIndex = 0;
  }
  const endIndex = Math.min(startIndex + max6, total);
  return {
    startIndex,
    endIndex
  };
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/file.js
var CONFIRM_MESSAGE = "The selected directory contains files. Would you like to traverse the selected directory?";
var Confirm = /* @__PURE__ */ taggedEnum();
var showConfirmation = /* @__PURE__ */ Confirm.$is("Show");
var renderBeep2 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function resolveCurrentPath(path2, options3) {
  return match2(path2, {
    onNone: () => match2(options3.startingPath, {
      onNone: () => sync5(() => process.cwd()),
      onSome: (path3) => flatMap9(FileSystem, (fs) => (
        // Ensure the user provided starting path exists
        orDie2(fs.exists(path3)).pipe(filterOrDieMessage2(identity, `The provided starting path '${path3}' does not exist`), as4(path3))
      ))
    }),
    onSome: (path3) => succeed8(path3)
  });
}
function getFileList(directory2, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path2 = yield* Path2;
    const files = yield* orDie2(fs.readDirectory(directory2)).pipe(
      // Always prepend the `".."` option to the file list but allow it
      // to be filtered out if the user so desires
      map17((files2) => ["..", ...files2])
    );
    return yield* filter8(files, (file3) => {
      const result = options3.filter(file3);
      const userDefinedFilter = isEffect2(result) ? result : succeed8(result);
      const directoryFilter = options3.type === "directory" ? map17(orDie2(fs.stat(path2.join(directory2, file3))), (info2) => info2.type === "Directory") : succeed8(true);
      return zipWith5(userDefinedFilter, directoryFilter, (a, b) => a && b);
    }, {
      concurrency: files.length
    });
  });
}
function handleClear2(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const currentPath = yield* resolveCurrentPath(state.path, options3);
      const text9 = "\n".repeat(Math.min(state.files.length, options3.maxPerPage));
      const clearPath = eraseText(currentPath, columns);
      const message = showConfirmation(state.confirm) ? CONFIRM_MESSAGE : options3.message;
      const clearPrompt = eraseText(`
${message}`, columns);
      const clearOptions = eraseText(text9, columns);
      return clearOptions.pipe(cat2(clearPath), cat2(clearPrompt), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
var NEWLINE_REGEX2 = /\r?\n/;
function renderPrompt(confirm, message, leadingSymbol, trailingSymbol) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(message.split(NEWLINE_REGEX2), {
    onEmpty: () => hsep2([prefix, trailingSymbol, confirm]),
    onNonEmpty: (promptLines) => {
      const lines3 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(confirm));
    }
  });
}
function renderPrefix(state, toDisplay, currentIndex, length3, figures2) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures2.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < length3) {
    prefix = figures2.arrowDown;
  }
  return state.cursor === currentIndex ? figures2.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderFileName(file3, isSelected) {
  return isSelected ? annotate2(text3(file3), combine11(underlined2, cyanBright2)) : text3(file3);
}
function renderFiles(state, files, figures2, options3) {
  const length3 = files.length;
  const toDisplay = entriesToDisplay(state.cursor, length3, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const isSelected = state.cursor === index;
    const prefix = renderPrefix(state, toDisplay, index, length3, figures2);
    const fileName = renderFileName(files[index], isSelected);
    documents.push(cat2(prefix, fileName));
  }
  return vsep2(documents);
}
function renderNextFrame2(state, options3) {
  return gen2(function* () {
    const path2 = yield* Path2;
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path2.resolve(currentPath, selectedPath);
    const resolvedPathMsg = figures2.pointerSmall.pipe(cat2(space2), cat2(text3(resolvedPath)), annotate2(blackBright2));
    if (showConfirmation(state.confirm)) {
      const leadingSymbol2 = annotate2(text3("?"), cyanBright2);
      const trailingSymbol2 = annotate2(figures2.pointerSmall, blackBright2);
      const confirm = annotate2(text3("(Y/n)"), blackBright2);
      const promptMsg2 = renderPrompt(confirm, CONFIRM_MESSAGE, leadingSymbol2, trailingSymbol2);
      return cursorHide3.pipe(cat2(promptMsg2), cat2(hardLine2), cat2(resolvedPathMsg), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    }
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty34, options3.message, leadingSymbol, trailingSymbol);
    const files = renderFiles(state, state.files, figures2, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(resolvedPathMsg), cat2(hardLine2), cat2(files), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission2(value5, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderPrompt(empty34, options3.message, leadingSymbol, trailingSymbol);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(text3(value5), white3)), cat2(hardLine2), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleRender2(options3) {
  return (_, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep2),
      NextFrame: ({
        state
      }) => renderNextFrame2(state, options3),
      Submit: ({
        value: value5
      }) => renderSubmission2(value5, options3)
    });
  };
}
function processCursorUp(state) {
  const cursor = state.cursor - 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor: cursor < 0 ? state.files.length - 1 : cursor
    }
  }));
}
function processCursorDown(state) {
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor: (state.cursor + 1) % state.files.length
    }
  }));
}
function processSelection(state, options3) {
  return gen2(function* () {
    const fs = yield* FileSystem;
    const path2 = yield* Path2;
    const currentPath = yield* resolveCurrentPath(state.path, options3);
    const selectedPath = state.files[state.cursor];
    const resolvedPath = path2.resolve(currentPath, selectedPath);
    const info2 = yield* orDie2(fs.stat(resolvedPath));
    if (info2.type === "Directory") {
      const files = yield* getFileList(resolvedPath, options3);
      const filesWithoutParent = files.filter((file3) => file3 !== "..");
      if (options3.type === "directory" || options3.type === "either") {
        return filesWithoutParent.length === 0 ? Action.Submit({
          value: resolvedPath
        }) : Action.NextFrame({
          state: {
            ...state,
            confirm: Confirm.Show()
          }
        });
      }
      return Action.NextFrame({
        state: {
          cursor: 0,
          files,
          path: some2(resolvedPath),
          confirm: Confirm.Hide()
        }
      });
    }
    return Action.Submit({
      value: resolvedPath
    });
  });
}
function handleProcess2(options3) {
  return (input, state) => gen2(function* () {
    switch (input.key.name) {
      case "k":
      case "up": {
        return yield* processCursorUp(state);
      }
      case "j":
      case "down":
      case "tab": {
        return yield* processCursorDown(state);
      }
      case "enter":
      case "return": {
        return yield* processSelection(state, options3);
      }
      case "y":
      case "t": {
        if (showConfirmation(state.confirm)) {
          const path2 = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path2.resolve(currentPath, selectedPath);
          const files = yield* getFileList(resolvedPath, options3);
          return Action.NextFrame({
            state: {
              cursor: 0,
              files,
              path: some2(resolvedPath),
              confirm: Confirm.Hide()
            }
          });
        }
        return Action.Beep();
      }
      case "n":
      case "f": {
        if (showConfirmation(state.confirm)) {
          const path2 = yield* Path2;
          const currentPath = yield* resolveCurrentPath(state.path, options3);
          const selectedPath = state.files[state.cursor];
          const resolvedPath = path2.resolve(currentPath, selectedPath);
          return Action.Submit({
            value: resolvedPath
          });
        }
        return Action.Beep();
      }
      default: {
        return Action.Beep();
      }
    }
  });
}
var file = (options3 = {}) => {
  const opts = {
    type: options3.type ?? "file",
    message: options3.message ?? `Choose a file`,
    startingPath: fromNullable(options3.startingPath),
    maxPerPage: options3.maxPerPage ?? 10,
    filter: options3.filter ?? (() => succeed8(true))
  };
  const initialState3 = gen2(function* () {
    const path2 = none2();
    const currentPath = yield* resolveCurrentPath(path2, opts);
    const files = yield* getFileList(currentPath, opts);
    const confirm = Confirm.Hide();
    return {
      cursor: 0,
      files,
      path: path2,
      confirm
    };
  });
  return custom2(initialState3, {
    render: handleRender2(opts),
    process: handleProcess2(opts),
    clear: handleClear2(opts)
  });
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/number.js
var parseInt2 = /* @__PURE__ */ NumberFromString.pipe(/* @__PURE__ */ int(), decodeUnknown2);
var parseFloat2 = /* @__PURE__ */ decodeUnknown2(NumberFromString);
var renderBeep3 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear3(options3) {
  return (state, _) => {
    return gen2(function* () {
      const terminal = yield* Terminal;
      const columns = yield* terminal.columns;
      const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
      const clearError = match2(state.error, {
        onNone: () => empty34,
        onSome: (error4) => cursorDown3(lines(error4, columns)).pipe(cat2(eraseText(`
${error4}`, columns)))
      });
      const clearOutput = eraseText(options3.message, columns);
      return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render3({
        style: "pretty",
        options: {
          lineWidth: columns
        }
      }));
    });
  };
}
function renderInput(state, submitted) {
  const annotation = match2(state.error, {
    onNone: () => combine11(underlined2, cyanBright2),
    onSome: () => red3
  });
  const value5 = state.value === "" ? empty34 : text3(`${state.value}`);
  return submitted ? value5 : annotate2(value5, annotation);
}
var NEWLINE_REGEX3 = /\r?\n/;
function renderError2(state, pointer) {
  return match2(state.error, {
    onNone: () => empty34,
    onSome: (error4) => match3(error4.split(NEWLINE_REGEX3), {
      onEmpty: () => empty34,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => annotate2(text3(line4), combine11(italicized2, red3));
        const prefix = cat2(annotate2(pointer, red3), space2);
        const lines3 = map3(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput2(state, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(/\r?\n/), {
    onEmpty: () => hsep2([prefix, trailingSymbol, renderInput(state, submitted)]),
    onNonEmpty: (promptLines) => {
      const lines3 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput(state, submitted)));
    }
  });
}
function renderNextFrame3(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const errorMsg = renderError2(state, figures2.pointerSmall);
    const promptMsg = renderOutput2(state, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(errorMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission3(nextState, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput2(nextState, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace(state) {
  if (state.value.length <= 0) {
    return succeed8(Action.Beep());
  }
  const value5 = state.value.slice(0, state.value.length - 1);
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      value: value5,
      error: none2()
    }
  }));
}
function defaultIntProcessor(state, input) {
  if (state.value.length === 0 && input === "-") {
    return succeed8(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match11(parseInt2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value5) => Action.NextFrame({
      state: {
        ...state,
        value: `${value5}`,
        error: none2()
      }
    })
  });
}
function defaultFloatProcessor(state, input) {
  if (input === "." && state.value.includes(".")) {
    return succeed8(Action.Beep());
  }
  if (state.value.length === 0 && input === "-") {
    return succeed8(Action.NextFrame({
      state: {
        ...state,
        value: "-",
        error: none2()
      }
    }));
  }
  return match11(parseFloat2(state.value + input), {
    onFailure: () => Action.Beep(),
    onSuccess: (value5) => Action.NextFrame({
      state: {
        ...state,
        value: input === "." ? `${value5}.` : `${value5}`,
        error: none2()
      }
    })
  });
}
var initialState = {
  cursor: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRenderInteger(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessInteger(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseInt(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseInt(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseInt2(state.value), {
          onFailure: () => succeed8(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide an integer value")
            }
          })),
          onSuccess: (n) => match11(options3.validate(n), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value5) => Action.Submit({
              value: value5
            })
          })
        });
      }
      default: {
        const value5 = getOrElse(input.input, () => "");
        return defaultIntProcessor(state, value5);
      }
    }
  };
}
var integer2 = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    validate: (n) => {
      if (n < opts.min) {
        return fail8(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail8(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed8(n);
    },
    ...options3
  };
  return custom2(initialState, {
    render: handleRenderInteger(opts),
    process: handleProcessInteger(opts),
    clear: handleClear3(opts)
  });
};
function handleRenderFloat(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep3),
      NextFrame: ({
        state: state2
      }) => renderNextFrame3(state2, options3),
      Submit: () => renderSubmission3(state, options3)
    });
  };
}
function handleProcessFloat(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace(state);
      }
      case "k":
      case "up": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `${options3.incrementBy}` : `${Number.parseFloat(state.value) + options3.incrementBy}`,
            error: none2()
          }
        }));
      }
      case "j":
      case "down": {
        return succeed8(Action.NextFrame({
          state: {
            ...state,
            value: state.value === "" || state.value === "-" ? `-${options3.decrementBy}` : `${Number.parseFloat(state.value) - options3.decrementBy}`,
            error: none2()
          }
        }));
      }
      case "enter":
      case "return": {
        return matchEffect2(parseFloat2(state.value), {
          onFailure: () => succeed8(Action.NextFrame({
            state: {
              ...state,
              error: some2("Must provide a floating point value")
            }
          })),
          onSuccess: (n) => flatMap9(sync5(() => round(n, options3.precision)), (rounded) => match11(options3.validate(rounded), {
            onFailure: (error4) => Action.NextFrame({
              state: {
                ...state,
                error: some2(error4)
              }
            }),
            onSuccess: (value5) => Action.Submit({
              value: value5
            })
          }))
        });
      }
      default: {
        const value5 = getOrElse(input.input, () => "");
        return defaultFloatProcessor(state, value5);
      }
    }
  };
}
var float = (options3) => {
  const opts = {
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    incrementBy: 1,
    decrementBy: 1,
    precision: 2,
    validate: (n) => {
      if (n < opts.min) {
        return fail8(`${n} must be greater than or equal to ${opts.min}`);
      }
      if (n > opts.max) {
        return fail8(`${n} must be less than or equal to ${opts.max}`);
      }
      return succeed8(n);
    },
    ...options3
  };
  return custom2(initialState, {
    render: handleRenderFloat(opts),
    process: handleProcessFloat(opts),
    clear: handleClear3(opts)
  });
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/select.js
var renderBeep4 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
var NEWLINE_REGEX4 = /\r?\n/;
function renderOutput3(leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const prefix = cat2(leadingSymbol, space2);
  return match3(options3.message.split(NEWLINE_REGEX4), {
    onEmpty: () => hsep2([prefix, trailingSymbol]),
    onNonEmpty: (promptLines) => {
      const lines3 = map3(promptLines, (line4) => annotateLine(line4));
      return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2));
    }
  });
}
function renderChoicePrefix(state, choices, toDisplay, currentIndex, figures2) {
  let prefix = space2;
  if (currentIndex === toDisplay.startIndex && toDisplay.startIndex > 0) {
    prefix = figures2.arrowUp;
  } else if (currentIndex === toDisplay.endIndex - 1 && toDisplay.endIndex < choices.length) {
    prefix = figures2.arrowDown;
  }
  if (choices[currentIndex].disabled) {
    const annotation = combine11(bold2, blackBright2);
    return state === currentIndex ? figures2.pointer.pipe(annotate2(annotation), cat2(prefix)) : prefix.pipe(cat2(space2));
  }
  return state === currentIndex ? figures2.pointer.pipe(annotate2(cyanBright2), cat2(prefix)) : prefix.pipe(cat2(space2));
}
function renderChoiceTitle(choice3, isSelected) {
  const title = text3(choice3.title);
  if (isSelected) {
    return choice3.disabled ? annotate2(title, combine11(underlined2, blackBright2)) : annotate2(title, combine11(underlined2, cyanBright2));
  }
  return choice3.disabled ? annotate2(title, combine11(strikethrough2, blackBright2)) : title;
}
function renderChoiceDescription(choice3, isSelected) {
  if (!choice3.disabled && choice3.description && isSelected) {
    return char3("-").pipe(cat2(space2), cat2(text3(choice3.description)), annotate2(blackBright2));
  }
  return empty34;
}
function renderChoices(state, options3, figures2) {
  const choices = options3.choices;
  const toDisplay = entriesToDisplay(state, choices.length, options3.maxPerPage);
  const documents = [];
  for (let index = toDisplay.startIndex; index < toDisplay.endIndex; index++) {
    const choice3 = choices[index];
    const isSelected = state === index;
    const prefix = renderChoicePrefix(state, choices, toDisplay, index, figures2);
    const title = renderChoiceTitle(choice3, isSelected);
    const description = renderChoiceDescription(choice3, isSelected);
    documents.push(prefix.pipe(cat2(title), cat2(space2), cat2(description)));
  }
  return vsep2(documents);
}
function renderNextFrame4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const choices = renderChoices(state, options3, figures2);
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), cat2(hardLine2), cat2(choices), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission4(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const selected = text3(options3.choices[state].title);
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput3(leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(space2), cat2(annotate2(selected, white3)), cat2(hardLine2), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processCursorUp2(state, choices) {
  if (state === 0) {
    return succeed8(Action.NextFrame({
      state: choices.length - 1
    }));
  }
  return succeed8(Action.NextFrame({
    state: state - 1
  }));
}
function processCursorDown2(state, choices) {
  if (state === choices.length - 1) {
    return succeed8(Action.NextFrame({
      state: 0
    }));
  }
  return succeed8(Action.NextFrame({
    state: state + 1
  }));
}
function processNext2(state, choices) {
  return succeed8(Action.NextFrame({
    state: (state + 1) % choices.length
  }));
}
function handleRender3(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep4),
      NextFrame: ({
        state: state2
      }) => renderNextFrame4(state2, options3),
      Submit: () => renderSubmission4(state, options3)
    });
  };
}
function handleClear4(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const text9 = "\n".repeat(Math.min(options3.choices.length, options3.maxPerPage)) + options3.message;
    const clearOutput = eraseText(text9, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function handleProcess3(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "k":
      case "up": {
        return processCursorUp2(state, options3.choices);
      }
      case "j":
      case "down": {
        return processCursorDown2(state, options3.choices);
      }
      case "tab": {
        return processNext2(state, options3.choices);
      }
      case "enter":
      case "return": {
        const selected = options3.choices[state];
        if (selected.disabled) {
          return succeed8(Action.Beep());
        }
        return succeed8(Action.Submit({
          value: selected.value
        }));
      }
      default: {
        return succeed8(Action.Beep());
      }
    }
  };
}
var select = (options3) => {
  const opts = {
    maxPerPage: 10,
    ...options3
  };
  return custom2(0, {
    render: handleRender3(opts),
    process: handleProcess3(opts),
    clear: () => handleClear4(opts)
  });
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/text.js
function getValue(state, options3) {
  return state.value.length > 0 ? state.value : options3.default;
}
var renderBeep5 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function renderClearScreen(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const resetCurrentLine = cat2(eraseLine3, cursorLeft3);
    const clearError = match2(state.error, {
      onNone: () => empty34,
      onSome: (error4) => (
        // If there was an error, move the cursor down to the final error line and
        // then clear all lines of error output
        cursorDown3(lines(error4, columns)).pipe(
          // Add a leading newline to the error message to ensure that the corrrect
          // number of error lines are erased
          cat2(eraseText(`
${error4}`, columns))
        )
      )
    });
    const clearOutput = eraseText(options3.message, columns);
    return clearError.pipe(cat2(clearOutput), cat2(resetCurrentLine), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderInput2(nextState, options3, submitted) {
  const text9 = getValue(nextState, options3);
  const annotation = match2(nextState.error, {
    onNone: () => {
      if (submitted) {
        return white3;
      }
      if (nextState.value.length === 0) {
        return blackBright2;
      }
      return combine11(underlined2, cyanBright2);
    },
    onSome: () => red3
  });
  switch (options3.type) {
    case "hidden": {
      return empty34;
    }
    case "password": {
      return annotate2(text3("*".repeat(text9.length)), annotation);
    }
    case "text": {
      return annotate2(text3(text9), annotation);
    }
  }
}
function renderError3(nextState, pointer) {
  return match2(nextState.error, {
    onNone: () => empty34,
    onSome: (error4) => match3(error4.split(/\r?\n/), {
      onEmpty: () => empty34,
      onNonEmpty: (errorLines) => {
        const annotateLine = (line4) => text3(line4).pipe(annotate2(combine11(italicized2, red3)));
        const prefix = cat2(annotate2(pointer, red3), space2);
        const lines3 = map3(errorLines, (str) => annotateLine(str));
        return cursorSavePosition3.pipe(cat2(hardLine2), cat2(prefix), cat2(align2(vsep2(lines3))), cat2(cursorRestorePosition3));
      }
    })
  });
}
function renderOutput4(nextState, leadingSymbol, trailingSymbol, options3, submitted = false) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines3 = map3(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(renderInput2(nextState, options3, submitted)));
  }
  return hsep2([prefix, trailingSymbol, renderInput2(nextState, options3, submitted)]);
}
function renderNextFrame5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3);
    const errorMsg = renderError3(state, figures2.pointerSmall);
    return promptMsg.pipe(cat2(errorMsg), cat2(cursorMove3(state.offset)), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission5(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const figures2 = yield* figures;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const promptMsg = renderOutput4(state, leadingSymbol, trailingSymbol, options3, true);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function processBackspace2(state) {
  if (state.cursor <= 0) {
    return succeed8(Action.Beep());
  }
  const beforeCursor = state.value.slice(0, state.cursor - 1);
  const afterCursor = state.value.slice(state.cursor);
  const cursor = state.cursor - 1;
  const value5 = `${beforeCursor}${afterCursor}`;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value5,
      error: none2()
    }
  }));
}
function processCursorLeft2(state) {
  if (state.cursor <= 0) {
    return succeed8(Action.Beep());
  }
  const cursor = state.cursor - 1;
  const offset = state.offset - 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: none2()
    }
  }));
}
function processCursorRight2(state) {
  if (state.cursor >= state.value.length) {
    return succeed8(Action.Beep());
  }
  const cursor = Math.min(state.cursor + 1, state.value.length);
  const offset = Math.min(state.offset + 1, state.value.length);
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      offset,
      error: none2()
    }
  }));
}
function processTab(state, options3) {
  if (state.value === options3.default) {
    return succeed8(Action.Beep());
  }
  const value5 = getValue(state, options3);
  const cursor = value5.length;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      value: value5,
      cursor,
      error: none2()
    }
  }));
}
function defaultProcessor2(input, state) {
  const beforeCursor = state.value.slice(0, state.cursor);
  const afterCursor = state.value.slice(state.cursor);
  const value5 = `${beforeCursor}${input}${afterCursor}`;
  const cursor = beforeCursor.length + 1;
  return succeed8(Action.NextFrame({
    state: {
      ...state,
      cursor,
      value: value5,
      error: none2()
    }
  }));
}
var initialState2 = {
  cursor: 0,
  offset: 0,
  value: "",
  error: /* @__PURE__ */ none2()
};
function handleRender4(options3) {
  return (state, action) => {
    return Action.$match(action, {
      Beep: () => succeed8(renderBeep5),
      NextFrame: ({
        state: state2
      }) => renderNextFrame5(state2, options3),
      Submit: () => renderSubmission5(state, options3)
    });
  };
}
function handleProcess4(options3) {
  return (input, state) => {
    switch (input.key.name) {
      case "backspace": {
        return processBackspace2(state);
      }
      case "left": {
        return processCursorLeft2(state);
      }
      case "right": {
        return processCursorRight2(state);
      }
      case "enter":
      case "return": {
        const value5 = getValue(state, options3);
        return match11(options3.validate(value5), {
          onFailure: (error4) => Action.NextFrame({
            state: {
              ...state,
              value: value5,
              error: some2(error4)
            }
          }),
          onSuccess: (value6) => Action.Submit({
            value: value6
          })
        });
      }
      case "tab": {
        return processTab(state, options3);
      }
      default: {
        const value5 = getOrElse(input.input, () => "");
        return defaultProcessor2(value5, state);
      }
    }
  };
}
function handleClear5(options3) {
  return (state, _) => {
    return renderClearScreen(state, options3);
  };
}
function basePrompt(options3, type2) {
  const opts = {
    default: "",
    type: type2,
    validate: succeed8,
    ...options3
  };
  return custom2(initialState2, {
    render: handleRender4(opts),
    process: handleProcess4(opts),
    clear: handleClear5(opts)
  });
}
var hidden = (options3) => basePrompt(options3, "hidden").pipe(map27(make52));
var text5 = (options3) => basePrompt(options3, "text");

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/toggle.js
var renderBeep6 = /* @__PURE__ */ render3(beep3, {
  style: "pretty"
});
function handleClear6(options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const columns = yield* terminal.columns;
    const clearPrompt = cat2(eraseLine3, cursorLeft3);
    const clearOutput = eraseText(options3.message, columns);
    return clearOutput.pipe(cat2(clearPrompt), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderToggle(value5, options3, submitted = false) {
  const separator = annotate2(char3("/"), blackBright2);
  const selectedAnnotation = combine11(underlined2, submitted ? white3 : cyanBright2);
  const inactive = value5 ? text3(options3.inactive) : annotate2(text3(options3.inactive), selectedAnnotation);
  const active2 = value5 ? annotate2(text3(options3.active), selectedAnnotation) : text3(options3.active);
  return hsep2([active2, separator, inactive]);
}
function renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3) {
  const annotateLine = (line4) => annotate2(text3(line4), bold2);
  const promptLines = options3.message.split(/\r?\n/);
  const prefix = cat2(leadingSymbol, space2);
  if (isNonEmptyReadonlyArray(promptLines)) {
    const lines3 = map3(promptLines, (line4) => annotateLine(line4));
    return prefix.pipe(cat2(nest2(vsep2(lines3), 2)), cat2(space2), cat2(trailingSymbol), cat2(space2), cat2(toggle3));
  }
  return hsep2([prefix, trailingSymbol, toggle3]);
}
function renderNextFrame6(state, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures2 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(text3("?"), cyanBright2);
    const trailingSymbol = annotate2(figures2.pointerSmall, blackBright2);
    const toggle3 = renderToggle(state, options3);
    const promptMsg = renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3);
    return cursorHide3.pipe(cat2(promptMsg), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
function renderSubmission6(value5, options3) {
  return gen2(function* () {
    const terminal = yield* Terminal;
    const figures2 = yield* figures;
    const columns = yield* terminal.columns;
    const leadingSymbol = annotate2(figures2.tick, green3);
    const trailingSymbol = annotate2(figures2.ellipsis, blackBright2);
    const toggle3 = renderToggle(value5, options3, true);
    const promptMsg = renderOutput5(toggle3, leadingSymbol, trailingSymbol, options3);
    return promptMsg.pipe(cat2(hardLine2), optimize3(Deep), render3({
      style: "pretty",
      options: {
        lineWidth: columns
      }
    }));
  });
}
var activate = /* @__PURE__ */ succeed8(/* @__PURE__ */ Action.NextFrame({
  state: true
}));
var deactivate = /* @__PURE__ */ succeed8(/* @__PURE__ */ Action.NextFrame({
  state: false
}));
function handleRender5(options3) {
  return (state, action) => {
    switch (action._tag) {
      case "Beep": {
        return succeed8(renderBeep6);
      }
      case "NextFrame": {
        return renderNextFrame6(state, options3);
      }
      case "Submit": {
        return renderSubmission6(state, options3);
      }
    }
  };
}
function handleProcess5(input, state) {
  switch (input.key.name) {
    case "0":
    case "j":
    case "delete":
    case "right":
    case "down": {
      return deactivate;
    }
    case "1":
    case "k":
    case "left":
    case "up": {
      return activate;
    }
    case " ":
    case "tab": {
      return state ? deactivate : activate;
    }
    case "enter":
    case "return": {
      return succeed8(Action.Submit({
        value: state
      }));
    }
    default: {
      return succeed8(Action.Beep());
    }
  }
}
var toggle2 = (options3) => {
  const opts = {
    initial: false,
    active: "on",
    inactive: "off",
    ...options3
  };
  return custom2(opts.initial, {
    render: handleRender5(opts),
    process: handleProcess5,
    clear: () => handleClear6(opts)
  });
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/primitive.js
var PrimitiveSymbolKey = "@effect/cli/Primitive";
var PrimitiveTypeId = /* @__PURE__ */ Symbol.for(PrimitiveSymbolKey);
var proto19 = {
  [PrimitiveTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isPrimitive = (u) => typeof u === "object" && u != null && PrimitiveTypeId in u;
var isBool = (self) => isPrimitive(self) && isBoolType(self);
var isBoolType = (self) => self._tag === "Bool";
var trueValues = /* @__PURE__ */ Literal2("true", "1", "y", "yes", "on");
var isTrueValue = /* @__PURE__ */ is(trueValues);
var falseValues = /* @__PURE__ */ Literal2("false", "0", "n", "no", "off");
var isFalseValue = /* @__PURE__ */ is(falseValues);
var boolean3 = (defaultValue) => {
  const op = Object.create(proto19);
  op._tag = "Bool";
  op.defaultValue = defaultValue;
  return op;
};
var choice = (alternatives) => {
  const op = Object.create(proto19);
  op._tag = "Choice";
  op.alternatives = alternatives;
  return op;
};
var path = (pathType, pathExists) => {
  const op = Object.create(proto19);
  op._tag = "Path";
  op.pathType = pathType;
  op.pathExists = pathExists;
  return op;
};
var text6 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto19);
  op._tag = "Text";
  return op;
})();
var getChoices = (self) => getChoicesInternal(self);
var getHelp = (self) => getHelpInternal(self);
var getTypeName = (self) => getTypeNameInternal(self);
var validate4 = /* @__PURE__ */ dual(3, (self, value5, config2) => validateInternal(self, value5, config2));
var wizard = /* @__PURE__ */ dual(2, (self, help) => wizardInternal(self, help));
var getChoicesInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return some2("true | false");
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(" | "));
      return some2(choices);
    }
    case "DateTime": {
      return some2("date");
    }
    case "Float":
    case "Integer":
    case "Path":
    case "Redacted":
    case "Secret":
    case "Text": {
      return none2();
    }
  }
};
var getHelpInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return text4("A true or false value.");
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(", "));
      return text4(`One of the following: ${choices}`);
    }
    case "DateTime": {
      return text4("A date without a time-zone in the ISO-8601 format, such as 2007-12-03T10:15:30.");
    }
    case "Float": {
      return text4("A floating point number.");
    }
    case "Integer": {
      return text4("An integer.");
    }
    case "Path": {
      if (self.pathType === "either" && self.pathExists === "yes") {
        return text4("An existing file or directory.");
      }
      if (self.pathType === "file" && self.pathExists === "yes") {
        return text4("An existing file.");
      }
      if (self.pathType === "directory" && self.pathExists === "yes") {
        return text4("An existing directory.");
      }
      if (self.pathType === "either" && self.pathExists === "no") {
        return text4("A file or directory that must not exist.");
      }
      if (self.pathType === "file" && self.pathExists === "no") {
        return text4("A file that must not exist.");
      }
      if (self.pathType === "directory" && self.pathExists === "no") {
        return text4("A directory that must not exist.");
      }
      if (self.pathType === "either" && self.pathExists === "either") {
        return text4("A file or directory.");
      }
      if (self.pathType === "file" && self.pathExists === "either") {
        return text4("A file.");
      }
      if (self.pathType === "directory" && self.pathExists === "either") {
        return text4("A directory.");
      }
      throw new Error(`[BUG]: Path.help - encountered invalid combination of path type ('${self.pathType}') and path existence ('${self.pathExists}')`);
    }
    case "Secret":
    case "Redacted": {
      return text4("A user-defined piece of text that is confidential.");
    }
    case "Text": {
      return text4("A user-defined piece of text.");
    }
  }
};
var getTypeNameInternal = (self) => {
  switch (self._tag) {
    case "Bool": {
      return "boolean";
    }
    case "Choice": {
      return "choice";
    }
    case "DateTime": {
      return "date";
    }
    case "Float": {
      return "float";
    }
    case "Integer": {
      return "integer";
    }
    case "Path": {
      if (self.pathType === "either") {
        return "path";
      }
      return self.pathType;
    }
    case "Redacted": {
      return "redacted";
    }
    case "Secret": {
      return "secret";
    }
    case "Text": {
      return "text";
    }
  }
};
var validateInternal = (self, value5, config2) => {
  switch (self._tag) {
    case "Bool": {
      return map2(value5, (str) => normalizeCase(config2, str)).pipe(match2({
        onNone: () => orElseFail2(self.defaultValue, () => `Missing default value for boolean parameter`),
        onSome: (value6) => isTrueValue(value6) ? succeed8(true) : isFalseValue(value6) ? succeed8(false) : fail8(`Unable to recognize '${value6}' as a valid boolean`)
      }));
    }
    case "Choice": {
      return orElseFail2(value5, () => `Choice options to not have a default value`).pipe(flatMap9((value6) => findFirst2(self.alternatives, ([choice3]) => choice3 === value6)), mapBoth4({
        onFailure: () => {
          const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(", "));
          return `Expected one of the following cases: ${choices}`;
        },
        onSuccess: ([, value6]) => value6
      }));
    }
    case "DateTime": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(Date$));
    }
    case "Float": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(NumberFromString));
    }
    case "Integer": {
      const intFromString = compose3(NumberFromString, Int);
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(intFromString));
    }
    case "Path": {
      return flatMap9(FileSystem, (fileSystem) => {
        const errorMsg = "Path options do not have a default value";
        return orElseFail2(value5, () => errorMsg).pipe(tap2((path2) => orDie2(fileSystem.exists(path2)).pipe(tap2((pathExists) => validatePathExistence(path2, self.pathExists, pathExists).pipe(zipRight3(validatePathType(path2, self.pathType, fileSystem).pipe(when2(() => self.pathExists !== "no" && pathExists))))))));
      });
    }
    case "Redacted": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(String$)).pipe(map17((value6) => make52(value6)));
    }
    case "Secret": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(String$)).pipe(map17((value6) => fromString2(value6)));
    }
    case "Text": {
      return attempt(value5, getTypeNameInternal(self), decodeUnknown2(String$));
    }
  }
};
var attempt = (option4, typeName, parse8) => orElseFail2(option4, () => `${typeName} options do not have a default value`).pipe(flatMap9((value5) => orElseFail2(parse8(value5), () => `'${value5}' is not a ${typeName}`)));
var validatePathExistence = (path2, shouldPathExist, pathExists) => {
  if (shouldPathExist === "no" && pathExists) {
    return fail8(`Path '${path2}' must not exist`);
  }
  if (shouldPathExist === "yes" && !pathExists) {
    return fail8(`Path '${path2}' must exist`);
  }
  return _void;
};
var validatePathType = (path2, pathType, fileSystem) => {
  switch (pathType) {
    case "file": {
      const checkIsFile = fileSystem.stat(path2).pipe(map17((info2) => info2.type === "File"), orDie2);
      return fail8(`Expected path '${path2}' to be a regular file`).pipe(unlessEffect2(checkIsFile), asVoid2);
    }
    case "directory": {
      const checkIsDirectory = fileSystem.stat(path2).pipe(map17((info2) => info2.type === "Directory"), orDie2);
      return fail8(`Expected path '${path2}' to be a directory`).pipe(unlessEffect2(checkIsDirectory), asVoid2);
    }
    case "either": {
      return _void;
    }
  }
};
var wizardInternal = (self, help) => {
  switch (self._tag) {
    case "Bool": {
      const primitiveHelp = p("Select true or false");
      const message = sequence(help, primitiveHelp);
      const initial = getOrElse(self.defaultValue, () => false);
      return toggle2({
        message: toAnsiText(message).trimEnd(),
        initial,
        active: "true",
        inactive: "false"
      }).pipe(map27((bool) => `${bool}`));
    }
    case "Choice": {
      const primitiveHelp = p("Select one of the following choices");
      const message = sequence(help, primitiveHelp);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: map3(self.alternatives, ([title]) => ({
          title,
          value: title
        }))
      });
    }
    case "DateTime": {
      const primitiveHelp = p("Enter a date");
      const message = sequence(help, primitiveHelp);
      return date2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map27((date5) => date5.toISOString()));
    }
    case "Float": {
      const primitiveHelp = p("Enter a floating point value");
      const message = sequence(help, primitiveHelp);
      return float({
        message: toAnsiText(message).trimEnd()
      }).pipe(map27((value5) => `${value5}`));
    }
    case "Integer": {
      const primitiveHelp = p("Enter an integer");
      const message = sequence(help, primitiveHelp);
      return integer2({
        message: toAnsiText(message).trimEnd()
      }).pipe(map27((value5) => `${value5}`));
    }
    case "Path": {
      const primitiveHelp = p("Select a file system path");
      const message = sequence(help, primitiveHelp);
      return file({
        type: self.pathType,
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Redacted": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Secret": {
      const primitiveHelp = p("Enter some text (value will be redacted)");
      const message = sequence(help, primitiveHelp);
      return hidden({
        message: toAnsiText(message).trimEnd()
      });
    }
    case "Text": {
      const primitiveHelp = p("Enter some text");
      const message = sequence(help, primitiveHelp);
      return text5({
        message: toAnsiText(message).trimEnd()
      });
    }
  }
};
var getBashCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return '"${cur}"';
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Secret":
    case "Redacted":
    case "Text": {
      return '$(compgen -f "${cur}")';
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -d "${cur}")' : "";
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? '$(compgen -f "${cur}")' : "";
        }
      }
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => choice3), join(","));
      return `$(compgen -W "${choices}" -- "\${cur}")`;
    }
  }
};
var getFishCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return empty2();
    }
    case "DateTime":
    case "Float":
    case "Integer":
    case "Redacted":
    case "Secret":
    case "Text": {
      return make4("-r", "-f");
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-f", "-a", `"(__fish_complete_directories (commandline -ct))"`) : make4("-r");
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? make4("-r", "-F") : make4("-r");
        }
      }
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([choice3]) => `${choice3}''`), join(","));
      return make4("-r", "-f", "-a", `"{${choices}}"`);
    }
  }
};
var getZshCompletions = (self) => {
  switch (self._tag) {
    case "Bool": {
      return "";
    }
    case "Choice": {
      const choices = pipe(map3(self.alternatives, ([name2]) => name2), join(" "));
      return `:CHOICE:(${choices})`;
    }
    case "DateTime": {
      return "";
    }
    case "Float": {
      return "";
    }
    case "Integer": {
      return "";
    }
    case "Path": {
      switch (self.pathType) {
        case "file": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files" : "";
        }
        case "directory": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files -/" : "";
        }
        case "either": {
          return self.pathExists === "yes" || self.pathExists === "either" ? ":PATH:_files" : "";
        }
      }
    }
    case "Redacted":
    case "Secret":
    case "Text": {
      return "";
    }
  }
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/prompt/list.js
var list3 = (options3) => text5(options3).pipe(map27((output) => output.split(options3.delimiter || ",")));

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/usage.js
var empty37 = {
  _tag: "Empty"
};
var mixed = {
  _tag: "Empty"
};
var named = (names, acceptedValues) => ({
  _tag: "Named",
  names,
  acceptedValues
});
var optional = (self) => ({
  _tag: "Optional",
  usage: self
});
var repeated2 = (self) => ({
  _tag: "Repeated",
  usage: self
});
var alternation = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Alternation",
  left: self,
  right: that
}));
var concat4 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: "Concat",
  left: self,
  right: that
}));
var getHelp2 = (self) => {
  const spans2 = enumerate(self, defaultConfig);
  if (isNonEmptyReadonlyArray(spans2)) {
    const head5 = headNonEmpty(spans2);
    const tail = tailNonEmpty(spans2);
    if (isNonEmptyReadonlyArray(tail)) {
      return pipe(map3(spans2, (span2) => p(span2)), reduceRight(empty36, (left3, right3) => sequence(left3, right3)));
    }
    return p(head5);
  }
  return empty36;
};
var enumerate = /* @__PURE__ */ dual(2, (self, config2) => render4(simplify(self, config2), config2));
var simplify = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return empty37;
    }
    case "Mixed": {
      return mixed;
    }
    case "Named": {
      if (isNone2(head(render4(self, config2)))) {
        return empty37;
      }
      return self;
    }
    case "Optional": {
      if (self.usage._tag === "Empty") {
        return empty37;
      }
      const usage = simplify(self.usage, config2);
      return usage._tag === "Empty" ? empty37 : usage._tag === "Optional" ? usage : optional(usage);
    }
    case "Repeated": {
      const usage = simplify(self.usage, config2);
      return usage._tag === "Empty" ? empty37 : repeated2(usage);
    }
    case "Alternation": {
      const leftUsage = simplify(self.left, config2);
      const rightUsage = simplify(self.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : alternation(leftUsage, rightUsage);
    }
    case "Concat": {
      const leftUsage = simplify(self.left, config2);
      const rightUsage = simplify(self.right, config2);
      return leftUsage._tag === "Empty" ? rightUsage : rightUsage._tag === "Empty" ? leftUsage : concat4(leftUsage, rightUsage);
    }
  }
};
var render4 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return of(text4(""));
    }
    case "Mixed": {
      return of(text4("<command>"));
    }
    case "Named": {
      const typeInfo = config2.showTypes ? match2(self.acceptedValues, {
        onNone: () => empty35,
        onSome: (s) => concat3(space3, text4(s))
      }) : empty35;
      const namesToShow = config2.showAllNames ? self.names : self.names.length > 1 ? pipe(filter2(self.names, (name2) => name2.startsWith("--")), head, map2(of), getOrElse(() => self.names)) : self.names;
      const nameInfo = text4(join(namesToShow, ", "));
      return config2.showAllNames && self.names.length > 1 ? of(spans([text4("("), nameInfo, typeInfo, text4(")")])) : of(concat3(nameInfo, typeInfo));
    }
    case "Optional": {
      return map3(render4(self.usage, config2), (span2) => spans([text4("["), span2, text4("]")]));
    }
    case "Repeated": {
      return map3(render4(self.usage, config2), (span2) => concat3(span2, text4("...")));
    }
    case "Alternation": {
      if (self.left._tag === "Repeated" || self.right._tag === "Repeated" || self.left._tag === "Concat" || self.right._tag === "Concat") {
        return appendAll(render4(self.left, config2), render4(self.right, config2));
      }
      return flatMap2(render4(self.left, config2), (left3) => map3(render4(self.right, config2), (right3) => spans([left3, text4("|"), right3])));
    }
    case "Concat": {
      const leftSpan = render4(self.left, config2);
      const rightSpan = render4(self.right, config2);
      const separator = isNonEmptyReadonlyArray(leftSpan) && isNonEmptyReadonlyArray(rightSpan) ? space3 : empty35;
      return flatMap2(leftSpan, (left3) => map3(rightSpan, (right3) => spans([left3, separator, right3])));
    }
  }
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/validationError.js
var ValidationErrorSymbolKey = "@effect/cli/ValidationError";
var ValidationErrorTypeId = /* @__PURE__ */ Symbol.for(ValidationErrorSymbolKey);
var proto20 = {
  [ValidationErrorTypeId]: ValidationErrorTypeId
};
var isValidationError = (u) => typeof u === "object" && u != null && ValidationErrorTypeId in u;
var isCommandMismatch = (self) => self._tag === "CommandMismatch";
var isHelpRequested = (self) => self._tag === "HelpRequested";
var isMultipleValuesDetected = (self) => self._tag === "MultipleValuesDetected";
var isMissingValue = (self) => self._tag === "MissingValue";
var commandMismatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CommandMismatch";
  op.error = error4;
  return op;
};
var correctedFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "CorrectedFlag";
  op.error = error4;
  return op;
};
var invalidArgument = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidArgument";
  op.error = error4;
  return op;
};
var invalidValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "InvalidValue";
  op.error = error4;
  return op;
};
var missingFlag = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingFlag";
  op.error = error4;
  return op;
};
var missingValue = (error4) => {
  const op = Object.create(proto20);
  op._tag = "MissingValue";
  op.error = error4;
  return op;
};
var multipleValuesDetected = (error4, values3) => {
  const op = Object.create(proto20);
  op._tag = "MultipleValuesDetected";
  op.error = error4;
  op.values = values3;
  return op;
};
var noBuiltInMatch = (error4) => {
  const op = Object.create(proto20);
  op._tag = "NoBuiltInMatch";
  op.error = error4;
  return op;
};
var unclusteredFlag = (error4, unclustered, rest) => {
  const op = Object.create(proto20);
  op._tag = "UnclusteredFlag";
  op.error = error4;
  op.unclustered = unclustered;
  op.rest = rest;
  return op;
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/options.js
var OptionsSymbolKey = "@effect/cli/Options";
var OptionsTypeId = /* @__PURE__ */ Symbol.for(OptionsSymbolKey);
var proto21 = {
  [OptionsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isOptions = (u) => typeof u === "object" && u != null && OptionsTypeId in u;
var isEmpty15 = (self) => self._tag === "Empty";
var isSingle2 = (self) => self._tag === "Single";
var all6 = function() {
  if (arguments.length === 1) {
    if (isOptions(arguments[0])) {
      return map28(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled(arguments[0]);
    } else {
      const entries2 = Object.entries(arguments[0]);
      let result = map28(entries2[0][1], (value5) => ({
        [entries2[0][0]]: value5
      }));
      if (entries2.length === 1) {
        return result;
      }
      const rest = entries2.slice(1);
      for (const [key, options3] of rest) {
        result = map28(makeBoth(result, options3), ([record2, value5]) => ({
          ...record2,
          [key]: value5
        }));
      }
      return result;
    }
  }
  return allTupled(arguments[0]);
};
var defaultBooleanOptions = {
  ifPresent: true,
  negationNames: [],
  aliases: []
};
var boolean4 = (name2, options3) => {
  const {
    aliases,
    ifPresent,
    negationNames
  } = {
    ...defaultBooleanOptions,
    ...options3
  };
  const option4 = makeSingle(name2, aliases, boolean3(some2(ifPresent)));
  if (isNonEmptyReadonlyArray(negationNames)) {
    const head5 = headNonEmpty(negationNames);
    const tail = tailNonEmpty(negationNames);
    const negationOption = makeSingle(head5, tail, boolean3(some2(!ifPresent)));
    return withDefault2(orElse13(option4, negationOption), !ifPresent);
  }
  return withDefault2(option4, !ifPresent);
};
var choiceWithValue = (name2, choices) => makeSingle(name2, empty2(), choice(choices));
var file2 = (name2, config2) => makeSingle(name2, empty2(), path("file", config2?.exists));
var fileParse = (name2, format6) => mapEffect5(fileText(name2), ([path2, content]) => mapError2(parse5(path2, content, format6), (error4) => invalidValue(p(error4))));
var fileText = (name2) => mapEffect5(file2(name2, {
  exists: "yes"
}), (path2) => mapError2(readString(path2), (error4) => invalidValue(p(error4))));
var none10 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto21);
  op._tag = "Empty";
  return op;
})();
var text7 = (name2) => makeSingle(name2, empty2(), text6);
var getHelp3 = (self) => getHelpInternal2(self);
var getUsage = (self) => getUsageInternal(self);
var map28 = /* @__PURE__ */ dual(2, (self, f) => makeMap(self, (a) => right2(f(a))));
var mapEffect5 = /* @__PURE__ */ dual(2, (self, f) => makeMap(self, f));
var optional2 = (self) => withDefault2(map28(self, some2), none2());
var orElse13 = /* @__PURE__ */ dual(2, (self, that) => orElseEither4(self, that).pipe(map28(merge)));
var orElseEither4 = /* @__PURE__ */ dual(2, (self, that) => makeOrElse(self, that));
var processCommandLine = /* @__PURE__ */ dual(3, (self, args2, config2) => matchOptions(args2, toParseableInstruction(self), config2).pipe(flatMap9(([error4, commandArgs, matchedOptions]) => parseInternal(self, matchedOptions, config2).pipe(catchAll2((e) => match2(error4, {
  onNone: () => fail8(e),
  onSome: (err) => fail8(err)
})), map17((a) => [error4, commandArgs, a])))));
var withAlias = /* @__PURE__ */ dual(2, (self, alias) => modifySingle(self, (single) => {
  const aliases = append(single.aliases, alias);
  return makeSingle(single.name, aliases, single.primitiveType, single.description, single.pseudoName);
}));
var withDefault2 = /* @__PURE__ */ dual(2, (self, fallback) => makeWithDefault(self, fallback));
var withDescription2 = /* @__PURE__ */ dual(2, (self, desc) => modifySingle(self, (single) => {
  const description = sequence(single.description, p(desc));
  return makeSingle(single.name, single.aliases, single.primitiveType, description, single.pseudoName);
}));
var wizard2 = /* @__PURE__ */ dual(2, (self, config2) => wizardInternal2(self, config2));
var allTupled = (arg) => {
  if (arg.length === 0) {
    return none10;
  }
  if (arg.length === 1) {
    return map28(arg[0], (x) => [x]);
  }
  let result = map28(arg[0], (x) => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map28(makeBoth(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty36;
    }
    case "Single": {
      return descriptionList(of([getSpan(getHelp2(getUsageInternal(self))), sequence(p(getHelp(self.primitiveType)), self.description)]));
    }
    case "KeyValueMap": {
      const identifier3 = getOrThrow2(getIdentifierInternal(self.argumentOption));
      return mapDescriptionList(getHelpInternal2(self.argumentOption), (span2, oldBlock) => {
        const header = p("This setting is a property argument which:");
        const single = `${identifier3} key1=value key2=value2`;
        const multiple = `${identifier3} key1=value ${identifier3} key2=value2`;
        const description = enumeration([p(`May be specified a single time:  '${single}'`), p(`May be specified multiple times: '${multiple}'`)]);
        const newBlock = pipe(oldBlock, sequence(header), sequence(description));
        return [span2, newBlock];
      });
    }
    case "Map": {
      return getHelpInternal2(self.options);
    }
    case "Both":
    case "OrElse": {
      return sequence(getHelpInternal2(self.left), getHelpInternal2(self.right));
    }
    case "Variadic": {
      const help = getHelpInternal2(self.argumentOption);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min4 = getMinSizeInternal(self);
        const max6 = getMaxSizeInternal(self);
        const newSpan = text4(isSome2(self.max) ? ` ${min4} - ${max6}` : min4 === 0 ? "..." : ` ${min4}+`);
        const newBlock = p(isSome2(self.max) ? `This option must be repeated at least ${min4} times and may be repeated up to ${max6} times.` : min4 === 0 ? "This option may be repeated zero or more times." : `This option must be repeated at least ${min4} times.`);
        return [concat3(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal2(self.options), (span2, block) => {
        const optionalDescription = isOption2(self.fallback) ? match2(self.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span2, sequence(block, optionalDescription)];
      });
    }
    case "WithFallback": {
      const helpDoc = isConfig2(self.effect) ? p("This option can be set from environment variables.") : isPrompt(self.effect) ? p("Will prompt the user for input if this option is not provided.") : empty36;
      return mapDescriptionList(getHelpInternal2(self.options), (span2, block) => [span2, sequence(block, helpDoc)]);
    }
  }
};
var getIdentifierInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return none2();
    }
    case "Single": {
      return some2(self.fullName);
    }
    case "Both":
    case "OrElse": {
      const ids3 = getSomes([getIdentifierInternal(self.left), getIdentifierInternal(self.right)]);
      return match3(ids3, {
        onEmpty: () => none2(),
        onNonEmpty: (ids4) => some2(join(ids4, ", "))
      });
    }
    case "KeyValueMap":
    case "Variadic": {
      return getIdentifierInternal(self.argumentOption);
    }
    case "Map":
    case "WithFallback":
    case "WithDefault": {
      return getIdentifierInternal(self.options);
    }
  }
};
var getMinSizeInternal = (self) => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallback": {
      return 0;
    }
    case "Single":
    case "KeyValueMap": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal(self.options);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal(self.left);
      const rightMinSize = getMinSizeInternal(self.right);
      return leftMinSize + rightMinSize;
    }
    case "OrElse": {
      const leftMinSize = getMinSizeInternal(self.left);
      const rightMinSize = getMinSizeInternal(self.right);
      return Math.min(leftMinSize, rightMinSize);
    }
    case "Variadic": {
      const selfMinSize = getOrElse(self.min, () => 0);
      const argumentOptionMinSize = getMinSizeInternal(self.argumentOption);
      return selfMinSize * argumentOptionMinSize;
    }
  }
};
var getMaxSizeInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "KeyValueMap": {
      return Number.MAX_SAFE_INTEGER;
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getMaxSizeInternal(self.options);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal(self.left);
      const rightMaxSize = getMaxSizeInternal(self.right);
      return leftMaxSize + rightMaxSize;
    }
    case "OrElse": {
      const leftMin = getMaxSizeInternal(self.left);
      const rightMin = getMaxSizeInternal(self.right);
      return Math.min(leftMin, rightMin);
    }
    case "Variadic": {
      const selfMaxSize = getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2);
      const optionsMaxSize = getMaxSizeInternal(self.argumentOption);
      return Math.floor(selfMaxSize * optionsMaxSize);
    }
  }
};
var getUsageInternal = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty37;
    }
    case "Single": {
      const acceptedValues = isBool(self.primitiveType) ? none2() : orElse(getChoices(self.primitiveType), () => some2(self.placeholder));
      return named(getNames(self), acceptedValues);
    }
    case "KeyValueMap": {
      return getUsageInternal(self.argumentOption);
    }
    case "Map": {
      return getUsageInternal(self.options);
    }
    case "Both": {
      return concat4(getUsageInternal(self.left), getUsageInternal(self.right));
    }
    case "OrElse": {
      return alternation(getUsageInternal(self.left), getUsageInternal(self.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal(self.argumentOption));
    }
    case "WithDefault":
    case "WithFallback": {
      return optional(getUsageInternal(self.options));
    }
  }
};
var isBoolInternal = (self) => {
  switch (self._tag) {
    case "Single": {
      return isBool(self.primitiveType);
    }
    case "Map": {
      return isBoolInternal(self.options);
    }
    case "WithDefault": {
      return isBoolInternal(self.options);
    }
    default: {
      return false;
    }
  }
};
var makeBoth = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeFullName = (str) => str.length === 1 ? [true, `-${str}`] : [false, `--${str}`];
var makeKeyValueMap = (argumentOption) => {
  const op = Object.create(proto21);
  op._tag = "KeyValueMap";
  op.argumentOption = argumentOption;
  return op;
};
var makeMap = (options3, f) => {
  const op = Object.create(proto21);
  op._tag = "Map";
  op.options = options3;
  op.f = f;
  return op;
};
var makeOrElse = (left3, right3) => {
  const op = Object.create(proto21);
  op._tag = "OrElse";
  op.left = left3;
  op.right = right3;
  return op;
};
var makeSingle = (name2, aliases, primitiveType, description = empty36, pseudoName = none2()) => {
  const op = Object.create(proto21);
  op._tag = "Single";
  op.name = name2;
  op.fullName = makeFullName(name2)[1];
  op.placeholder = `${getOrElse(pseudoName, () => getTypeName(primitiveType))}`;
  op.aliases = aliases;
  op.primitiveType = primitiveType;
  op.description = description;
  op.pseudoName = pseudoName;
  return op;
};
var makeVariadic = (argumentOption, min4, max6) => {
  if (!isSingle2(argumentOption)) {
    throw new Error("InvalidArgumentException: only single options can be variadic");
  }
  const op = Object.create(proto21);
  op._tag = "Variadic";
  op.argumentOption = argumentOption;
  op.min = min4;
  op.max = max6;
  return op;
};
var makeWithDefault = (options3, fallback) => {
  const op = Object.create(proto21);
  op._tag = "WithDefault";
  op.options = options3;
  op.fallback = fallback;
  return op;
};
var makeWithFallback = (options3, effect3) => {
  const op = Object.create(proto21);
  op._tag = "WithFallback";
  op.options = options3;
  op.effect = effect3;
  return op;
};
var modifySingle = (self, f) => {
  switch (self._tag) {
    case "Empty": {
      return none10;
    }
    case "Single": {
      return f(self);
    }
    case "KeyValueMap": {
      return makeKeyValueMap(f(self.argumentOption));
    }
    case "Map": {
      return makeMap(modifySingle(self.options, f), self.f);
    }
    case "Both": {
      return makeBoth(modifySingle(self.left, f), modifySingle(self.right, f));
    }
    case "OrElse": {
      return makeOrElse(modifySingle(self.left, f), modifySingle(self.right, f));
    }
    case "Variadic": {
      return makeVariadic(f(self.argumentOption), self.min, self.max);
    }
    case "WithDefault": {
      return makeWithDefault(modifySingle(self.options, f), self.fallback);
    }
    case "WithFallback": {
      return makeWithFallback(modifySingle(self.options, f), self.effect);
    }
  }
};
var getNames = (self) => {
  const loop2 = (self2) => {
    switch (self2._tag) {
      case "Empty": {
        return empty2();
      }
      case "Single": {
        return prepend(self2.aliases, self2.name);
      }
      case "KeyValueMap":
      case "Variadic": {
        return loop2(self2.argumentOption);
      }
      case "Map":
      case "WithDefault":
      case "WithFallback": {
        return loop2(self2.options);
      }
      case "Both":
      case "OrElse": {
        const left3 = loop2(self2.left);
        const right3 = loop2(self2.right);
        return appendAll(left3, right3);
      }
    }
  };
  const order = mapInput2(boolean, (tuple3) => !tuple3[0]);
  return pipe(loop2(self), map3((str) => makeFullName(str)), sort(order), map3((tuple3) => tuple3[1]));
};
var toParseableInstruction = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single":
    case "KeyValueMap":
    case "Variadic": {
      return of(self);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return toParseableInstruction(self.options);
    }
    case "Both":
    case "OrElse": {
      return appendAll(toParseableInstruction(self.left), toParseableInstruction(self.right));
    }
  }
};
var keyValueSplitter = /=(.*)/;
var parseInternal = (self, args2, config2) => {
  switch (self._tag) {
    case "Empty": {
      return _void;
    }
    case "Single": {
      const singleNames = filterMap2(getNames(self), (name2) => get7(args2, name2));
      if (isNonEmptyReadonlyArray(singleNames)) {
        const head5 = headNonEmpty(singleNames);
        const tail = tailNonEmpty(singleNames);
        if (isEmptyReadonlyArray(tail)) {
          if (isEmptyReadonlyArray(head5)) {
            return validate4(self.primitiveType, none2(), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          if (isNonEmptyReadonlyArray(head5) && isEmptyReadonlyArray(tailNonEmpty(head5))) {
            const value5 = headNonEmpty(head5);
            return validate4(self.primitiveType, some2(value5), config2).pipe(mapError2((e) => invalidValue(p(e))));
          }
          return fail8(multipleValuesDetected(empty36, head5));
        }
        const error5 = p(`More than one reference to option '${self.fullName}' detected`);
        return fail8(invalidValue(error5));
      }
      const error4 = p(`Expected to find option: '${self.fullName}'`);
      return fail8(missingValue(error4));
    }
    case "KeyValueMap": {
      const extractKeyValue = (value5) => {
        const split2 = value5.trim().split(keyValueSplitter, 2);
        if (isNonEmptyReadonlyArray(split2) && split2.length === 2 && split2[1] !== "") {
          return succeed8(split2);
        }
        const error4 = p(`Expected a key/value pair but received '${value5}'`);
        return fail8(invalidArgument(error4));
      };
      return parseInternal(self.argumentOption, args2, config2).pipe(matchEffect2({
        onFailure: (e) => isMultipleValuesDetected(e) ? forEach8(e.values, (kv) => extractKeyValue(kv)).pipe(map17(fromIterable6)) : fail8(e),
        onSuccess: (kv) => extractKeyValue(kv).pipe(map17(make16))
      }));
    }
    case "Map": {
      return parseInternal(self.options, args2, config2).pipe(flatMap9((a) => self.f(a)));
    }
    case "Both": {
      return parseInternal(self.left, args2, config2).pipe(catchAll2((err1) => parseInternal(self.right, args2, config2).pipe(matchEffect2({
        onFailure: (err2) => {
          const error4 = sequence(err1.error, err2.error);
          return fail8(missingValue(error4));
        },
        onSuccess: () => fail8(err1)
      }))), zip6(parseInternal(self.right, args2, config2)));
    }
    case "OrElse": {
      return parseInternal(self.left, args2, config2).pipe(matchEffect2({
        onFailure: (err1) => parseInternal(self.right, args2, config2).pipe(mapBoth4({
          onFailure: (err2) => (
            // orElse option is only missing in case neither option was given
            isMissingValue(err1) && isMissingValue(err2) ? missingValue(sequence(err1.error, err2.error)) : invalidValue(sequence(err1.error, err2.error))
          ),
          onSuccess: (b) => right2(b)
        })),
        onSuccess: (a) => parseInternal(self.right, args2, config2).pipe(matchEffect2({
          onFailure: () => succeed8(left2(a)),
          onSuccess: () => {
            const leftUid = getOrElse(getIdentifierInternal(self.left), () => "???");
            const rightUid = getOrElse(getIdentifierInternal(self.right), () => "???");
            const error4 = p(`Collision between two options detected - you can only specify one of either: ['${leftUid}', '${rightUid}']`);
            return fail8(invalidValue(error4));
          }
        }))
      }));
    }
    case "Variadic": {
      const min4 = getOrElse(self.min, () => 0);
      const max6 = getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
      const matchedArgument = filterMap2(getNames(self), (name2) => get7(args2, name2));
      const validateMinMax = (values3) => {
        if (values3.length < min4) {
          const name2 = self.argumentOption.fullName;
          const error4 = `Expected at least ${min4} value(s) for option: '${name2}'`;
          return fail8(invalidValue(p(error4)));
        }
        if (values3.length > max6) {
          const name2 = self.argumentOption.fullName;
          const error4 = `Expected at most ${max6} value(s) for option: '${name2}'`;
          return fail8(invalidValue(p(error4)));
        }
        const primitive2 = self.argumentOption.primitiveType;
        const validatePrimitive = (value5) => validate4(primitive2, some2(value5), config2).pipe(mapError2((e) => invalidValue(p(e))));
        return forEach8(values3, (value5) => validatePrimitive(value5));
      };
      if (every(matchedArgument, isEmptyReadonlyArray)) {
        return validateMinMax(empty2());
      }
      return parseInternal(self.argumentOption, args2, config2).pipe(matchEffect2({
        onFailure: (error4) => isMultipleValuesDetected(error4) ? validateMinMax(error4.values) : fail8(error4),
        onSuccess: (value5) => validateMinMax(of(value5))
      }));
    }
    case "WithDefault": {
      return parseInternal(self.options, args2, config2).pipe(catchTag2("MissingValue", () => succeed8(self.fallback)));
    }
    case "WithFallback": {
      return parseInternal(self.options, args2, config2).pipe(catchTag2("MissingValue", (e) => self.effect.pipe(catchAll2((e2) => {
        if (isTagged(e2, "QuitException")) {
          return die5(e2);
        }
        if (isConfigError2(e2) && !isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail8(error4);
        }
        return fail8(e);
      }))));
    }
  }
};
var wizardInternal2 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed8(empty2());
    }
    case "Single": {
      const help = getHelpInternal2(self);
      return wizard(self.primitiveType, help).pipe(flatMap9((input) => {
        const args2 = make4(getNames(self)[0], input);
        return parseCommandLine(self, args2, config2).pipe(as4(args2));
      }), zipLeft2(log2()));
    }
    case "KeyValueMap": {
      const message = p("Enter `key=value` pairs separated by spaces");
      return list3({
        message: toAnsiText(message).trim(),
        delimiter: " "
      }).pipe(flatMap9((args2) => {
        const identifier3 = getOrElse(getIdentifierInternal(self), () => "");
        return parseInternal(self, make16([identifier3, args2]), config2).pipe(as4(prepend(args2, identifier3)));
      }), zipLeft2(log2()));
    }
    case "Map": {
      return wizardInternal2(self.options, config2);
    }
    case "Both": {
      return zipWith5(wizardInternal2(self.left, config2), wizardInternal2(self.right, config2), (left3, right3) => appendAll(left3, right3));
    }
    case "OrElse": {
      const alternativeHelp = p("Select which option you would like to use");
      const message = pipe(getHelpInternal2(self), sequence(alternativeHelp));
      const makeChoice = (title, value5) => ({
        title,
        value: value5
      });
      const choices = getSomes([map2(getIdentifierInternal(self.left), (title) => makeChoice(title, self.left)), map2(getIdentifierInternal(self.right), (title) => makeChoice(title, self.right))]);
      return select({
        message: toAnsiText(message).trimEnd(),
        choices
      }).pipe(flatMap9((option4) => wizardInternal2(option4, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument be repeated?");
      const message = pipe(getHelpInternal2(self), sequence(repeatHelp));
      return integer2({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal(self),
        max: getMaxSizeInternal(self)
      }).pipe(flatMap9((n) => n <= 0 ? succeed8(empty2()) : make28(empty2()).pipe(flatMap9((ref) => wizardInternal2(self.argumentOption, config2).pipe(flatMap9((args2) => update3(ref, appendAll(args2))), repeatN2(n - 1), zipRight3(get11(ref)))))));
    }
    case "WithDefault": {
      if (isBoolInternal(self.options)) {
        return wizardInternal2(self.options, config2);
      }
      const defaultHelp = p(`This option is optional - use the default?`);
      const message = pipe(getHelpInternal2(self.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: "Yes",
          value: true,
          description: `use the default ${isOption2(self.fallback) ? match2(self.fallback, {
            onNone: () => "",
            onSome: (a) => `(${JSON.stringify(a)})`
          }) : `(${JSON.stringify(self.fallback)})`}`
        }, {
          title: "No",
          value: false,
          description: "use a custom value"
        }]
      }).pipe(zipLeft2(log2()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal2(self.options, config2)));
    }
    case "WithFallback": {
      if (isBoolInternal(self.options)) {
        return wizardInternal2(self.options, config2);
      }
      if (isPrompt(self.effect)) {
        return wizardInternal2(self.options, config2);
      }
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal2(self.options), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log2()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal2(self.options, config2)));
    }
  }
};
var matchOptions = (input, options3, config2) => {
  if (isNonEmptyReadonlyArray(options3)) {
    return findOptions(input, options3, config2).pipe(flatMap9(([otherArgs, otherOptions, map1]) => {
      if (isEmpty3(map1)) {
        return succeed8([none2(), input, map1]);
      }
      return matchOptions(otherArgs, otherOptions, config2).pipe(map17(([error4, otherArgs2, map210]) => [error4, otherArgs2, merge9(map1, fromIterable(map210))]));
    }), catchAll2((e) => succeed8([some2(e), input, empty9()])));
  }
  return isEmptyReadonlyArray(input) ? succeed8([none2(), empty2(), empty9()]) : succeed8([none2(), input, empty9()]);
};
var findOptions = (input, options3, config2) => matchLeft(options3, {
  onEmpty: () => succeed8([input, empty2(), empty9()]),
  onNonEmpty: (head5, tail) => parseCommandLine(head5, input, config2).pipe(flatMap9(({
    leftover: leftover2,
    parsed
  }) => match2(parsed, {
    onNone: () => findOptions(leftover2, tail, config2).pipe(map17(([nextArgs, nextOptions, map33]) => [nextArgs, prepend(nextOptions, head5), map33])),
    onSome: ({
      name: name2,
      values: values3
    }) => succeed8([leftover2, tail, make16([name2, values3])])
  })), catchTags2({
    CorrectedFlag: (e) => findOptions(input, tail, config2).pipe(catchSome2(() => some2(fail8(e))), flatMap9(([otherArgs, otherOptions, map33]) => fail8(e).pipe(when2(() => isEmpty3(map33)), as4([otherArgs, prepend(otherOptions, head5), map33])))),
    MissingFlag: () => findOptions(input, tail, config2).pipe(map17(([otherArgs, otherOptions, map33]) => [otherArgs, prepend(otherOptions, head5), map33])),
    UnclusteredFlag: (e) => matchUnclustered(e.unclustered, e.rest, options3, config2).pipe(catchAll2(() => fail8(e)))
  }))
});
var CLUSTERED_REGEX = /^-{1}([^-]{2,}$)/;
var FLAG_REGEX = /^(--[^=]+)(?:=(.+))?$/;
var processArgs = (args2) => matchLeft(args2, {
  onEmpty: () => succeed8(empty2()),
  onNonEmpty: (head5, tail) => {
    const value5 = head5.trim();
    if (CLUSTERED_REGEX.test(value5)) {
      const unclustered = value5.substring(1).split("").map((c) => `-${c}`);
      return fail8(unclusteredFlag(empty36, unclustered, tail));
    }
    if (FLAG_REGEX.test(value5)) {
      const result = FLAG_REGEX.exec(value5);
      if (result !== null && result[2] !== void 0) {
        return succeed8(appendAll([result[1], result[2]], tail));
      }
    }
    return succeed8(args2);
  }
});
var parseCommandLine = (self, args2, config2) => {
  switch (self._tag) {
    case "Single": {
      return processArgs(args2).pipe(flatMap9((args3) => matchLeft(args3, {
        onEmpty: () => {
          const error4 = p(`Expected to find option: '${self.fullName}'`);
          return fail8(missingFlag(error4));
        },
        onNonEmpty: (head5, tail) => {
          const normalize = (value5) => normalizeCase(config2, value5);
          const normalizedHead = normalize(head5);
          const normalizedNames = map3(getNames(self), (name2) => normalize(name2));
          if (contains2(normalizedNames, normalizedHead)) {
            if (isBool(self.primitiveType)) {
              return matchLeft(tail, {
                onEmpty: () => {
                  const parsed = some2({
                    name: head5,
                    values: empty2()
                  });
                  return succeed8({
                    parsed,
                    leftover: tail
                  });
                },
                onNonEmpty: (value5, leftover2) => {
                  if (isTrueValue(value5)) {
                    const parsed2 = some2({
                      name: head5,
                      values: of("true")
                    });
                    return succeed8({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  if (isFalseValue(value5)) {
                    const parsed2 = some2({
                      name: head5,
                      values: of("false")
                    });
                    return succeed8({
                      parsed: parsed2,
                      leftover: leftover2
                    });
                  }
                  const parsed = some2({
                    name: head5,
                    values: empty2()
                  });
                  return succeed8({
                    parsed,
                    leftover: tail
                  });
                }
              });
            }
            return matchLeft(tail, {
              onEmpty: () => {
                const error5 = p(`Expected a value following option: '${self.fullName}'`);
                return fail8(missingValue(error5));
              },
              onNonEmpty: (value5, leftover2) => {
                const parsed = some2({
                  name: head5,
                  values: of(value5)
                });
                return succeed8({
                  parsed,
                  leftover: leftover2
                });
              }
            });
          }
          if (self.name.length > config2.autoCorrectLimit + 1 && levensteinDistance(head5, self.fullName, config2) <= config2.autoCorrectLimit) {
            const error5 = p(`The flag '${head5}' is not recognized. Did you mean '${self.fullName}'?`);
            return fail8(correctedFlag(error5));
          }
          const error4 = p(`Expected to find option: '${self.fullName}'`);
          return fail8(missingFlag(error4));
        }
      })));
    }
    case "KeyValueMap": {
      const normalizedNames = map3(getNames(self.argumentOption), (name2) => normalizeCase(config2, name2));
      return matchLeft(args2, {
        onEmpty: () => succeed8({
          parsed: none2(),
          leftover: args2
        }),
        onNonEmpty: (head5, tail) => {
          const loop2 = (args3) => {
            let keyValues = empty2();
            let leftover2 = args3;
            while (isNonEmptyReadonlyArray(leftover2)) {
              const name2 = headNonEmpty(leftover2).trim();
              const normalizedName2 = normalizeCase(config2, name2);
              if (leftover2.length >= 2 && contains2(normalizedNames, normalizedName2)) {
                const keyValue = leftover2[1].trim();
                const [key, value5] = keyValue.split("=");
                if (key !== void 0 && value5 !== void 0 && value5.length > 0) {
                  keyValues = append(keyValues, keyValue);
                  leftover2 = leftover2.slice(2);
                  continue;
                }
              }
              if (name2.includes("=")) {
                const [key, value5] = name2.split("=");
                if (key !== void 0 && value5 !== void 0 && value5.length > 0) {
                  keyValues = append(keyValues, name2);
                  leftover2 = leftover2.slice(1);
                  continue;
                }
              }
              break;
            }
            return [keyValues, leftover2];
          };
          const normalizedName = normalizeCase(config2, head5);
          if (contains2(normalizedNames, normalizedName)) {
            const [values3, leftover2] = loop2(tail);
            return succeed8({
              parsed: some2({
                name: head5,
                values: values3
              }),
              leftover: leftover2
            });
          }
          return succeed8({
            parsed: none2(),
            leftover: args2
          });
        }
      });
    }
    case "Variadic": {
      const normalizedNames = map3(getNames(self.argumentOption), (name2) => normalizeCase(config2, name2));
      let optionName = void 0;
      let values3 = empty2();
      let unparsed = args2;
      let leftover2 = empty2();
      while (isNonEmptyReadonlyArray(unparsed)) {
        const name2 = headNonEmpty(unparsed);
        const normalizedName = normalizeCase(config2, name2);
        if (contains2(normalizedNames, normalizedName)) {
          if (optionName === void 0) {
            optionName = name2;
          }
          const value5 = unparsed[1];
          if (value5 !== void 0 && value5.length > 0) {
            values3 = append(values3, value5.trim());
          }
          unparsed = unparsed.slice(2);
        } else {
          leftover2 = append(leftover2, headNonEmpty(unparsed));
          unparsed = unparsed.slice(1);
        }
      }
      const parsed = fromNullable(optionName).pipe(orElse(() => some2(self.argumentOption.fullName)), map2((name2) => ({
        name: name2,
        values: values3
      })));
      return succeed8({
        parsed,
        leftover: leftover2
      });
    }
  }
};
var matchUnclustered = (input, tail, options3, config2) => {
  if (isNonEmptyReadonlyArray(input)) {
    const flag = headNonEmpty(input);
    const otherFlags = tailNonEmpty(input);
    return findOptions(of(flag), options3, config2).pipe(flatMap9(([_, opts1, map1]) => {
      if (isEmpty3(map1)) {
        return fail8(unclusteredFlag(empty36, empty2(), tail));
      }
      return matchUnclustered(otherFlags, tail, opts1, config2).pipe(map17(([_2, opts2, map210]) => [tail, opts2, merge9(map1, fromIterable(map210))]));
    }));
  }
  return succeed8([tail, options3, empty9()]);
};
var merge9 = (map1, map210) => {
  if (isNonEmptyReadonlyArray(map210)) {
    const head5 = headNonEmpty(map210);
    const tail = tailNonEmpty(map210);
    const newMap = match2(get7(map1, head5[0]), {
      onNone: () => set3(map1, head5[0], head5[1]),
      onSome: (elems) => set3(map1, head5[0], appendAll(elems, head5[1]))
    });
    return merge9(newMap, tail);
  }
  return map1;
};
var escape2 = (string7) => string7.replaceAll("\\", "\\\\").replaceAll("'", "'\\''").replaceAll("[", "\\[").replaceAll("]", "\\]").replaceAll(":", "\\:").replaceAll("$", "\\$").replaceAll("`", "\\`").replaceAll("(", "\\(").replaceAll(")", "\\)");
var getShortDescription = (self) => {
  switch (self._tag) {
    case "Empty":
    case "Both":
    case "OrElse": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self.description));
    }
    case "KeyValueMap":
    case "Variadic": {
      return getShortDescription(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getShortDescription(self.options);
    }
  }
};
var getBashCompletions2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const names = getNames(self);
      const cases = join(names, "|");
      const compgen = getBashCompletions(self.primitiveType);
      return make4(`${cases})`, `    COMPREPLY=( ${compgen} )`, `    return 0`, `    ;;`);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getBashCompletions2(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getBashCompletions2(self.options);
    }
    case "Both":
    case "OrElse": {
      const left3 = getBashCompletions2(self.left);
      const right3 = getBashCompletions2(self.right);
      return appendAll(left3, right3);
    }
  }
};
var getFishCompletions2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const description = getShortDescription(self);
      const order = mapInput2(boolean, (tuple3) => !tuple3[0]);
      return pipe(prepend(self.aliases, self.name), map3((name2) => [name2.length === 1, name2]), sort(order), flatMap2(([isShort, name2]) => make4(isShort ? "-s" : "-l", name2)), appendAll(getFishCompletions(self.primitiveType)), appendAll(description.length === 0 ? empty2() : of(`-d '${description}'`)), join(" "), of);
    }
    case "KeyValueMap":
    case "Variadic": {
      return getFishCompletions2(self.argumentOption);
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getFishCompletions2(self.options);
    }
    case "Both":
    case "OrElse": {
      return pipe(getFishCompletions2(self.left), appendAll(getFishCompletions2(self.right)));
    }
  }
};
var getZshCompletions2 = (self, state = {
  conflicts: empty2(),
  multiple: false
}) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const names = getNames(self);
      const description = getShortDescription(self);
      const possibleValues = getZshCompletions(self.primitiveType);
      const multiple = state.multiple ? "*" : "";
      const conflicts = isNonEmptyReadonlyArray(state.conflicts) ? `(${join(state.conflicts, " ")})` : "";
      return map3(names, (name2) => `${conflicts}${multiple}${name2}[${escape2(description)}]${possibleValues}`);
    }
    case "KeyValueMap": {
      return getZshCompletions2(self.argumentOption, {
        ...state,
        multiple: true
      });
    }
    case "Map":
    case "WithDefault":
    case "WithFallback": {
      return getZshCompletions2(self.options, state);
    }
    case "Both": {
      const left3 = getZshCompletions2(self.left, state);
      const right3 = getZshCompletions2(self.right, state);
      return appendAll(left3, right3);
    }
    case "OrElse": {
      const leftNames = getNames(self.left);
      const rightNames = getNames(self.right);
      const left3 = getZshCompletions2(self.left, {
        ...state,
        conflicts: appendAll(state.conflicts, rightNames)
      });
      const right3 = getZshCompletions2(self.right, {
        ...state,
        conflicts: appendAll(state.conflicts, leftNames)
      });
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self.max) && self.max.value > 1 ? getZshCompletions2(self.argumentOption, {
        ...state,
        multiple: true
      }) : getZshCompletions2(self.argumentOption, state);
    }
  }
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/Options.js
var all7 = all6;
var boolean5 = boolean4;
var fileParse2 = fileParse;
var text8 = text7;
var withAlias2 = withAlias;
var withDefault3 = withDefault2;
var withDescription3 = withDescription2;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/commandExecutor.js
var TypeId20 = /* @__PURE__ */ Symbol.for("@effect/platform/CommandExecutor");
var ProcessTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Process");
var ExitCode = /* @__PURE__ */ nominal();
var ProcessId = /* @__PURE__ */ nominal();
var CommandExecutor = /* @__PURE__ */ GenericTag("@effect/platform/CommandExecutor");
var makeExecutor = (start4) => {
  const stream3 = (command) => unwrapScoped6(map17(start4(command), (process2) => process2.stdout));
  const streamLines2 = (command, encoding) => {
    const decoder = new TextDecoder(encoding);
    return splitLines3(mapChunks2(stream3(command), map4((bytes) => decoder.decode(bytes))));
  };
  return {
    [TypeId20]: TypeId20,
    start: start4,
    exitCode: (command) => scoped2(flatMap9(start4(command), (process2) => process2.exitCode)),
    stream: stream3,
    string: (command, encoding = "utf-8") => {
      const decoder = new TextDecoder(encoding);
      return pipe(start4(command), flatMap9((process2) => run4(process2.stdout, collectUint8Array)), map17((bytes) => decoder.decode(bytes)), scoped2);
    },
    lines: (command, encoding = "utf-8") => {
      return pipe(streamLines2(command, encoding), runCollect3, map17(toArray2));
    },
    streamLines: streamLines2
  };
};
var collectUint8Array = /* @__PURE__ */ foldLeftChunks2(/* @__PURE__ */ new Uint8Array(), (bytes, chunk4) => reduce2(chunk4, bytes, (acc, curr) => {
  const newArray = new Uint8Array(acc.length + curr.length);
  newArray.set(acc);
  newArray.set(curr, acc.length);
  return newArray;
}));

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/command.js
var CommandTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Command");
var flatten13 = (self) => Array.from(flattenLoop(self));
var flattenLoop = (self) => {
  switch (self._tag) {
    case "StandardCommand": {
      return of2(self);
    }
    case "PipedCommand": {
      return appendAll2(flattenLoop(self.left), flattenLoop(self.right));
    }
  }
};
var Proto2 = {
  [CommandTypeId]: CommandTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto
};
var StandardProto = {
  ...Proto2,
  _tag: "StandardCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      command: this.command,
      args: this.args,
      env: Object.fromEntries(this.env),
      cwd: this.cwd.toJSON(),
      shell: this.shell,
      gid: this.gid.toJSON(),
      uid: this.uid.toJSON()
    };
  }
};
var makeStandard = (options3) => Object.assign(Object.create(StandardProto), options3);
var PipedProto = {
  ...Proto2,
  _tag: "PipedCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      left: this.left.toJSON(),
      right: this.right.toJSON()
    };
  }
};
var makePiped = (options3) => Object.assign(Object.create(PipedProto), options3);
var stdin = /* @__PURE__ */ dual(2, (self, input) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        stdin: input
      });
    }
    // For piped commands it only makes sense to provide `stdin` for the
    // left-most command as the rest will be piped in.
    case "PipedCommand": {
      return makePiped({
        ...self,
        left: stdin(self.left, input)
      });
    }
  }
});

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Command.js
var flatten14 = flatten13;
var stdin2 = stdin;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/CommandExecutor.js
var CommandExecutor2 = CommandExecutor;
var ProcessTypeId2 = ProcessTypeId;
var ExitCode2 = ExitCode;
var ProcessId2 = ProcessId;
var makeExecutor2 = makeExecutor;

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/internal/error.js
var handleErrnoException = (module, method) => (err, [path2]) => {
  let reason = "Unknown";
  switch (err.code) {
    case "ENOENT":
      reason = "NotFound";
      break;
    case "EACCES":
      reason = "PermissionDenied";
      break;
    case "EEXIST":
      reason = "AlreadyExists";
      break;
    case "EISDIR":
      reason = "BadResource";
      break;
    case "ENOTDIR":
      reason = "BadResource";
      break;
    case "EBUSY":
      reason = "Busy";
      break;
    case "ELOOP":
      reason = "BadResource";
      break;
  }
  return SystemError({
    reason,
    module,
    method,
    pathOrDescriptor: path2,
    syscall: err.syscall,
    message: err.message
  });
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/internal/mailbox.js
var TypeId21 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty38 = /* @__PURE__ */ empty3();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty38);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty38, true];
var MailboxImpl = class extends Class2 {
  scheduler;
  capacity;
  strategy;
  [TypeId21] = TypeId21;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty3();
  constructor(scheduler, capacity3, strategy) {
    super();
    this.scheduler = scheduler;
    this.capacity = capacity3;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable2(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable2(messages)), takeRight(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error4) {
    return this.done(exitFail(error4));
  }
  failCause(cause2) {
    return this.done(exitFailCause(cause2));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty38;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty38);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty38, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else {
        return zipRight(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size13 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some2(size13);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty38;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty38;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
var make55 = (capacity3) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity3 === "number" ? capacity3 : capacity3?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity3 === "number" ? "suspend" : capacity3?.strategy ?? "suspend")));
var toChannel3 = (self) => {
  const loop2 = flatMap12(self.takeAll, ([messages, done8]) => done8 ? messages.length === 0 ? void_5 : write(messages) : zipRight4(write(messages), loop2));
  return loop2;
};

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Mailbox.js
var TypeId22 = TypeId21;
var isMailbox = (u) => hasProperty(u, TypeId22);
var make56 = make55;
var toChannel4 = toChannel3;
var fromReadable = (evaluate2, onError4, {
  chunkSize
} = {}) => fromChannel4(fromReadableChannel(evaluate2, onError4, chunkSize ? Number(chunkSize) : void 0));
var fromReadableChannel = (evaluate2, onError4, chunkSize) => acquireUseRelease4(tap2(zip6(sync5(evaluate2), make56()), ([readable, mailbox]) => readableOffer(readable, mailbox, onError4)), ([readable, mailbox]) => readableTake(readable, mailbox, chunkSize), ([readable, mailbox]) => zipRight3(sync5(() => {
  if ("closed" in readable && !readable.closed) {
    readable.destroy();
  }
}), mailbox.shutdown));
var writeInput = (writable, onFailure, {
  encoding,
  endOnDone = true
} = {}, onDone2 = _void) => {
  const write4 = writeEffect(writable, encoding);
  const close3 = endOnDone ? async2((resume2) => {
    if ("closed" in writable && writable.closed) {
      resume2(_void);
    } else {
      writable.once("finish", () => resume2(_void));
      writable.end();
    }
  }) : _void;
  return {
    awaitRead: () => _void,
    emit: write4,
    error: (cause2) => zipRight3(close3, onFailure(cause2)),
    done: (_) => zipRight3(close3, onDone2)
  };
};
var writeEffect = (writable, encoding) => (chunk4) => chunk4.length === 0 ? _void : async2((resume2) => {
  const iterator = chunk4[Symbol.iterator]();
  let next = iterator.next();
  function loop2() {
    const item = next;
    next = iterator.next();
    const success = writable.write(item.value, encoding);
    if (next.done) {
      resume2(_void);
    } else if (success) {
      loop2();
    } else {
      writable.once("drain", loop2);
    }
  }
  loop2();
});
var readableOffer = (readable, mailbox, onError4) => sync5(() => {
  readable.on("readable", () => {
    mailbox.unsafeOffer(void 0);
  });
  readable.on("error", (err) => {
    mailbox.unsafeDone(fail5(onError4(err)));
  });
  readable.on("end", () => {
    mailbox.unsafeDone(void_3);
  });
  if (readable.readable) {
    mailbox.unsafeOffer(void 0);
  }
});
var readableTake = (readable, mailbox, chunkSize) => {
  const read4 = readChunkChannel(readable, chunkSize);
  const loop2 = flatMap15(mailbox.takeAll, ([, done8]) => done8 ? read4 : zipRight7(read4, loop2));
  return loop2;
};
var readChunkChannel = (readable, chunkSize) => suspend9(() => {
  const arr = [];
  let chunk4 = readable.read(chunkSize);
  if (chunk4 === null) {
    return void_6;
  }
  while (chunk4 !== null) {
    arr.push(chunk4);
    chunk4 = readable.read(chunkSize);
  }
  return write2(unsafeFromArray(arr));
});

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/internal/sink.js
var fromWritable = (evaluate2, onError4, options3) => fromChannel3(fromWritableChannel(evaluate2, onError4, options3));
var fromWritableChannel = (writable, onError4, options3) => flatMap15(zip6(sync5(() => writable()), make26()), ([writable2, deferred]) => embedInput2(writableOutput(writable2, deferred, onError4), writeInput(writable2, (cause2) => failCause2(deferred, cause2), options3, complete(deferred, _void))));
var writableOutput = (writable, deferred, onError4) => suspend5(() => {
  function handleError(err) {
    unsafeDone(deferred, fail8(onError4(err)));
  }
  writable.on("error", handleError);
  return ensuring2(_await(deferred), sync5(() => {
    writable.removeListener("error", handleError);
  }));
});

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
var inputToStdioOption = (stdin3) => typeof stdin3 === "string" ? stdin3 : "pipe";
var outputToStdioOption = (output) => typeof output === "string" ? output : "pipe";
var toError = (err) => err instanceof globalThis.Error ? err : new globalThis.Error(String(err));
var toPlatformError = (method, error4, command) => {
  const flattened2 = flatten14(command).reduce((acc, curr) => {
    const command2 = `${curr.command} ${curr.args.join(" ")}`;
    return acc.length === 0 ? command2 : `${acc} | ${command2}`;
  }, "");
  return handleErrnoException("Command", method)(error4, [flattened2]);
};
var ProcessProto = {
  [ProcessTypeId2]: ProcessTypeId2,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/CommandExecutor/Process",
      pid: this.pid
    };
  }
};
var runCommand = (fileSystem) => (command) => {
  switch (command._tag) {
    case "StandardCommand": {
      const spawn2 = flatMap9(make26(), (exitCode2) => async2((resume2) => {
        const handle = ChildProcess__namespace.spawn(command.command, command.args, {
          stdio: [inputToStdioOption(command.stdin), outputToStdioOption(command.stdout), outputToStdioOption(command.stderr)],
          cwd: getOrElse(command.cwd, constUndefined),
          shell: command.shell,
          env: {
            ...process.env,
            ...Object.fromEntries(command.env)
          }
        });
        handle.on("error", (err) => {
          resume2(fail8(toPlatformError("spawn", err, command)));
        });
        handle.on("exit", (...args2) => {
          unsafeDone(exitCode2, succeed8(args2));
        });
        handle.on("spawn", () => {
          resume2(succeed8([handle, exitCode2]));
        });
        return sync5(() => {
          handle.kill("SIGTERM");
        });
      }));
      return pipe(
        // Validate that the directory is accessible
        match2(command.cwd, {
          onNone: () => _void,
          onSome: (dir2) => fileSystem.access(dir2)
        }),
        zipRight3(acquireRelease2(spawn2, ([handle, exitCode2]) => flatMap9(isDone(exitCode2), (done8) => done8 ? _void : suspend5(() => {
          if (handle.kill("SIGTERM")) {
            return _await(exitCode2);
          }
          return _void;
        })))),
        map17(([handle, exitCodeDeferred]) => {
          let stdin3 = drain3;
          if (handle.stdin !== null) {
            stdin3 = fromWritable(() => handle.stdin, (err) => toPlatformError("toWritable", toError(err), command));
          }
          const exitCode2 = flatMap9(_await(exitCodeDeferred), ([code2, signal]) => {
            if (code2 !== null) {
              return succeed8(ExitCode2(code2));
            }
            return fail8(toPlatformError("exitCode", new globalThis.Error(`Process interrupted due to receipt of signal: ${signal}`), command));
          });
          const isRunning2 = negate2(isDone(exitCodeDeferred));
          const kill = (signal = "SIGTERM") => suspend5(() => handle.kill(signal) ? asVoid2(_await(exitCodeDeferred)) : fail8(toPlatformError("kill", new globalThis.Error("Failed to kill process"), command)));
          const pid = ProcessId2(handle.pid);
          const stderr2 = fromReadable(() => handle.stderr, (err) => toPlatformError("fromReadable(stderr)", toError(err), command));
          let stdout2 = fromReadable(() => handle.stdout, (err) => toPlatformError("fromReadable(stdout)", toError(err), command));
          if (typeof command.stdout !== "string") {
            stdout2 = transduce2(stdout2, command.stdout);
          }
          return Object.assign(Object.create(ProcessProto), {
            pid,
            exitCode: exitCode2,
            isRunning: isRunning2,
            kill,
            stdin: stdin3,
            stderr: stderr2,
            stdout: stdout2
          });
        }),
        typeof command.stdin === "string" ? identity : tap2((process2) => forkDaemon2(run4(command.stdin, process2.stdin)))
      );
    }
    case "PipedCommand": {
      const flattened2 = flatten14(command);
      if (flattened2.length === 1) {
        return pipe(flattened2[0], runCommand(fileSystem));
      }
      const head5 = flattened2[0];
      const tail = flattened2.slice(1);
      const initial = tail.slice(0, tail.length - 1);
      const last5 = tail[tail.length - 1];
      const stream3 = initial.reduce((stdin3, command2) => pipe(stdin2(command2, stdin3), runCommand(fileSystem), map17((process2) => process2.stdout), unwrapScoped6), pipe(runCommand(fileSystem)(head5), map17((process2) => process2.stdout), unwrapScoped6));
      return pipe(stdin2(last5, stream3), runCommand(fileSystem));
    }
  }
};
var layer3 = /* @__PURE__ */ effect(CommandExecutor2, /* @__PURE__ */ pipe(FileSystem, /* @__PURE__ */ map17((fileSystem) => makeExecutor2(runCommand(fileSystem)))));

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/NodeCommandExecutor.js
var layer4 = layer3;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/effectify.js
var effectify = (fn2, onError4, onSyncError) => (...args2) => async2((resume2) => {
  try {
    fn2(...args2, (err, result) => {
      if (err) {
        resume2(fail8(onError4 ? onError4(err, args2) : err));
      } else {
        resume2(succeed8(result));
      }
    });
  } catch (err) {
    resume2(onSyncError ? fail8(onSyncError(err, args2)) : die5(err));
  }
});

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Effectify.js
var effectify2 = effectify;
var handleBadArgument = (method) => (err) => BadArgument({
  module: "FileSystem",
  method,
  message: err.message ?? String(err)
});
var access2 = /* @__PURE__ */ (() => {
  const nodeAccess = /* @__PURE__ */ effectify2(NFS__namespace.access, /* @__PURE__ */ handleErrnoException("FileSystem", "access"), /* @__PURE__ */ handleBadArgument("access"));
  return (path2, options3) => {
    let mode = NFS__namespace.constants.F_OK;
    if (options3?.readable) {
      mode |= NFS__namespace.constants.R_OK;
    }
    if (options3?.writable) {
      mode |= NFS__namespace.constants.W_OK;
    }
    return nodeAccess(path2, mode);
  };
})();
var copy3 = /* @__PURE__ */ (() => {
  const nodeCp = /* @__PURE__ */ effectify2(NFS__namespace.cp, /* @__PURE__ */ handleErrnoException("FileSystem", "copy"), /* @__PURE__ */ handleBadArgument("copy"));
  return (fromPath, toPath, options3) => nodeCp(fromPath, toPath, {
    force: options3?.overwrite ?? false,
    preserveTimestamps: options3?.preserveTimestamps ?? false,
    recursive: true
  });
})();
var copyFile2 = /* @__PURE__ */ (() => {
  const nodeCopyFile = /* @__PURE__ */ effectify2(NFS__namespace.copyFile, /* @__PURE__ */ handleErrnoException("FileSystem", "copyFile"), /* @__PURE__ */ handleBadArgument("copyFile"));
  return (fromPath, toPath) => nodeCopyFile(fromPath, toPath);
})();
var chmod2 = /* @__PURE__ */ (() => {
  const nodeChmod = /* @__PURE__ */ effectify2(NFS__namespace.chmod, /* @__PURE__ */ handleErrnoException("FileSystem", "chmod"), /* @__PURE__ */ handleBadArgument("chmod"));
  return (path2, mode) => nodeChmod(path2, mode);
})();
var chown2 = /* @__PURE__ */ (() => {
  const nodeChown = /* @__PURE__ */ effectify2(NFS__namespace.chown, /* @__PURE__ */ handleErrnoException("FileSystem", "chown"), /* @__PURE__ */ handleBadArgument("chown"));
  return (path2, uid, gid) => nodeChown(path2, uid, gid);
})();
var link2 = /* @__PURE__ */ (() => {
  const nodeLink = /* @__PURE__ */ effectify2(NFS__namespace.link, /* @__PURE__ */ handleErrnoException("FileSystem", "link"), /* @__PURE__ */ handleBadArgument("link"));
  return (existingPath, newPath) => nodeLink(existingPath, newPath);
})();
var makeDirectory = /* @__PURE__ */ (() => {
  const nodeMkdir = /* @__PURE__ */ effectify2(NFS__namespace.mkdir, /* @__PURE__ */ handleErrnoException("FileSystem", "makeDirectory"), /* @__PURE__ */ handleBadArgument("makeDirectory"));
  return (path2, options3) => nodeMkdir(path2, {
    recursive: options3?.recursive ?? false,
    mode: options3?.mode
  });
})();
var makeTempDirectoryFactory = (method) => {
  const nodeMkdtemp = effectify2(NFS__namespace.mkdtemp, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (options3) => suspend5(() => {
    const prefix = options3?.prefix ?? "";
    const directory2 = typeof options3?.directory === "string" ? Path3__namespace.join(options3.directory, ".") : OS__namespace.tmpdir();
    return nodeMkdtemp(prefix ? Path3__namespace.join(directory2, prefix) : directory2 + "/");
  });
};
var makeTempDirectory = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectory");
var removeFactory = (method) => {
  const nodeRm = effectify2(NFS__namespace.rm, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path2, options3) => nodeRm(path2, {
    recursive: options3?.recursive ?? false,
    force: options3?.force ?? false
  });
};
var remove7 = /* @__PURE__ */ removeFactory("remove");
var makeTempDirectoryScoped = /* @__PURE__ */ (() => {
  const makeDirectory2 = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectoryScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempDirectoryScoped");
  return (options3) => acquireRelease2(makeDirectory2(options3), (directory2) => orDie2(removeDirectory(directory2, {
    recursive: true
  })));
})();
var openFactory = (method) => {
  const nodeOpen = effectify2(NFS__namespace.open, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeClose = effectify2(NFS__namespace.close, handleErrnoException("FileSystem", method), handleBadArgument(method));
  return (path2, options3) => pipe(acquireRelease2(nodeOpen(path2, options3?.flag ?? "r", options3?.mode), (fd) => orDie2(nodeClose(fd))), map17((fd) => makeFile(FileDescriptor(fd), options3?.flag?.startsWith("a") ?? false)));
};
var open2 = /* @__PURE__ */ openFactory("open");
var makeFile = /* @__PURE__ */ (() => {
  const nodeReadFactory = (method) => effectify2(NFS__namespace.read, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeRead = /* @__PURE__ */ nodeReadFactory("read");
  const nodeReadAlloc = /* @__PURE__ */ nodeReadFactory("readAlloc");
  const nodeStat = /* @__PURE__ */ effectify2(NFS__namespace.fstat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS__namespace.ftruncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  const nodeSync = /* @__PURE__ */ effectify2(NFS__namespace.fsync, /* @__PURE__ */ handleErrnoException("FileSystem", "sync"), /* @__PURE__ */ handleBadArgument("sync"));
  const nodeWriteFactory = (method) => effectify2(NFS__namespace.write, handleErrnoException("FileSystem", method), handleBadArgument(method));
  const nodeWrite = /* @__PURE__ */ nodeWriteFactory("write");
  const nodeWriteAll = /* @__PURE__ */ nodeWriteFactory("writeAll");
  class FileImpl {
    fd;
    append;
    [FileTypeId];
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore2(1);
    position = 0n;
    constructor(fd, append4) {
      this.fd = fd;
      this.append = append4;
      this[FileTypeId] = FileTypeId;
    }
    get stat() {
      return map17(nodeStat(this.fd), makeFileInfo);
    }
    get sync() {
      return nodeSync(this.fd);
    }
    seek(offset, from) {
      const offsetSize = Size2(offset);
      return this.semaphore.withPermits(1)(sync5(() => {
        if (from === "start") {
          this.position = offsetSize;
        } else if (from === "current") {
          this.position = this.position + offsetSize;
        }
        return this.position;
      }));
    }
    read(buffer3) {
      return this.semaphore.withPermits(1)(map17(suspend5(() => nodeRead(this.fd, {
        buffer: buffer3,
        position: this.position
      })), (bytesRead) => {
        const sizeRead = Size2(bytesRead);
        this.position = this.position + sizeRead;
        return sizeRead;
      }));
    }
    readAlloc(size13) {
      const sizeNumber = Number(size13);
      return this.semaphore.withPermits(1)(flatMap9(sync5(() => Buffer.allocUnsafeSlow(sizeNumber)), (buffer3) => map17(nodeReadAlloc(this.fd, {
        buffer: buffer3,
        position: this.position
      }), (bytesRead) => {
        if (bytesRead === 0) {
          return none2();
        }
        this.position = this.position + BigInt(bytesRead);
        if (bytesRead === sizeNumber) {
          return some2(buffer3);
        }
        const dst = Buffer.allocUnsafeSlow(bytesRead);
        buffer3.copy(dst, 0, 0, bytesRead);
        return some2(dst);
      })));
    }
    truncate(length3) {
      return this.semaphore.withPermits(1)(map17(nodeTruncate(this.fd, length3 ? Number(length3) : void 0), () => {
        if (!this.append) {
          const len = BigInt(length3 ?? 0);
          if (this.position > len) {
            this.position = len;
          }
        }
      }));
    }
    write(buffer3) {
      return this.semaphore.withPermits(1)(map17(suspend5(() => nodeWrite(this.fd, buffer3, void 0, void 0, this.append ? void 0 : Number(this.position))), (bytesWritten) => {
        const sizeWritten = Size2(bytesWritten);
        if (!this.append) {
          this.position = this.position + sizeWritten;
        }
        return sizeWritten;
      }));
    }
    writeAllChunk(buffer3) {
      return flatMap9(suspend5(() => nodeWriteAll(this.fd, buffer3, void 0, void 0, this.append ? void 0 : Number(this.position))), (bytesWritten) => {
        if (bytesWritten === 0) {
          return fail8(SystemError({
            module: "FileSystem",
            method: "writeAll",
            reason: "WriteZero",
            pathOrDescriptor: this.fd,
            message: "write returned 0 bytes written"
          }));
        }
        if (!this.append) {
          this.position = this.position + BigInt(bytesWritten);
        }
        return bytesWritten < buffer3.length ? this.writeAllChunk(buffer3.subarray(bytesWritten)) : _void;
      });
    }
    writeAll(buffer3) {
      return this.semaphore.withPermits(1)(this.writeAllChunk(buffer3));
    }
  }
  return (fd, append4) => new FileImpl(fd, append4);
})();
var makeTempFileFactory = (method) => {
  const makeDirectory2 = makeTempDirectoryFactory(method);
  const open3 = openFactory(method);
  const randomHexString2 = (bytes) => sync5(() => Crypto__namespace.randomBytes(bytes).toString("hex"));
  return (options3) => pipe(zip6(makeDirectory2(options3), randomHexString2(6)), map17(([directory2, random3]) => Path3__namespace.join(directory2, random3)), tap2((path2) => scoped2(open3(path2, {
    flag: "w+"
  }))));
};
var makeTempFile = /* @__PURE__ */ makeTempFileFactory("makeTempFile");
var makeTempFileScoped = /* @__PURE__ */ (() => {
  const makeFile2 = /* @__PURE__ */ makeTempFileFactory("makeTempFileScoped");
  const removeDirectory = /* @__PURE__ */ removeFactory("makeTempFileScoped");
  return (options3) => acquireRelease2(makeFile2(options3), (file3) => orDie2(removeDirectory(Path3__namespace.dirname(file3), {
    recursive: true
  })));
})();
var readDirectory = (path2, options3) => tryPromise2({
  try: () => NFS__namespace.promises.readdir(path2, options3),
  catch: (err) => handleErrnoException("FileSystem", "readDirectory")(err, [path2])
});
var readFile2 = (path2) => async2((resume2, signal) => {
  try {
    NFS__namespace.readFile(path2, {
      signal
    }, (err, data) => {
      if (err) {
        resume2(fail8(handleErrnoException("FileSystem", "readFile")(err, [path2])));
      } else {
        resume2(succeed8(data));
      }
    });
  } catch (err) {
    resume2(fail8(handleBadArgument("readFile")(err)));
  }
});
var readLink = /* @__PURE__ */ (() => {
  const nodeReadLink = /* @__PURE__ */ effectify2(NFS__namespace.readlink, /* @__PURE__ */ handleErrnoException("FileSystem", "readLink"), /* @__PURE__ */ handleBadArgument("readLink"));
  return (path2) => nodeReadLink(path2);
})();
var realPath = /* @__PURE__ */ (() => {
  const nodeRealPath = /* @__PURE__ */ effectify2(NFS__namespace.realpath, /* @__PURE__ */ handleErrnoException("FileSystem", "realPath"), /* @__PURE__ */ handleBadArgument("realPath"));
  return (path2) => nodeRealPath(path2);
})();
var rename3 = /* @__PURE__ */ (() => {
  const nodeRename = /* @__PURE__ */ effectify2(NFS__namespace.rename, /* @__PURE__ */ handleErrnoException("FileSystem", "rename"), /* @__PURE__ */ handleBadArgument("rename"));
  return (oldPath, newPath) => nodeRename(oldPath, newPath);
})();
var makeFileInfo = (stat3) => ({
  type: stat3.isFile() ? "File" : stat3.isDirectory() ? "Directory" : stat3.isSymbolicLink() ? "SymbolicLink" : stat3.isBlockDevice() ? "BlockDevice" : stat3.isCharacterDevice() ? "CharacterDevice" : stat3.isFIFO() ? "FIFO" : stat3.isSocket() ? "Socket" : "Unknown",
  mtime: fromNullable(stat3.mtime),
  atime: fromNullable(stat3.atime),
  birthtime: fromNullable(stat3.birthtime),
  dev: stat3.dev,
  rdev: fromNullable(stat3.rdev),
  ino: fromNullable(stat3.ino),
  mode: stat3.mode,
  nlink: fromNullable(stat3.nlink),
  uid: fromNullable(stat3.uid),
  gid: fromNullable(stat3.gid),
  size: Size2(stat3.size),
  blksize: fromNullable(Size2(stat3.blksize)),
  blocks: fromNullable(stat3.blocks)
});
var stat2 = /* @__PURE__ */ (() => {
  const nodeStat = /* @__PURE__ */ effectify2(NFS__namespace.stat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
  return (path2) => map17(nodeStat(path2), makeFileInfo);
})();
var symlink2 = /* @__PURE__ */ (() => {
  const nodeSymlink = /* @__PURE__ */ effectify2(NFS__namespace.symlink, /* @__PURE__ */ handleErrnoException("FileSystem", "symlink"), /* @__PURE__ */ handleBadArgument("symlink"));
  return (target, path2) => nodeSymlink(target, path2);
})();
var truncate2 = /* @__PURE__ */ (() => {
  const nodeTruncate = /* @__PURE__ */ effectify2(NFS__namespace.truncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
  return (path2, length3) => nodeTruncate(path2, length3 !== void 0 ? Number(length3) : void 0);
})();
var utimes2 = /* @__PURE__ */ (() => {
  const nodeUtimes = /* @__PURE__ */ effectify2(NFS__namespace.utimes, /* @__PURE__ */ handleErrnoException("FileSystem", "utime"), /* @__PURE__ */ handleBadArgument("utime"));
  return (path2, atime, mtime) => nodeUtimes(path2, atime, mtime);
})();
var watchNode = (path2) => asyncScoped2((emit) => acquireRelease2(sync5(() => {
  const watcher = NFS__namespace.watch(path2, {}, (event, path3) => {
    if (!path3) return;
    switch (event) {
      case "rename": {
        emit.fromEffect(match11(stat2(path3), {
          onSuccess: (_) => WatchEventCreate({
            path: path3
          }),
          onFailure: (_) => WatchEventRemove({
            path: path3
          })
        }));
        return;
      }
      case "change": {
        emit.single(WatchEventUpdate({
          path: path3
        }));
        return;
      }
    }
  });
  watcher.on("error", (error4) => {
    emit.fail(SystemError({
      module: "FileSystem",
      reason: "Unknown",
      method: "watch",
      pathOrDescriptor: path2,
      message: error4.message
    }));
  });
  watcher.on("close", () => {
    emit.end();
  });
  return watcher;
}), (watcher) => sync5(() => watcher.close())));
var watch2 = (backend, path2) => stat2(path2).pipe(map17((stat3) => backend.pipe(flatMap((_) => _.register(path2, stat3)), getOrElse(() => watchNode(path2)))), unwrap5);
var writeFile2 = (path2, data, options3) => async2((resume2, signal) => {
  try {
    NFS__namespace.writeFile(path2, data, {
      signal,
      flag: options3?.flag,
      mode: options3?.mode
    }, (err) => {
      if (err) {
        resume2(fail8(handleErrnoException("FileSystem", "writeFile")(err, [path2])));
      } else {
        resume2(_void);
      }
    });
  } catch (err) {
    resume2(fail8(handleBadArgument("writeFile")(err)));
  }
});
var makeFileSystem = /* @__PURE__ */ map17(/* @__PURE__ */ serviceOption2(WatchBackend), (backend) => make49({
  access: access2,
  chmod: chmod2,
  chown: chown2,
  copy: copy3,
  copyFile: copyFile2,
  link: link2,
  makeDirectory,
  makeTempDirectory,
  makeTempDirectoryScoped,
  makeTempFile,
  makeTempFileScoped,
  open: open2,
  readDirectory,
  readFile: readFile2,
  readLink,
  realPath,
  remove: remove7,
  rename: rename3,
  stat: stat2,
  symlink: symlink2,
  truncate: truncate2,
  utimes: utimes2,
  watch(path2) {
    return watch2(backend, path2);
  },
  writeFile: writeFile2
}));
var layer5 = /* @__PURE__ */ effect(FileSystem, makeFileSystem);

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/NodeFileSystem.js
var layer6 = layer5;
var fromFileUrl2 = (url2) => try_2({
  try: () => Url__namespace.fileURLToPath(url2),
  catch: (error4) => BadArgument({
    module: "Path",
    method: "fromFileUrl",
    message: `${error4}`
  })
});
var toFileUrl2 = (path2) => try_2({
  try: () => Url__namespace.pathToFileURL(path2),
  catch: (error4) => BadArgument({
    module: "Path",
    method: "toFileUrl",
    message: `${error4}`
  })
});
var layer7 = /* @__PURE__ */ succeed10(Path2, /* @__PURE__ */ Path2.of({
  [TypeId19]: TypeId19,
  ...Path3__namespace,
  fromFileUrl: fromFileUrl2,
  toFileUrl: toFileUrl2
}));

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/NodePath.js
var layer8 = layer7;
var defaultShouldQuit = (input) => input.key.ctrl && (input.key.name === "c" || input.key.name === "d");
var make57 = (shouldQuit = defaultShouldQuit) => gen2(function* () {
  const input = yield* sync5(() => globalThis.process.stdin);
  const output = yield* sync5(() => globalThis.process.stdout);
  const acquireReadlineInterface = sync5(() => readline__namespace.createInterface({
    input,
    escapeCodeTimeout: 50
  }));
  const emitKeypressEvents2 = (rl) => {
    readline__namespace.emitKeypressEvents(input, rl);
    if (input.isTTY) {
      input.setRawMode(true);
    }
    return rl;
  };
  const releaseReadlineInterface = (rl) => sync5(() => {
    if (input.isTTY) {
      input.setRawMode(false);
    }
    rl.close();
  });
  const handleKeypressEvent = (input2) => async2((resume2) => {
    const handleKeypress = (input3, key) => {
      const userInput = {
        input: fromNullable(input3),
        key: {
          name: key.name || "",
          ctrl: key.ctrl || false,
          meta: key.meta || false,
          shift: key.shift || false
        }
      };
      if (shouldQuit(userInput)) {
        resume2(fail8(new QuitException()));
      } else {
        resume2(succeed8(userInput));
      }
    };
    input2.once("keypress", handleKeypress);
    return sync5(() => {
      input2.removeListener("keypress", handleKeypress);
    });
  });
  const handleLineEvent = (rl) => async2((resume2) => {
    const handleLine = (line4) => {
      resume2(succeed8(line4));
    };
    rl.on("line", handleLine);
    return sync5(() => {
      rl.removeListener("line", handleLine);
    });
  });
  const readInput = acquireUseRelease2(acquireReadlineInterface.pipe(map17(emitKeypressEvents2)), () => handleKeypressEvent(input), releaseReadlineInterface);
  const readLine = acquireUseRelease2(acquireReadlineInterface, (rl) => handleLineEvent(rl), releaseReadlineInterface);
  const display = (prompt3) => uninterruptible2(async2((resume2) => {
    output.write(prompt3, (err) => {
      if (err) {
        resume2(fail8(BadArgument({
          module: "Terminal",
          method: "display",
          message: err.message ?? String(err)
        })));
      }
      resume2(_void);
    });
  }));
  return Terminal.of({
    // The columns property can be undefined if stdout was redirected
    columns: sync5(() => output.columns || 0),
    readInput,
    readLine,
    display
  });
});
var layer9 = /* @__PURE__ */ scoped3(Terminal, /* @__PURE__ */ make57(defaultShouldQuit));

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/NodeTerminal.js
var layer10 = layer9;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/FiberSet.js
var TypeId23 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId23);
var Proto3 = {
  [TypeId23]: TypeId23,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake8 = (backing, deferred) => {
  const self = Object.create(Proto3);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make58 = () => acquireRelease2(map17(make26(), (deferred) => unsafeMake8(/* @__PURE__ */ new Set(), deferred)), (set7) => withFiberRuntime2((parent) => {
  const state = set7.state;
  if (state._tag === "Closed") return _void;
  set7.state = {
    _tag: "Closed"
  };
  const fibers = state.backing;
  return interruptAllAs2(fibers, combine3(parent.id(), internalFiberId)).pipe(intoDeferred2(set7.deferred));
}));
var internalFiberIdId = -1;
var internalFiberId = /* @__PURE__ */ make15(internalFiberIdId, 0);
var isInternalInterruption = /* @__PURE__ */ reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId2) => has3(ids2(fiberId2), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self, fiber, options3) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options3?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure(exit4) && (options3?.propagateInterruption === true ? !isInternalInterruption(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var join5 = (self) => _await(self.deferred);

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Transferable.js
var Collector = class extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
};
var unsafeMakeCollector = () => {
  let tranferables = [];
  const unsafeAddAll = (transfers) => {
    tranferables.push(...transfers);
  };
  const unsafeRead = () => tranferables;
  const unsafeClear = () => {
    const prev = tranferables;
    tranferables = [];
    return prev;
  };
  return Collector.of({
    unsafeAddAll,
    addAll: (transferables) => sync5(() => unsafeAddAll(transferables)),
    unsafeRead,
    read: sync5(unsafeRead),
    unsafeClear,
    clear: sync5(unsafeClear)
  });
};

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/workerError.js
var WorkerErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/WorkerError");

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/WorkerError.js
var WorkerErrorTypeId2 = WorkerErrorTypeId;
var WorkerError = class extends (/* @__PURE__ */ TaggedError2()("WorkerError", {
  reason: /* @__PURE__ */ Literal2("spawn", "decode", "send", "unknown", "encode"),
  cause: Defect
})) {
  /**
   * @since 1.0.0
   */
  [WorkerErrorTypeId2] = WorkerErrorTypeId2;
  /**
   * @since 1.0.0
   */
  static Cause = /* @__PURE__ */ Cause({
    error: this,
    defect: Defect
  });
  /**
   * @since 1.0.0
   */
  static encodeCause = /* @__PURE__ */ encodeSync(this.Cause);
  /**
   * @since 1.0.0
   */
  static decodeCause = /* @__PURE__ */ decodeSync(this.Cause);
  /**
   * @since 1.0.0
   */
  get message() {
    switch (this.reason) {
      case "send":
        return "An error occurred calling .postMessage";
      case "spawn":
        return "An error occurred while spawning a worker";
      case "decode":
        return "An error occurred during decoding";
      case "encode":
        return "An error occurred during encoding";
      case "unknown":
        return "An unexpected error occurred";
    }
  }
};

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/internal/worker.js
var PlatformWorkerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/PlatformWorker");
var PlatformWorker = /* @__PURE__ */ GenericTag("@effect/platform/Worker/PlatformWorker");
var WorkerManagerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/WorkerManager");
var WorkerManager = /* @__PURE__ */ GenericTag("@effect/platform/Worker/WorkerManager");
var Spawner = /* @__PURE__ */ GenericTag("@effect/platform/Worker/Spawner");
var makeManager = /* @__PURE__ */ gen2(function* () {
  const platform = yield* PlatformWorker;
  let idCounter = 0;
  return WorkerManager.of({
    [WorkerManagerTypeId]: WorkerManagerTypeId,
    spawn({
      encode,
      initialMessage
    }) {
      return gen2(function* () {
        const id2 = idCounter++;
        let requestIdCounter = 0;
        const requestMap = /* @__PURE__ */ new Map();
        const collector = unsafeMakeCollector();
        const wrappedEncode = encode ? (message) => zipRight3(collector.clear, provideService2(encode(message), Collector, collector)) : succeed8;
        const readyLatch = yield* make26();
        const backing = yield* platform.spawn(id2);
        yield* backing.run((message) => {
          if (message[0] === 0) {
            return complete(readyLatch, _void);
          }
          return handleMessage(message[1]);
        }).pipe(onError2((cause2) => forEach8(requestMap.values(), (mailbox) => DeferredTypeId2 in mailbox ? failCause2(mailbox, cause2) : mailbox.failCause(cause2))), tapErrorCause2(logWarning2), retry(spaced2(1e3)), annotateLogs2({
          package: "@effect/platform",
          module: "Worker"
        }), interruptible4, forkScoped2);
        yield* addFinalizer3(() => zipRight3(forEach8(requestMap.values(), (mailbox) => DeferredTypeId2 in mailbox ? interrupt3(mailbox) : mailbox.end, {
          discard: true
        }), sync5(() => requestMap.clear())));
        const handleMessage = (response) => suspend5(() => {
          const mailbox = requestMap.get(response[0]);
          if (!mailbox) return _void;
          switch (response[1]) {
            // data
            case 0: {
              return DeferredTypeId2 in mailbox ? succeed3(mailbox, response[2][0]) : mailbox.offerAll(response[2]);
            }
            // end
            case 1: {
              if (response.length === 2) {
                return DeferredTypeId2 in mailbox ? interrupt3(mailbox) : mailbox.end;
              }
              return DeferredTypeId2 in mailbox ? succeed3(mailbox, response[2][0]) : zipRight3(mailbox.offerAll(response[2]), mailbox.end);
            }
            // error / defect
            case 2:
            case 3: {
              if (response[1] === 2) {
                return DeferredTypeId2 in mailbox ? fail4(mailbox, response[2]) : mailbox.fail(response[2]);
              }
              const cause2 = WorkerError.decodeCause(response[2]);
              return DeferredTypeId2 in mailbox ? failCause2(mailbox, cause2) : mailbox.failCause(cause2);
            }
          }
        });
        const executeAcquire = (request, makeMailbox) => withFiberRuntime2((fiber) => {
          const context7 = fiber.getFiberRef(currentContext2);
          const span2 = getOption2(context7, ParentSpan).pipe(filter((span3) => span3._tag === "Span"));
          const id3 = requestIdCounter++;
          return makeMailbox.pipe(tap2((mailbox) => {
            requestMap.set(id3, mailbox);
            return wrappedEncode(request).pipe(tap2((payload) => backing.send([id3, 0, payload, span2._tag === "Some" ? [span2.value.traceId, span2.value.spanId, span2.value.sampled] : void 0], collector.unsafeRead())), catchAllCause2((cause2) => isMailbox(mailbox) ? mailbox.failCause(cause2) : failCause2(mailbox, cause2)));
          }), map17((mailbox) => ({
            id: id3,
            mailbox
          })));
        });
        const executeRelease = ({
          id: id3
        }, exit4) => {
          const release = sync5(() => requestMap.delete(id3));
          return isFailure(exit4) ? zipRight3(orDie2(backing.send([id3, 1])), release) : release;
        };
        const execute2 = (request) => fromChannel4(acquireUseRelease4(executeAcquire(request, make56()), ({
          mailbox
        }) => toChannel4(mailbox), executeRelease));
        const executeEffect = (request) => acquireUseRelease2(executeAcquire(request, make26()), ({
          mailbox
        }) => _await(mailbox), executeRelease);
        yield* _await(readyLatch);
        if (initialMessage) {
          yield* sync5(initialMessage).pipe(flatMap9(executeEffect), mapError2((cause2) => new WorkerError({
            reason: "spawn",
            cause: cause2
          })));
        }
        return {
          id: id2,
          execute: execute2,
          executeEffect
        };
      });
    }
  });
});
var layerManager = /* @__PURE__ */ effect(WorkerManager, makeManager);
var makePlatform = () => (options3) => PlatformWorker.of({
  [PlatformWorkerTypeId]: PlatformWorkerTypeId,
  spawn(id2) {
    return gen2(function* () {
      const spawn2 = yield* Spawner;
      let currentPort;
      const buffer3 = [];
      const run10 = (handler) => uninterruptibleMask3((restore) => gen2(function* () {
        const scope4 = yield* scope2;
        const port = yield* options3.setup({
          worker: spawn2(id2),
          scope: scope4
        });
        currentPort = port;
        yield* addFinalizer2(scope4, sync5(() => {
          currentPort = void 0;
        }));
        const runtime5 = (yield* runtime4()).pipe(updateContext3(omit2(Scope)));
        const fiberSet = yield* make58();
        const runFork4 = runFork3(runtime5);
        yield* options3.listen({
          port,
          scope: scope4,
          emit(data) {
            unsafeAdd(fiberSet, runFork4(handler(data)));
          },
          deferred: fiberSet.deferred
        });
        if (buffer3.length > 0) {
          for (const [message, transfers] of buffer3) {
            port.postMessage([0, message], transfers);
          }
          buffer3.length = 0;
        }
        return yield* restore(join5(fiberSet));
      }).pipe(scoped2));
      const send = (message, transfers) => try_2({
        try: () => {
          if (currentPort === void 0) {
            buffer3.push([message, transfers]);
          } else {
            currentPort.postMessage([0, message], transfers);
          }
        },
        catch: (cause2) => new WorkerError({
          reason: "send",
          cause: cause2
        })
      });
      return {
        run: run10,
        send
      };
    });
  }
});

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Worker.js
var makePlatform2 = makePlatform;
var PlatformWorker2 = PlatformWorker;
var layerManager2 = layerManager;

// node_modules/.pnpm/@effect+platform-node@0.81.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.15.2__@e_w5tyeqyqg35xl2byegz3vsande/node_modules/@effect/platform-node/dist/esm/internal/worker.js
var platformWorkerImpl = /* @__PURE__ */ makePlatform2()({
  setup({
    scope: scope4,
    worker
  }) {
    return flatMap9(make26(), (exitDeferred) => {
      const thing = "postMessage" in worker ? {
        postMessage(msg, t) {
          worker.postMessage(msg, t);
        },
        kill: () => worker.terminate(),
        worker
      } : {
        postMessage(msg, _) {
          worker.send(msg);
        },
        kill: () => worker.kill("SIGKILL"),
        worker
      };
      worker.on("exit", () => {
        unsafeDone(exitDeferred, void_3);
      });
      return as4(addFinalizer2(scope4, suspend5(() => {
        thing.postMessage([1]);
        return _await(exitDeferred);
      }).pipe(interruptible4, timeout2(5e3), catchAllCause2(() => sync5(() => thing.kill())))), thing);
    });
  },
  listen({
    deferred,
    emit,
    port
  }) {
    port.worker.on("message", (message) => {
      emit(message);
    });
    port.worker.on("messageerror", (cause2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "decode",
        cause: cause2
      }));
    });
    port.worker.on("error", (cause2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: cause2
      }));
    });
    port.worker.on("exit", (code2) => {
      unsafeDone(deferred, new WorkerError({
        reason: "unknown",
        cause: new Error(`exited with code ${code2}`)
      }));
    });
    return _void;
  }
});
var layerWorker = /* @__PURE__ */ succeed10(PlatformWorker2, platformWorkerImpl);
var layerManager3 = /* @__PURE__ */ provide3(layerManager2, layerWorker);

// node_modules/.pnpm/@effect+platform-node@0.81.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.15.2__@e_w5tyeqyqg35xl2byegz3vsande/node_modules/@effect/platform-node/dist/esm/NodeWorker.js
var layerManager4 = layerManager3;

// node_modules/.pnpm/@effect+platform-node@0.81.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.15.2__@e_w5tyeqyqg35xl2byegz3vsande/node_modules/@effect/platform-node/dist/esm/NodeContext.js
var layer12 = /* @__PURE__ */ pipe(/* @__PURE__ */ mergeAll4(layer8, layer4, layer10, layerManager4), /* @__PURE__ */ provideMerge2(layer6));

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Logger.js
var withMinimumLogLevel2 = withMinimumLogLevel;
var defaultLogger2 = defaultLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;

// node_modules/.pnpm/@effect+platform@0.82.3_effect@3.15.2/node_modules/@effect/platform/dist/esm/Runtime.js
var defaultTeardown = (exit4, onExit3) => {
  onExit3(isFailure(exit4) && !isInterruptedOnly2(exit4.cause) ? 1 : 0);
};
var addPrettyLogger = (refs, fiberId2) => {
  const loggers = getOrDefault2(refs, currentLoggers2);
  if (!has3(loggers, defaultLogger2)) {
    return refs;
  }
  return updateAs2(refs, {
    fiberId: fiberId2,
    fiberRef: currentLoggers2,
    value: loggers.pipe(remove4(defaultLogger2), add2(prettyLoggerDefault2))
  });
};
var makeRunMain = (f) => dual((args2) => isEffect2(args2[0]), (effect3, options3) => {
  const fiber = options3?.disableErrorReporting === true ? runFork2(effect3, {
    updateRefs: options3?.disablePrettyLogger === true ? void 0 : addPrettyLogger
  }) : runFork2(tapErrorCause2(effect3, (cause2) => {
    if (isInterruptedOnly2(cause2)) {
      return _void;
    }
    return logError2(cause2);
  }), {
    updateRefs: options3?.disablePrettyLogger === true ? void 0 : addPrettyLogger
  });
  const teardown = options3?.teardown ?? defaultTeardown;
  return f({
    fiber,
    teardown
  });
});

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/internal/runtime.js
var runMain = /* @__PURE__ */ makeRunMain(({
  fiber,
  teardown
}) => {
  const keepAlive = setInterval(constVoid, 2 ** 31 - 1);
  let receivedSignal = false;
  fiber.addObserver((exit4) => {
    if (!receivedSignal) {
      process.removeListener("SIGINT", onSigint);
      process.removeListener("SIGTERM", onSigint);
    }
    clearInterval(keepAlive);
    teardown(exit4, (code2) => {
      if (receivedSignal || code2 !== 0) {
        process.exit(code2);
      }
    });
  });
  function onSigint() {
    receivedSignal = true;
    process.removeListener("SIGINT", onSigint);
    process.removeListener("SIGTERM", onSigint);
    fiber.unsafeInterruptAsFork(fiber.id());
  }
  process.on("SIGINT", onSigint);
  process.on("SIGTERM", onSigint);
});

// node_modules/.pnpm/@effect+platform-node-shared@0.35.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.1_hybd2lwxvsevyfph5ajl2j5bmi/node_modules/@effect/platform-node-shared/dist/esm/NodeRuntime.js
var runMain2 = runMain;

// node_modules/.pnpm/@effect+platform-node@0.81.0_@effect+cluster@0.34.0_@effect+platform@0.82.3_effect@3.15.2__@e_w5tyeqyqg35xl2byegz3vsande/node_modules/@effect/platform-node/dist/esm/NodeRuntime.js
var runMain3 = runMain2;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/SynchronizedRef.js
var make59 = makeSynchronized;
var get13 = get10;
var updateEffect2 = updateEffect;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/args.js
var ArgsSymbolKey = "@effect/cli/Args";
var ArgsTypeId = /* @__PURE__ */ Symbol.for(ArgsSymbolKey);
var proto22 = {
  [ArgsTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isArgs = (u) => typeof u === "object" && u != null && ArgsTypeId in u;
var isEmpty16 = (self) => self._tag === "Empty";
var all8 = function() {
  if (arguments.length === 1) {
    if (isArgs(arguments[0])) {
      return map30(arguments[0], (x) => [x]);
    } else if (isArray(arguments[0])) {
      return allTupled2(arguments[0]);
    } else {
      const entries2 = Object.entries(arguments[0]);
      let result = map30(entries2[0][1], (value5) => ({
        [entries2[0][0]]: value5
      }));
      if (entries2.length === 1) {
        return result;
      }
      const rest = entries2.slice(1);
      for (const [key, options3] of rest) {
        result = map30(makeBoth2(result, options3), ([record2, value5]) => ({
          ...record2,
          [key]: value5
        }));
      }
      return result;
    }
  }
  return allTupled2(arguments[0]);
};
var none11 = /* @__PURE__ */ (() => {
  const op = /* @__PURE__ */ Object.create(proto22);
  op._tag = "Empty";
  return op;
})();
var getHelp4 = (self) => getHelpInternal3(self);
var getUsage2 = (self) => getUsageInternal2(self);
var map30 = /* @__PURE__ */ dual(2, (self, f) => mapEffect7(self, (a) => succeed8(f(a))));
var mapEffect7 = /* @__PURE__ */ dual(2, (self, f) => makeMap2(self, f));
var validate5 = /* @__PURE__ */ dual(3, (self, args2, config2) => validateInternal2(self, args2, config2));
var wizard3 = /* @__PURE__ */ dual(2, (self, config2) => wizardInternal3(self, config2));
var allTupled2 = (arg) => {
  if (arg.length === 0) {
    return none11;
  }
  if (arg.length === 1) {
    return map30(arg[0], (x) => [x]);
  }
  let result = map30(arg[0], (x) => [x]);
  for (let i = 1; i < arg.length; i++) {
    const curr = arg[i];
    result = map30(makeBoth2(result, curr), ([a, b]) => [...a, b]);
  }
  return result;
};
var getHelpInternal3 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty36;
    }
    case "Single": {
      return descriptionList([[weak(self.name), sequence(p(getHelp(self.primitiveType)), self.description)]]);
    }
    case "Map": {
      return getHelpInternal3(self.args);
    }
    case "Both": {
      return sequence(getHelpInternal3(self.left), getHelpInternal3(self.right));
    }
    case "Variadic": {
      const help = getHelpInternal3(self.args);
      return mapDescriptionList(help, (oldSpan, oldBlock) => {
        const min4 = getMinSizeInternal2(self);
        const max6 = getMaxSizeInternal2(self);
        const newSpan = text4(isSome2(self.max) ? ` ${min4} - ${max6}` : min4 === 0 ? "..." : ` ${min4}+`);
        const newBlock = p(isSome2(self.max) ? `This argument must be repeated at least ${min4} times and may be repeated up to ${max6} times.` : min4 === 0 ? "This argument may be repeated zero or more times." : `This argument must be repeated at least ${min4} times.`);
        return [concat3(oldSpan, newSpan), sequence(oldBlock, newBlock)];
      });
    }
    case "WithDefault": {
      return mapDescriptionList(getHelpInternal3(self.args), (span2, block) => {
        const optionalDescription = isOption2(self.fallback) ? match2(self.fallback, {
          onNone: () => p("This setting is optional."),
          onSome: (fallbackValue) => {
            const inspectableValue = isObject(fallbackValue) ? fallbackValue : String(fallbackValue);
            const displayValue = toStringUnknown(inspectableValue, 0);
            return p(`This setting is optional. Defaults to: ${displayValue}`);
          }
        }) : p("This setting is optional.");
        return [span2, sequence(block, optionalDescription)];
      });
    }
    case "WithFallbackConfig": {
      return mapDescriptionList(getHelpInternal3(self.args), (span2, block) => [span2, sequence(block, p("This argument can be set from environment variables."))]);
    }
  }
};
var getMinSizeInternal2 = (self) => {
  switch (self._tag) {
    case "Empty":
    case "WithDefault":
    case "WithFallbackConfig": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map": {
      return getMinSizeInternal2(self.args);
    }
    case "Both": {
      const leftMinSize = getMinSizeInternal2(self.left);
      const rightMinSize = getMinSizeInternal2(self.right);
      return leftMinSize + rightMinSize;
    }
    case "Variadic": {
      const argsMinSize = getMinSizeInternal2(self.args);
      return Math.floor(getOrElse(self.min, () => 0) * argsMinSize);
    }
  }
};
var getMaxSizeInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return 0;
    }
    case "Single": {
      return 1;
    }
    case "Map":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getMaxSizeInternal2(self.args);
    }
    case "Both": {
      const leftMaxSize = getMaxSizeInternal2(self.left);
      const rightMaxSize = getMaxSizeInternal2(self.right);
      return leftMaxSize + rightMaxSize;
    }
    case "Variadic": {
      const argsMaxSize = getMaxSizeInternal2(self.args);
      return Math.floor(getOrElse(self.max, () => Number.MAX_SAFE_INTEGER / 2) * argsMaxSize);
    }
  }
};
var getUsageInternal2 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty37;
    }
    case "Single": {
      return named(of(self.name), getChoices(self.primitiveType));
    }
    case "Map": {
      return getUsageInternal2(self.args);
    }
    case "Both": {
      return concat4(getUsageInternal2(self.left), getUsageInternal2(self.right));
    }
    case "Variadic": {
      return repeated2(getUsageInternal2(self.args));
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return optional(getUsageInternal2(self.args));
    }
  }
};
var makeMap2 = (self, f) => {
  const op = Object.create(proto22);
  op._tag = "Map";
  op.args = self;
  op.f = f;
  return op;
};
var makeBoth2 = (left3, right3) => {
  const op = Object.create(proto22);
  op._tag = "Both";
  op.left = left3;
  op.right = right3;
  return op;
};
var validateInternal2 = (self, args2, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed8([args2, void 0]);
    }
    case "Single": {
      return suspend5(() => {
        return matchLeft(args2, {
          onEmpty: () => {
            const choices = getChoices(self.primitiveType);
            if (isSome2(self.pseudoName) && isSome2(choices)) {
              return fail8(missingValue(p(`Missing argument <${self.pseudoName.value}> with choices ${choices.value}`)));
            }
            if (isSome2(self.pseudoName)) {
              return fail8(missingValue(p(`Missing argument <${self.pseudoName.value}>`)));
            }
            if (isSome2(choices)) {
              return fail8(missingValue(p(`Missing argument ${getTypeName(self.primitiveType)} with choices ${choices.value}`)));
            }
            return fail8(missingValue(p(`Missing argument ${getTypeName(self.primitiveType)}`)));
          },
          onNonEmpty: (head5, tail) => validate4(self.primitiveType, some2(head5), config2).pipe(mapBoth4({
            onFailure: (text9) => invalidArgument(p(text9)),
            onSuccess: (a) => [tail, a]
          }))
        });
      });
    }
    case "Map": {
      return validateInternal2(self.args, args2, config2).pipe(flatMap9(([leftover2, a]) => matchEffect2(self.f(a), {
        onFailure: (doc) => fail8(invalidArgument(doc)),
        onSuccess: (b) => succeed8([leftover2, b])
      })));
    }
    case "Both": {
      return validateInternal2(self.left, args2, config2).pipe(flatMap9(([args3, a]) => validateInternal2(self.right, args3, config2).pipe(map17(([args4, b]) => [args4, [a, b]]))));
    }
    case "Variadic": {
      const min1 = getOrElse(self.min, () => 0);
      const max1 = getOrElse(self.max, () => Number.MAX_SAFE_INTEGER);
      const loop2 = (args3, acc) => {
        if (acc.length >= max1) {
          return succeed8([args3, acc]);
        }
        return validateInternal2(self.args, args3, config2).pipe(matchEffect2({
          onFailure: (failure) => acc.length >= min1 && isEmptyReadonlyArray(args3) ? succeed8([args3, acc]) : fail8(failure),
          onSuccess: ([args4, a]) => loop2(args4, append(acc, a))
        }));
      };
      return loop2(args2, empty2()).pipe(map17(([args3, acc]) => [args3, acc]));
    }
    case "WithDefault": {
      return validateInternal2(self.args, args2, config2).pipe(catchTag2("MissingValue", () => succeed8([args2, self.fallback])));
    }
    case "WithFallbackConfig": {
      return validateInternal2(self.args, args2, config2).pipe(catchTag2("MissingValue", (e) => map17(catchAll2(self.config, (e2) => {
        if (isMissingDataOnly2(e2)) {
          const help = p(String(e2));
          const error4 = invalidValue(help);
          return fail8(error4);
        }
        return fail8(e);
      }), (value5) => [args2, value5])));
    }
  }
};
var wizardInternal3 = (self, config2) => {
  switch (self._tag) {
    case "Empty": {
      return succeed8(empty2());
    }
    case "Single": {
      const help = getHelpInternal3(self);
      return wizard(self.primitiveType, help).pipe(zipLeft2(log2()), flatMap9((input) => {
        const args2 = of(input);
        return validateInternal2(self, args2, config2).pipe(as4(args2));
      }));
    }
    case "Map": {
      return wizardInternal3(self.args, config2).pipe(tap2((args2) => validateInternal2(self.args, args2, config2)));
    }
    case "Both": {
      return zipWith5(wizardInternal3(self.left, config2), wizardInternal3(self.right, config2), (left3, right3) => appendAll(left3, right3)).pipe(tap2((args2) => validateInternal2(self, args2, config2)));
    }
    case "Variadic": {
      const repeatHelp = p("How many times should this argument should be repeated?");
      const message = pipe(getHelpInternal3(self), sequence(repeatHelp));
      return integer2({
        message: toAnsiText(message).trimEnd(),
        min: getMinSizeInternal2(self),
        max: getMaxSizeInternal2(self)
      }).pipe(zipLeft2(log2()), flatMap9((n) => n <= 0 ? succeed8(empty2()) : make28(empty2()).pipe(flatMap9((ref) => wizardInternal3(self.args, config2).pipe(flatMap9((args2) => update3(ref, appendAll(args2))), repeatN2(n - 1), zipRight3(get11(ref)), tap2((args2) => validateInternal2(self, args2, config2)))))));
    }
    case "WithDefault": {
      const defaultHelp = p(`This argument is optional - use the default?`);
      const message = pipe(getHelpInternal3(self.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Default ['${JSON.stringify(self.fallback)}']`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log2()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal3(self.args, config2)));
    }
    case "WithFallbackConfig": {
      const defaultHelp = p(`Try load this option from the environment?`);
      const message = pipe(getHelpInternal3(self.args), sequence(defaultHelp));
      return select({
        message: toAnsiText(message).trimEnd(),
        choices: [{
          title: `Use environment variables`,
          value: true
        }, {
          title: "Custom",
          value: false
        }]
      }).pipe(zipLeft2(log2()), flatMap9((useFallback) => useFallback ? succeed8(empty2()) : wizardInternal3(self.args, config2)));
    }
  }
};
var getShortDescription2 = (self) => {
  switch (self._tag) {
    case "Empty":
    case "Both": {
      return "";
    }
    case "Single": {
      return getText(getSpan(self.description));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getShortDescription2(self.args);
    }
  }
};
var getFishCompletions3 = (self) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const description = getShortDescription2(self);
      return pipe(getFishCompletions(self.primitiveType), appendAll(description.length === 0 ? empty2() : of(`-d '${description}'`)), join(" "), of);
    }
    case "Both": {
      return pipe(getFishCompletions3(self.left), appendAll(getFishCompletions3(self.right)));
    }
    case "Map":
    case "Variadic":
    case "WithDefault":
    case "WithFallbackConfig": {
      return getFishCompletions3(self.args);
    }
  }
};
var getZshCompletions3 = (self, state = {
  multiple: false,
  optional: false
}) => {
  switch (self._tag) {
    case "Empty": {
      return empty2();
    }
    case "Single": {
      const multiple = state.multiple ? "*" : "";
      const optional3 = state.optional ? "::" : ":";
      const shortDescription = getShortDescription2(self);
      const description = shortDescription.length > 0 ? ` -- ${shortDescription}` : "";
      const possibleValues = getZshCompletions(self.primitiveType);
      return possibleValues.length === 0 ? empty2() : of(`${multiple}${optional3}${self.name}${description}${possibleValues}`);
    }
    case "Map": {
      return getZshCompletions3(self.args, state);
    }
    case "Both": {
      const left3 = getZshCompletions3(self.left, state);
      const right3 = getZshCompletions3(self.right, state);
      return appendAll(left3, right3);
    }
    case "Variadic": {
      return isSome2(self.max) && self.max.value > 1 ? getZshCompletions3(self.args, {
        ...state,
        multiple: true
      }) : getZshCompletions3(self.args, state);
    }
    case "WithDefault":
    case "WithFallbackConfig": {
      return getZshCompletions3(self.args, {
        ...state,
        optional: true
      });
    }
  }
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/builtInOptions.js
var setLogLevel = (level) => ({
  _tag: "SetLogLevel",
  level
});
var showCompletions = (shellType) => ({
  _tag: "ShowCompletions",
  shellType
});
var showHelp = (usage, helpDoc) => ({
  _tag: "ShowHelp",
  usage,
  helpDoc
});
var showWizard = (command) => ({
  _tag: "ShowWizard",
  command
});
var showVersion = {
  _tag: "ShowVersion"
};
var isShowHelp = (self) => self._tag === "ShowHelp";
var isShowWizard = (self) => self._tag === "ShowWizard";
var completionsOptions = /* @__PURE__ */ choiceWithValue("completions", [["sh", "bash"], ["bash", "bash"], ["fish", "fish"], ["zsh", "zsh"]]).pipe(optional2, /* @__PURE__ */ withDescription2("Generate a completion script for a specific shell."));
var logLevelOptions = /* @__PURE__ */ choiceWithValue("log-level", allLevels.map((level) => [level._tag.toLowerCase(), level])).pipe(optional2, /* @__PURE__ */ withDescription2("Sets the minimum log level for a command."));
var helpOptions = /* @__PURE__ */ boolean4("help").pipe(/* @__PURE__ */ withAlias("h"), /* @__PURE__ */ withDescription2("Show the help documentation for a command."));
var versionOptions = /* @__PURE__ */ boolean4("version").pipe(/* @__PURE__ */ withDescription2("Show the version of the application."));
var wizardOptions = /* @__PURE__ */ boolean4("wizard").pipe(/* @__PURE__ */ withDescription2("Start wizard mode for a command."));
var builtIns = /* @__PURE__ */ all6({
  completions: completionsOptions,
  logLevel: logLevelOptions,
  help: helpOptions,
  wizard: wizardOptions,
  version: versionOptions
});
var builtInOptions = (command, usage, helpDoc) => map28(builtIns, (builtIn2) => {
  if (isSome2(builtIn2.completions)) {
    return some2(showCompletions(builtIn2.completions.value));
  }
  if (isSome2(builtIn2.logLevel)) {
    return some2(setLogLevel(builtIn2.logLevel.value));
  }
  if (builtIn2.help) {
    return some2(showHelp(usage, helpDoc));
  }
  if (builtIn2.wizard) {
    return some2(showWizard(command));
  }
  if (builtIn2.version) {
    return some2(showVersion);
  }
  return none2();
});

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/commandDirective.js
var builtIn = (option4) => ({
  _tag: "BuiltIn",
  option: option4
});
var userDefined = (leftover2, value5) => ({
  _tag: "UserDefined",
  leftover: leftover2,
  value: value5
});
var isBuiltIn = (self) => self._tag === "BuiltIn";
var isUserDefined = (self) => self._tag === "UserDefined";
var map31 = /* @__PURE__ */ dual(2, (self, f) => isUserDefined(self) ? userDefined(self.leftover, f(self.value)) : self);

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/commandDescriptor.js
var CommandDescriptorSymbolKey = "@effect/cli/CommandDescriptor";
var TypeId24 = /* @__PURE__ */ Symbol.for(CommandDescriptorSymbolKey);
var proto23 = {
  [TypeId24]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCommand2 = (u) => typeof u === "object" && u != null && TypeId24 in u;
var isStandard = (self) => self._tag === "Standard";
var make60 = (name2, options3 = none10, args2 = none11) => {
  const op = Object.create(proto23);
  op._tag = "Standard";
  op.name = name2;
  op.description = empty36;
  op.options = options3;
  op.args = args2;
  return op;
};
var getHelp5 = (self, config2) => getHelpInternal4(self, config2);
var getNames2 = (self) => fromIterable5(getNamesInternal(self));
var getBashCompletions3 = (self, executable) => getBashCompletionsInternal(self, executable);
var getFishCompletions4 = (self, executable) => getFishCompletionsInternal(self, executable);
var getZshCompletions4 = (self, executable) => getZshCompletionsInternal(self, executable);
var getSubcommands = (self) => fromIterable6(getSubcommandsInternal(self));
var getUsage3 = (self) => getUsageInternal3(self);
var map32 = /* @__PURE__ */ dual(2, (self, f) => mapEffect8(self, (a) => right2(f(a))));
var mapEffect8 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto23);
  op._tag = "Map";
  op.command = self;
  op.f = f;
  return op;
});
var parse7 = /* @__PURE__ */ dual(3, (self, args2, config2) => parseInternal2(self, args2, config2));
var wizard4 = /* @__PURE__ */ dual(3, (self, prefix, config2) => wizardInternal4(self, prefix, config2));
var getHelpInternal4 = (self, config2) => {
  switch (self._tag) {
    case "Standard": {
      const header = isEmpty14(self.description) ? empty36 : sequence(h1("DESCRIPTION"), self.description);
      const argsHelp = getHelp4(self.args);
      const argsSection = isEmpty14(argsHelp) ? empty36 : sequence(h1("ARGUMENTS"), argsHelp);
      const options3 = config2.showBuiltIns ? all7([self.options, builtIns]) : self.options;
      const optionsHelp = getHelp3(options3);
      const optionsSection = isEmpty14(optionsHelp) ? empty36 : sequence(h1("OPTIONS"), optionsHelp);
      return sequence(header, sequence(argsSection, optionsSection));
    }
    case "GetUserInput": {
      return isEmpty14(self.description) ? empty36 : sequence(h1("DESCRIPTION"), self.description);
    }
    case "Map": {
      return getHelpInternal4(self.command, config2);
    }
    case "Subcommands": {
      const getUsage5 = (command, preceding) => {
        switch (command._tag) {
          case "Standard":
          case "GetUserInput": {
            const usage = getSpan(getHelp2(getUsageInternal3(command)));
            const usages = append(preceding, usage);
            const finalUsage = reduce(usages, empty35, (acc, next) => isText3(acc) && acc.value === "" ? next : isText3(next) && next.value === "" ? acc : spans([acc, space3, next]));
            const description = getSpan(command.description);
            return of([finalUsage, description]);
          }
          case "Map": {
            return getUsage5(command.command, preceding);
          }
          case "Subcommands": {
            const parentUsage = getUsage5(command.parent, preceding);
            return match2(head(parentUsage), {
              onNone: () => flatMap2(command.children, (child) => getUsage5(child, preceding)),
              onSome: ([usage]) => {
                const childrenUsage = flatMap2(command.children, (child) => getUsage5(child, append(preceding, usage)));
                return appendAll(parentUsage, childrenUsage);
              }
            });
          }
        }
      };
      const printSubcommands = (subcommands) => {
        const maxUsageLength = reduceRight(subcommands, 0, (max6, [usage]) => Math.max(size12(usage), max6));
        const documents = map3(subcommands, ([usage, desc]) => p(spans([usage, text4(" ".repeat(maxUsageLength - size12(usage) + 2)), desc])));
        if (isNonEmptyReadonlyArray(documents)) {
          return enumeration(documents);
        }
        throw new Error("[BUG]: Subcommands.usage - received empty list of subcommands to print");
      };
      return sequence(getHelpInternal4(self.parent, config2), sequence(h1("COMMANDS"), printSubcommands(flatMap2(self.children, (child) => getUsage5(child, empty2())))));
    }
  }
};
var getNamesInternal = (self) => {
  switch (self._tag) {
    case "Standard":
    case "GetUserInput": {
      return of(self.name);
    }
    case "Map": {
      return getNamesInternal(self.command);
    }
    case "Subcommands": {
      return getNamesInternal(self.parent);
    }
  }
};
var getSubcommandsInternal = (self) => {
  const loop2 = (self2, isSubcommand) => {
    switch (self2._tag) {
      case "Standard":
      case "GetUserInput": {
        return of([self2.name, self2]);
      }
      case "Map": {
        return loop2(self2.command, isSubcommand);
      }
      case "Subcommands": {
        return isSubcommand ? loop2(self2.parent, false) : flatMap2(self2.children, (child) => loop2(child, true));
      }
    }
  };
  return loop2(self, false);
};
var getUsageInternal3 = (self) => {
  switch (self._tag) {
    case "Standard": {
      return concat4(named(of(self.name), none2()), concat4(getUsage(self.options), getUsage2(self.args)));
    }
    case "GetUserInput": {
      return named(of(self.name), none2());
    }
    case "Map": {
      return getUsageInternal3(self.command);
    }
    case "Subcommands": {
      return concat4(getUsageInternal3(self.parent), mixed);
    }
  }
};
var parseInternal2 = (self, args2, config2) => {
  const parseCommandLine2 = (self2, args3) => matchLeft(args3, {
    onEmpty: () => {
      const error4 = p(`Missing command name: '${self2.name}'`);
      return fail8(commandMismatch(error4));
    },
    onNonEmpty: (head5, tail) => {
      const normalizedArgv0 = normalizeCase(config2, head5);
      const normalizedCommandName = normalizeCase(config2, self2.name);
      return succeed8(tail).pipe(when2(() => normalizedArgv0 === normalizedCommandName), flatten5, catchTag2("NoSuchElementException", () => {
        const error4 = p(`Missing command name: '${self2.name}'`);
        return fail8(commandMismatch(error4));
      }));
    }
  });
  switch (self._tag) {
    case "Standard": {
      const parseBuiltInArgs = (args3) => matchLeft(args3, {
        onEmpty: () => {
          const error4 = p(`Missing command name: '${self.name}'`);
          return fail8(commandMismatch(error4));
        },
        onNonEmpty: (argv0) => {
          const normalizedArgv0 = normalizeCase(config2, argv0);
          const normalizedCommandName = normalizeCase(config2, self.name);
          if (normalizedArgv0 === normalizedCommandName) {
            const help = getHelpInternal4(self, config2);
            const usage = getUsageInternal3(self);
            const options3 = builtInOptions(self, usage, help);
            const argsWithoutCommand = drop(args3, 1);
            return processCommandLine(options3, argsWithoutCommand, config2).pipe(flatMap9((tuple3) => tuple3[2]), catchTag2("NoSuchElementException", () => {
              const error5 = p("No built-in option was matched");
              return fail8(noBuiltInMatch(error5));
            }), map17(builtIn));
          }
          const error4 = p(`Missing command name: '${self.name}'`);
          return fail8(commandMismatch(error4));
        }
      });
      const parseUserDefinedArgs = (args3) => parseCommandLine2(self, args3).pipe(flatMap9((commandOptionsAndArgs) => {
        const [optionsAndArgs, forcedCommandArgs] = splitForcedArgs(commandOptionsAndArgs);
        return processCommandLine(self.options, optionsAndArgs, config2).pipe(flatMap9(([error4, commandArgs, optionsType]) => validate5(self.args, appendAll(commandArgs, forcedCommandArgs), config2).pipe(catchAll2((e) => match2(error4, {
          onNone: () => fail8(e),
          onSome: (err) => fail8(err)
        })), map17(([argsLeftover, argsType]) => userDefined(argsLeftover, {
          name: self.name,
          options: optionsType,
          args: argsType
        })))));
      }));
      const exhaustiveSearch = (args3) => {
        if (contains2(args3, "--help") || contains2(args3, "-h")) {
          return parseBuiltInArgs(make4(self.name, "--help"));
        }
        if (contains2(args3, "--wizard")) {
          return parseBuiltInArgs(make4(self.name, "--wizard"));
        }
        if (contains2(args3, "--version")) {
          return parseBuiltInArgs(make4(self.name, "--version"));
        }
        const error4 = p(`Missing command name: '${self.name}'`);
        return fail8(commandMismatch(error4));
      };
      return parseBuiltInArgs(args2).pipe(orElse5(() => parseUserDefinedArgs(args2)), catchSome2((e) => {
        if (isValidationError(e)) {
          if (config2.finalCheckBuiltIn) {
            return some2(exhaustiveSearch(args2).pipe(catchSome2((_) => isValidationError(_) ? some2(fail8(e)) : none2())));
          }
          return some2(fail8(e));
        }
        return none2();
      }));
    }
    case "GetUserInput": {
      return parseCommandLine2(self, args2).pipe(zipRight3(run5(self.prompt)), catchTag2("QuitException", (e) => die5(e)), map17((value5) => userDefined(drop(args2, 1), {
        name: self.name,
        value: value5
      })));
    }
    case "Map": {
      return parseInternal2(self.command, args2, config2).pipe(flatMap9((directive) => {
        if (isUserDefined(directive)) {
          return self.f(directive.value).pipe(map17((value5) => userDefined(directive.leftover, value5)));
        }
        return succeed8(directive);
      }));
    }
    case "Subcommands": {
      const names = getNamesInternal(self);
      const subcommands = getSubcommandsInternal(self);
      const [parentArgs, childArgs] = span(args2, (arg) => !some3(subcommands, ([name2]) => name2 === arg));
      const parseChildren = suspend5(() => {
        const iterator = self.children[Symbol.iterator]();
        const loop2 = (next) => {
          return parseInternal2(next, childArgs, config2).pipe(catchIf2(isCommandMismatch, (e) => {
            const next2 = iterator.next();
            return next2.done ? fail8(e) : loop2(next2.value);
          }));
        };
        return loop2(iterator.next().value);
      });
      const helpDirectiveForParent = sync5(() => {
        return builtIn(showHelp(getUsageInternal3(self), getHelpInternal4(self, config2)));
      });
      const helpDirectiveForChild = parseChildren.pipe(flatMap9((directive) => {
        if (isBuiltIn(directive) && isShowHelp(directive.option)) {
          const parentName = getOrElse(head(names), () => "");
          const newDirective = builtIn(showHelp(concat4(named(of(parentName), none2()), directive.option.usage), directive.option.helpDoc));
          return succeed8(newDirective);
        }
        return fail8(invalidArgument(empty36));
      }));
      const wizardDirectiveForParent = sync5(() => builtIn(showWizard(self)));
      const wizardDirectiveForChild = parseChildren.pipe(flatMap9((directive) => {
        if (isBuiltIn(directive) && isShowWizard(directive.option)) {
          return succeed8(directive);
        }
        return fail8(invalidArgument(empty36));
      }));
      return suspend5(() => parseInternal2(self.parent, parentArgs, config2).pipe(flatMap9((directive) => {
        switch (directive._tag) {
          case "BuiltIn": {
            if (isShowHelp(directive.option)) {
              return isNonEmptyReadonlyArray(childArgs) ? orElse5(helpDirectiveForChild, () => helpDirectiveForParent) : helpDirectiveForParent;
            }
            if (isShowWizard(directive.option)) {
              return orElse5(wizardDirectiveForChild, () => wizardDirectiveForParent);
            }
            return succeed8(directive);
          }
          case "UserDefined": {
            const args3 = appendAll(directive.leftover, childArgs);
            if (isNonEmptyReadonlyArray(args3)) {
              return parseChildren.pipe(mapBoth4({
                onFailure: (err) => {
                  if (isCommandMismatch(err)) {
                    const parentName = getOrElse(head(names), () => "");
                    const childNames = map3(subcommands, ([name2]) => `'${name2}'`);
                    const oneOf = childNames.length === 1 ? "" : " one of";
                    const error4 = p(`Invalid subcommand for ${parentName} - use${oneOf} ${join(childNames, ", ")}`);
                    return commandMismatch(error4);
                  }
                  return err;
                },
                onSuccess: map31((subcommand) => ({
                  ...directive.value,
                  subcommand: some2(subcommand)
                }))
              }));
            }
            return succeed8(userDefined(directive.leftover, {
              ...directive.value,
              subcommand: none2()
            }));
          }
        }
      }), catchSome2(() => isEmptyReadonlyArray(args2) ? some2(helpDirectiveForParent) : none2())));
    }
  }
};
var splitForcedArgs = (args2) => {
  const [remainingArgs, forcedArgs] = span(args2, (str) => str !== "--");
  return [remainingArgs, drop(forcedArgs, 1)];
};
var argsWizardHeader = /* @__PURE__ */ code("Args Wizard - ");
var optionsWizardHeader = /* @__PURE__ */ code("Options Wizard - ");
var wizardInternal4 = (self, prefix, config2) => {
  const loop2 = (self2, commandLineRef) => {
    switch (self2._tag) {
      case "GetUserInput":
      case "Standard": {
        return gen2(function* () {
          const logCurrentCommand = get11(commandLineRef).pipe(flatMap9((commandLine) => {
            const currentCommand = p(pipe(strong(highlight("COMMAND:", cyan3)), concat3(space3), concat3(highlight(join(commandLine, " "), magenta3))));
            return log2(toAnsiText(currentCommand));
          }));
          if (isStandard(self2)) {
            yield* logCurrentCommand;
            const commandName = highlight(self2.name, magenta3);
            if (!isEmpty15(self2.options)) {
              const message = p(concat3(optionsWizardHeader, commandName));
              yield* log2(toAnsiText(message));
              const options3 = yield* wizard2(self2.options, config2);
              yield* updateAndGet2(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
            if (!isEmpty16(self2.args)) {
              const message = p(concat3(argsWizardHeader, commandName));
              yield* log2(toAnsiText(message));
              const options3 = yield* wizard3(self2.args, config2);
              yield* updateAndGet2(commandLineRef, appendAll(options3));
              yield* logCurrentCommand;
            }
          }
          return yield* get11(commandLineRef);
        });
      }
      case "Map": {
        return loop2(self2.command, commandLineRef);
      }
      case "Subcommands": {
        const description = p("Select which command you would like to execute");
        const message = toAnsiText(description).trimEnd();
        const makeChoice = (title, index) => ({
          title,
          value: [title, index]
        });
        const choices = pipe(getSubcommandsInternal(self2), map3(([name2], index) => makeChoice(name2, index)));
        return loop2(self2.parent, commandLineRef).pipe(zipRight3(select({
          message,
          choices
        }).pipe(tap2(([name2]) => update3(commandLineRef, append(name2))), zipLeft2(log2()), flatMap9(([, nextIndex]) => loop2(self2.children[nextIndex], commandLineRef)))));
      }
    }
  };
  return make28(prefix).pipe(flatMap9((commandLineRef) => loop2(self, commandLineRef).pipe(zipRight3(get11(commandLineRef)))));
};
var getShortDescription3 = (self) => {
  switch (self._tag) {
    case "Standard": {
      return getText(getSpan(self.description));
    }
    case "GetUserInput": {
      return getText(getSpan(self.description));
    }
    case "Map": {
      return getShortDescription3(self.command);
    }
    case "Subcommands": {
      return "";
    }
  }
};
var traverseCommand = (self, initialState3, f) => make59(initialState3).pipe(flatMap9((ref) => {
  const loop2 = (self2, parentCommands, subcommands, level) => {
    switch (self2._tag) {
      case "Standard": {
        const info2 = {
          command: self2,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info2));
      }
      case "GetUserInput": {
        const info2 = {
          command: self2,
          parentCommands,
          subcommands,
          level
        };
        return updateEffect2(ref, (state) => f(state, info2));
      }
      case "Map": {
        return loop2(self2.command, parentCommands, subcommands, level);
      }
      case "Subcommands": {
        const parentNames = getNamesInternal(self2.parent);
        const nextSubcommands = getSubcommandsInternal(self2);
        const nextParentCommands = appendAll(parentCommands, parentNames);
        return loop2(self2.parent, parentCommands, nextSubcommands, level).pipe(zipRight3(forEach8(self2.children, (child) => (
          // Traverse the child command using next parent names and old subcommands
          loop2(child, nextParentCommands, subcommands, level + 1)
        ))));
      }
    }
  };
  return suspend5(() => loop2(self, empty2(), empty2(), 0)).pipe(zipRight3(get13(ref)));
}));
var indentAll = /* @__PURE__ */ dual(2, (self, indent3) => {
  const indentation = allocate(indent3 + 1).join(" ");
  return map3(self, (line4) => `${indentation}${line4}`);
});
var getBashCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const options3 = isStandard(info2.command) ? all7([info2.command.options, builtIns]) : builtIns;
  const optionNames = getNames(options3);
  const optionCases = isStandard(info2.command) ? getBashCompletions2(info2.command.options) : empty2();
  const subcommandNames = pipe(info2.subcommands, map3(([name2]) => name2), sort(string2));
  const wordList = appendAll(optionNames, subcommandNames);
  const preformatted = isEmptyReadonlyArray(info2.parentCommands) ? of(info2.command.name) : pipe(info2.parentCommands, append(info2.command.name), map3((command) => command.replace("-", "__")));
  const caseName = join(preformatted, ",");
  const funcName = join(preformatted, "__");
  const funcLines = isEmptyReadonlyArray(info2.parentCommands) ? empty2() : [`${caseName})`, `    cmd="${funcName}"`, "    ;;"];
  const cmdLines = [`${funcName})`, `    opts="${join(wordList, " ")}"`, `    if [[ \${cur} == -* || \${COMP_CWORD} -eq ${info2.level + 1} ]] ; then`, '        COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "        return 0", "    fi", '    case "${prev}" in', ...indentAll(optionCases, 8), "    *)", "        COMPREPLY=()", "        ;;", "    esac", '    COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )', "    return 0", "    ;;"];
  const lines3 = append(state, [funcLines, cmdLines]);
  return succeed8(lines3);
}).pipe(map17((lines3) => {
  const rootCommand = unsafeGet(getNamesInternal(self), 0);
  const scriptName = `_${rootCommand}_bash_completions`;
  const funcCases = flatMap2(lines3, ([funcLines]) => funcLines);
  const cmdCases = flatMap2(lines3, ([, cmdLines]) => cmdLines);
  return [`function ${scriptName}() {`, "    local i cur prev opts cmd", "    COMPREPLY=()", '    cur="${COMP_WORDS[COMP_CWORD]}"', '    prev="${COMP_WORDS[COMP_CWORD-1]}"', '    cmd=""', '    opts=""', '    for i in "${COMP_WORDS[@]}"; do', '        case "${cmd},${i}" in', '            ",$1")', `                cmd="${executable}"`, "                ;;", ...indentAll(funcCases, 12), "            *)", "                ;;", "        esac", "    done", '    case "${cmd}" in', ...indentAll(cmdCases, 8), "    esac", "}", `complete -F ${scriptName} -o nosort -o bashdefault -o default ${rootCommand}`];
}));
var getFishCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const baseTemplate = make4("complete", "-c", executable);
  const options3 = isStandard(info2.command) ? all6([builtIns, info2.command.options]) : builtIns;
  const optionsCompletions = getFishCompletions2(options3);
  const argsCompletions = isStandard(info2.command) ? getFishCompletions3(info2.command.args) : empty2();
  const rootCompletions = (conditionals2) => pipe(map3(optionsCompletions, (option4) => pipe(baseTemplate, appendAll(conditionals2), append(option4), join(" "))), appendAll(map3(argsCompletions, (option4) => pipe(baseTemplate, appendAll(conditionals2), append(option4), join(" ")))));
  const subcommandCompletions = (conditionals2) => map3(info2.subcommands, ([name2, subcommand]) => {
    const description = getShortDescription3(subcommand);
    return pipe(baseTemplate, appendAll(conditionals2), appendAll(make4("-f", "-a", `"${name2}"`)), appendAll(description.length === 0 ? empty2() : make4("-d", `'${description}'`)), join(" "));
  });
  if (isEmptyReadonlyArray(info2.parentCommands)) {
    const conditionals2 = make4("-n", '"__fish_use_subcommand"');
    return succeed8(pipe(state, appendAll(rootCompletions(conditionals2)), appendAll(subcommandCompletions(conditionals2))));
  }
  const parentConditionals = pipe(
    info2.parentCommands,
    // Drop the root command name from the subcommand conditionals
    drop(1),
    append(info2.command.name),
    map3((command) => `__fish_seen_subcommand_from ${command}`)
  );
  const subcommandConditionals = map3(info2.subcommands, ([name2]) => `not __fish_seen_subcommand_from ${name2}`);
  const baseConditionals = pipe(appendAll(parentConditionals, subcommandConditionals), join("; and "));
  const conditionals = make4("-n", `"${baseConditionals}"`);
  return succeed8(pipe(state, appendAll(rootCompletions(conditionals)), appendAll(subcommandCompletions(conditionals))));
});
var getZshCompletionsInternal = (self, executable) => traverseCommand(self, empty2(), (state, info2) => {
  const preformatted = isEmptyReadonlyArray(info2.parentCommands) ? of(info2.command.name) : pipe(info2.parentCommands, append(info2.command.name), map3((command) => command.replace("-", "__")));
  const underscoreName = join(preformatted, "__");
  const spaceName = join(preformatted, " ");
  const subcommands = pipe(info2.subcommands, map3(([name2, subcommand]) => {
    const desc = getShortDescription3(subcommand);
    return `'${name2}:${desc}' \\`;
  }));
  const commands = isEmptyReadonlyArray(subcommands) ? `commands=()` : `commands=(
${join(indentAll(subcommands, 8), "\n")}
    )`;
  const handlerLines = [`(( $+functions[_${underscoreName}_commands] )) ||`, `_${underscoreName}_commands() {`, `    local commands; ${commands}`, `    _describe -t commands '${spaceName} commands' commands "$@"`, "}"];
  return succeed8(appendAll(state, handlerLines));
}).pipe(map17((handlers) => {
  const rootCommand = unsafeGet(getNamesInternal(self), 0);
  const cases = getZshSubcommandCases(self, empty2(), empty2());
  const scriptName = `_${rootCommand}_zsh_completions`;
  return [`#compdef ${executable}`, "", "autoload -U is-at-least", "", `function ${scriptName}() {`, "    typeset -A opt_args", "    typeset -a _arguments_options", "    local ret=1", "", "    if is-at-least 5.2; then", "        _arguments_options=(-s -S -C)", "    else", "        _arguments_options=(-s -C)", "    fi", "", '    local context curcontext="$curcontext" state line', ...indentAll(cases, 4), "}", "", ...handlers, "", `if [ "$funcstack[1]" = "${scriptName}" ]; then`, `    ${scriptName} "$@"`, "else", `    compdef ${scriptName} ${rootCommand}`, "fi"];
}));
var getZshSubcommandCases = (self, parentCommands, subcommands) => {
  switch (self._tag) {
    case "Standard":
    case "GetUserInput": {
      const options3 = isStandard(self) ? all6([builtIns, self.options]) : builtIns;
      const args2 = isStandard(self) ? self.args : none11;
      const optionCompletions = pipe(getZshCompletions2(options3), map3((completion) => `'${completion}' \\`));
      const argCompletions = pipe(getZshCompletions3(args2), map3((completion) => `'${completion}' \\`));
      if (isEmptyReadonlyArray(parentCommands)) {
        return ['_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${self.name}_commands" \\`, `    "*::: :->${self.name}" \\`, "    && ret=0"];
      }
      if (isEmptyReadonlyArray(subcommands)) {
        return [`(${self.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), "    && ret=0", ";;"];
      }
      return [`(${self.name})`, '_arguments "${_arguments_options[@]}" \\', ...indentAll(optionCompletions, 4), ...indentAll(argCompletions, 4), `    ":: :_${append(parentCommands, self.name).join("__")}_commands" \\`, `    "*::: :->${self.name}" \\`, "    && ret=0"];
    }
    case "Map": {
      return getZshSubcommandCases(self.command, parentCommands, subcommands);
    }
    case "Subcommands": {
      const nextSubcommands = getSubcommandsInternal(self);
      const parentNames = getNamesInternal(self.parent);
      const parentLines = getZshSubcommandCases(self.parent, parentCommands, appendAll(subcommands, nextSubcommands));
      const childCases = pipe(self.children, flatMap2((child) => getZshSubcommandCases(child, appendAll(parentCommands, parentNames), subcommands)));
      const hyphenName = pipe(appendAll(parentCommands, parentNames), join("-"));
      const childLines = pipe(parentNames, flatMap2((parentName) => ["case $state in", `    (${parentName})`, `    words=($line[1] "\${words[@]}")`, "    (( CURRENT += 1 ))", `    curcontext="\${curcontext%:*:*}:${hyphenName}-command-$line[1]:"`, `    case $line[1] in`, ...indentAll(childCases, 8), "    esac", "    ;;", "esac"]), appendAll(isEmptyReadonlyArray(parentCommands) ? empty2() : of(";;")));
      return appendAll(parentLines, childLines);
    }
  }
};
var helpRequestedError = (command) => {
  const op = Object.create(proto20);
  op._tag = "HelpRequested";
  op.error = empty36;
  op.command = command;
  return op;
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/ValidationError.js
var helpRequested = helpRequestedError;

// node_modules/.pnpm/effect@3.15.2/node_modules/effect/dist/esm/Unify.js
var unify2 = identity;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/cliApp.js
var proto24 = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make61 = (config2) => {
  const op = Object.create(proto24);
  op.name = config2.name;
  op.version = config2.version;
  op.executable = config2.executable;
  op.command = config2.command;
  op.summary = config2.summary || empty35;
  op.footer = config2.footer || empty36;
  return op;
};
var run6 = /* @__PURE__ */ dual(3, (self, args2, execute2) => contextWithEffect2((context7) => {
  const config2 = getOrElse(getOption2(context7, Tag4), () => defaultConfig);
  const [executable, filteredArgs] = splitExecutable(self, args2);
  const prefixedArgs = appendAll(prefixCommand(self.command), filteredArgs);
  return matchEffect2(parse7(self.command, prefixedArgs, config2), {
    onFailure: (e) => zipRight3(printDocs(e.error), fail8(e)),
    onSuccess: unify2((directive) => {
      switch (directive._tag) {
        case "UserDefined": {
          return matchLeft(directive.leftover, {
            onEmpty: () => execute2(directive.value).pipe(catchSome2((e) => isValidationError(e) && isHelpRequested(e) ? some2(handleBuiltInOption(self, executable, filteredArgs, showHelp(getUsage3(e.command), getHelp5(e.command, config2)), execute2, config2)) : none2())),
            onNonEmpty: (head5) => {
              const error4 = p(`Received unknown argument: '${head5}'`);
              return zipRight3(printDocs(error4), fail8(invalidValue(error4)));
            }
          });
        }
        case "BuiltIn": {
          return handleBuiltInOption(self, executable, filteredArgs, directive.option, execute2, config2).pipe(catchSome2((e) => isValidationError(e) ? some2(zipRight3(printDocs(e.error), fail8(e))) : none2()));
        }
      }
    })
  });
}));
var splitExecutable = (self, args2) => {
  if (self.executable !== void 0) {
    return [self.executable, drop(args2, 2)];
  }
  const [[runtime5, script], optionsAndArgs] = splitAt(args2, 2);
  return [`${runtime5} ${script}`, optionsAndArgs];
};
var printDocs = (error4) => error2(toAnsiText(error4));
var isQuitException = (u) => typeof u === "object" && u != null && "_tag" in u && u._tag === "QuitException";
var handleBuiltInOption = (self, executable, args2, builtIn2, execute2, config2) => {
  switch (builtIn2._tag) {
    case "SetLogLevel": {
      const nextArgs = executable.split(/\s+/);
      for (let i = 0; i < args2.length; i++) {
        if (args2[i] === "--log-level" || args2[i - 1] === "--log-level") {
          continue;
        }
        nextArgs.push(args2[i]);
      }
      return run6(self, nextArgs, execute2).pipe(withMinimumLogLevel2(builtIn2.level));
    }
    case "ShowHelp": {
      const banner = h1(code(self.name));
      const header = p(spans([text4(`${self.name} ${self.version}`), isEmpty13(self.summary) ? empty35 : spans([space3, text4("--"), space3, self.summary])]));
      const usage = sequence(h1("USAGE"), pipe(enumerate(builtIn2.usage, config2), map3((span2) => p(concat3(text4("$ "), span2))), reduceRight(empty36, (left3, right3) => sequence(left3, right3))));
      const helpDoc = pipe(banner, sequence(header), sequence(usage), sequence(builtIn2.helpDoc), sequence(self.footer));
      return log2(toAnsiText(helpDoc));
    }
    case "ShowCompletions": {
      const command = fromIterable(getNames2(self.command))[0];
      switch (builtIn2.shellType) {
        case "bash": {
          return getBashCompletions3(self.command, command).pipe(flatMap9((completions) => log2(join(completions, "\n"))));
        }
        case "fish": {
          return getFishCompletions4(self.command, command).pipe(flatMap9((completions) => log2(join(completions, "\n"))));
        }
        case "zsh":
          return getZshCompletions4(self.command, command).pipe(flatMap9((completions) => log2(join(completions, "\n"))));
      }
    }
    case "ShowWizard": {
      const summary5 = isEmpty13(self.summary) ? empty35 : spans([space3, text4("--"), space3, self.summary]);
      const instructions = sequence(p(spans([text4("The wizard mode will assist you with constructing commands for"), space3, code(`${self.name} (${self.version})`), text4(".")])), p("Please answer all prompts provided by the wizard."));
      const description = descriptionList([[text4("Instructions"), instructions]]);
      const header = h1(spans([code("Wizard Mode for CLI Application:"), space3, code(self.name), space3, code(`(${self.version})`), summary5]));
      const help = sequence(header, description);
      const text9 = toAnsiText(help);
      const command = fromIterable(getNames2(self.command))[0];
      const wizardPrefix = getWizardPrefix(builtIn2, command, args2);
      return log2(text9).pipe(zipRight3(wizard4(builtIn2.command, wizardPrefix, config2)), tap2((args3) => log2(toAnsiText(renderWizardArgs(args3)))), flatMap9((args3) => toggle2({
        message: "Would you like to run the command?",
        initial: true,
        active: "yes",
        inactive: "no"
      }).pipe(flatMap9((shouldRunCommand) => {
        const finalArgs = pipe(drop(args3, 1), prependAll(executable.split(/\s+/)));
        return shouldRunCommand ? log2().pipe(zipRight3(run6(self, finalArgs, execute2))) : _void;
      }))), catchAll2((e) => {
        if (isQuitException(e)) {
          const message = p(error3("\n\nQuitting wizard mode..."));
          return log2(toAnsiText(message));
        }
        return fail8(e);
      }));
    }
    case "ShowVersion": {
      const help = p(self.version);
      return log2(toAnsiText(help));
    }
  }
};
var prefixCommand = (self) => {
  let command = self;
  let prefix = empty2();
  while (command !== void 0) {
    switch (command._tag) {
      case "Standard": {
        prefix = of(command.name);
        command = void 0;
        break;
      }
      case "GetUserInput": {
        prefix = of(command.name);
        command = void 0;
        break;
      }
      case "Map": {
        command = command.command;
        break;
      }
      case "Subcommands": {
        command = command.parent;
        break;
      }
    }
  }
  return prefix;
};
var getWizardPrefix = (builtIn2, rootCommand, commandLineArgs) => {
  const subcommands = getSubcommands(builtIn2.command);
  const [parentArgs, childArgs] = span(commandLineArgs, (name2) => !has4(subcommands, name2));
  const args2 = matchLeft(childArgs, {
    onEmpty: () => filter2(parentArgs, (arg) => arg !== "--wizard"),
    onNonEmpty: (head5) => append(parentArgs, head5)
  });
  return appendAll(rootCommand.split(/\s+/), args2);
};
var renderWizardArgs = (args2) => {
  const params = pipe(filter2(args2, (param) => param.length > 0), join(" "));
  const executeMsg = text4("You may now execute your command directly with the following options and arguments:");
  return blocks([p(strong(code("Wizard Mode Complete!"))), p(executeMsg), p(concat3(text4("    "), highlight(params, cyan3)))]);
};

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/internal/command.js
var CommandSymbolKey = "@effect/cli/Command";
var TypeId25 = /* @__PURE__ */ Symbol.for(CommandSymbolKey);
var parseConfig = (config2) => {
  const args2 = [];
  let argsIndex = 0;
  const options3 = [];
  let optionsIndex = 0;
  function parse8(config3) {
    const tree = {};
    for (const key in config3) {
      tree[key] = parseValue(config3[key]);
    }
    return tree;
  }
  function parseValue(value5) {
    if (isArray(value5)) {
      return {
        _tag: "Array",
        children: map3(value5, parseValue)
      };
    } else if (isArgs(value5)) {
      args2.push(value5);
      return {
        _tag: "Args",
        index: argsIndex++
      };
    } else if (isOptions(value5)) {
      options3.push(value5);
      return {
        _tag: "Options",
        index: optionsIndex++
      };
    } else {
      return {
        _tag: "ParsedConfig",
        tree: parse8(value5)
      };
    }
  }
  return {
    args: args2,
    options: options3,
    tree: parse8(config2)
  };
};
var reconstructConfigTree = (tree, args2, options3) => {
  const output = {};
  for (const key in tree) {
    output[key] = nodeValue(tree[key]);
  }
  return output;
  function nodeValue(node) {
    if (node._tag === "Args") {
      return args2[node.index];
    } else if (node._tag === "Options") {
      return options3[node.index];
    } else if (node._tag === "Array") {
      return map3(node.children, nodeValue);
    } else {
      return reconstructConfigTree(node.tree, args2, options3);
    }
  }
};
var Prototype = {
  ...CommitPrototype2,
  [TypeId25]: TypeId25,
  commit() {
    return this.tag;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var registeredDescriptors = /* @__PURE__ */ globalValue("@effect/cli/Command/registeredDescriptors", () => /* @__PURE__ */ new WeakMap());
var getDescriptor = (self) => registeredDescriptors.get(self.tag) ?? self.descriptor;
var makeProto = (descriptor2, handler, tag4, transform3 = identity) => {
  const self = Object.create(Prototype);
  self.descriptor = descriptor2;
  self.handler = handler;
  self.transform = transform3;
  self.tag = tag4;
  return self;
};
var makeDerive = (self, options3) => {
  const command = Object.create(Prototype);
  command.descriptor = options3.descriptor ?? self.descriptor;
  command.handler = options3.handler ?? self.handler;
  command.transform = options3.transform ? (effect3, opts) => options3.transform(self.transform(effect3, opts), opts) : self.transform;
  command.tag = self.tag;
  return command;
};
var fromDescriptor = /* @__PURE__ */ dual((args2) => isCommand2(args2[0]), (descriptor2, handler) => {
  const self = makeProto(descriptor2, handler ?? ((_) => failSync2(() => helpRequested(getDescriptor(self)))), GenericTag(`@effect/cli/Command/(${fromIterable(getNames2(descriptor2)).join("|")})`));
  return self;
});
var makeDescriptor = (name2, config2) => {
  const {
    args: args2,
    options: options3,
    tree
  } = parseConfig(config2);
  return map32(make60(name2, all6(options3), all8(args2)), ({
    args: args3,
    options: options4
  }) => reconstructConfigTree(tree, args3, options4));
};
var make62 = (name2, config2 = {}, handler) => fromDescriptor(makeDescriptor(name2, config2), handler);
var withHandler = /* @__PURE__ */ dual(2, (self, handler) => makeDerive(self, {
  handler,
  transform: identity
}));
var run7 = /* @__PURE__ */ dual(2, (self, config2) => {
  const app = make61({
    ...config2,
    command: self.descriptor
  });
  registeredDescriptors.set(self.tag, self.descriptor);
  const handler = (args2) => self.transform(self.handler(args2), args2);
  return (args2) => run6(app, args2, handler);
});

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/Command.js
var make63 = make62;
var withHandler2 = withHandler;
var run8 = run7;

// node_modules/.pnpm/@effect+cli@0.61.3_@effect+platform@0.82.3_effect@3.15.2__@effect+printer-ansi@0.43.2_@effect_c3kxzfnife426alr2ajuhgbxrm/node_modules/@effect/cli/dist/esm/CliConfig.js
var layer13 = layer;

// src/Utils.ts
var camelize = (self) => {
  let str = "";
  let hadSymbol = false;
  for (let i = 0; i < self.length; i++) {
    const charCode = self.charCodeAt(i);
    if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122) {
      str += hadSymbol ? self[i].toUpperCase() : self[i];
      hadSymbol = false;
    } else if (charCode >= 48 && charCode <= 57) {
      if (str.length > 0) {
        str += self[i];
        hadSymbol = true;
      }
    } else if (str.length > 0) {
      hadSymbol = true;
    }
  }
  return str;
};
var identifier2 = (operationId) => capitalize(camelize(operationId));
var nonEmptyString3 = flow(
  fromNullable,
  filter(isString2),
  map2(trim),
  filter(isNonEmpty5)
);
var toComment = match2({
  onNone: () => "",
  onSome: (description) => `/**
* ${description.replace(/\*\//g, " * /").split("\n").join("\n* ")}
*/
`
});

// src/JsonSchemaGen.ts
var make64 = gen2(function* () {
  const store = /* @__PURE__ */ new Map();
  const classes = /* @__PURE__ */ new Set();
  const enums = /* @__PURE__ */ new Set();
  const refStore = /* @__PURE__ */ new Map();
  const dependencies = /* @__PURE__ */ new Map();
  const aliasMap = /* @__PURE__ */ new Map();
  const schemaCache = /* @__PURE__ */ new Map();
  const structuralOmitKeys2 = /* @__PURE__ */ new Set([
    "description",
    "title",
    "summary",
    "externalDocs",
    "examples",
    "example"
  ]);
  const canonicalize = (value5) => {
    if (Array.isArray(value5)) {
      return value5.map(canonicalize);
    }
    if (value5 && typeof value5 === "object") {
      const entries2 = Object.entries(value5).filter(
        ([key, v]) => v !== void 0 && !structuralOmitKeys2.has(key) && !key.startsWith("x-")
      ).map(([key, v]) => [key, canonicalize(v)]).sort(([a], [b]) => a.localeCompare(b));
      const out2 = {};
      for (const [key, v] of entries2) {
        out2[key] = v;
      }
      return out2;
    }
    return value5;
  };
  const schemaCacheKey = (schema, asStruct) => JSON.stringify({
    asStruct,
    schema: canonicalize(schema)
  });
  function cleanupSchema(schema) {
    if ("type" in schema && Array.isArray(schema.type) && schema.type.includes("null")) {
      const type2 = schema.type.filter((_) => _ !== "null");
      schema = {
        ...schema,
        type: type2.length === 1 ? type2[0] : type2,
        nullable: true
      };
    }
    if ("type" in schema && "oneOf" in schema && Array.isArray(schema.oneOf) && schema.oneOf.length === 0) {
      schema = omit3(schema, "oneOf");
    }
    if ("enum" in schema && Array.isArray(schema.enum)) {
      const values3 = Array.from(new Set(schema.enum));
      values3.sort();
      if (values3.length === 1) {
        schema = {
          ...schema,
          const: values3[0]
        };
        schema = omit3(schema, "enum");
      } else if (schema.enum.length !== values3.length || schema.enum.some((value5, index) => value5 !== values3[index])) {
        schema = {
          ...schema,
          enum: values3
        };
      }
    }
    if ("allOf" in schema && schema.allOf.length === 1 || "oneOf" in schema && schema.oneOf.length === 1 || "anyOf" in schema && schema.anyOf.length === 1) {
      if ("allOf" in schema) {
        const item = schema.allOf[0];
        schema = omit3(schema, "allOf");
        Object.assign(schema, item);
      } else if ("anyOf" in schema) {
        const item = schema.anyOf[0];
        schema = omit3(schema, "anyOf");
        Object.assign(schema, item);
      } else {
        const item = schema.oneOf[0];
        schema = omit3(schema, "oneOf");
        Object.assign(schema, item);
      }
    }
    return schema;
  }
  const processingRefs = /* @__PURE__ */ new Set();
  const processedRefs = /* @__PURE__ */ new Set();
  const addSchema = (name2, root2, context7, asStruct = false) => {
    root2 = cleanupSchema(root2);
    const cacheKey = schemaCacheKey(root2, asStruct);
    const cachedName = schemaCache.get(cacheKey);
    if (cachedName) {
      if (cachedName !== name2) {
        aliasMap.set(name2, cachedName);
      }
      return cachedName;
    }
    function addRefs(schema, childName, asStruct2 = true) {
      schema = cleanupSchema(schema);
      const enumSuffix = childName?.endsWith("Enum") ? "" : "Enum";
      if ("$ref" in schema) {
        if (processingRefs.has(schema.$ref)) {
          return;
        }
        processingRefs.add(schema.$ref);
        const resolved = resolveRef(
          schema,
          {
            ...root2,
            ...context7
          },
          false,
          aliasMap
        );
        if (!resolved) {
          processingRefs.delete(schema.$ref);
          return;
        }
        refStore.set(schema.$ref, resolved.schema);
        let inserted = false;
        if (!store.has(resolved.name)) {
          store.set(resolved.name, resolved.schema);
          inserted = true;
        }
        if (!processedRefs.has(resolved.name) || inserted) {
          processedRefs.add(resolved.name);
          addRefs(resolved.schema, resolved.name);
        }
        classes.add(resolved.name);
        processingRefs.delete(schema.$ref);
      }
      if ("properties" in schema) {
        Object.entries(schema.properties).forEach(
          ([name3, s]) => addRefs(s, childName ? childName + identifier2(name3) : void 0)
        );
      }
      if ("type" in schema && schema.type === "array") {
        if (Array.isArray(schema.items)) {
          schema.items.forEach((s) => addRefs(s, void 0));
        } else if (schema.items) {
          addRefs(schema.items, void 0);
        }
        return;
      }
      if ("allOf" in schema) {
        const resolved = resolveAllOf(
          schema,
          {
            ...root2,
            ...context7
          },
          true,
          aliasMap
        );
        if (childName !== void 0) {
          addRefs(resolved, childName + enumSuffix, asStruct2);
          store.set(childName, resolved);
        } else {
          addRefs(resolved, void 0, asStruct2);
        }
        return;
      }
      if ("anyOf" in schema) {
        schema.anyOf.forEach(
          (s) => addRefs(s, childName ? childName + enumSuffix : void 0)
        );
        return;
      }
      if ("oneOf" in schema) {
        schema.oneOf.forEach((s) => {
          const nextChild = childName ? childName + enumSuffix : void 0;
          addRefs(s, nextChild);
        });
        return;
      }
      if ("enum" in schema) {
        if (childName !== void 0 && !("const" in schema)) {
          store.set(childName, schema);
          enums.add(childName);
        }
      }
    }
    if ("$ref" in root2) {
      addRefs(root2, void 0, false);
      const target = identifier2(root2.$ref.split("/").pop());
      if (target !== name2) {
        aliasMap.set(name2, target);
      }
      schemaCache.set(cacheKey, target);
      return target;
    } else {
      addRefs(root2, "properties" in root2 ? name2 : void 0);
      store.set(name2, root2);
      if (!asStruct && !("oneOf" in root2 || "anyOf" in root2)) {
        classes.add(name2);
      }
    }
    schemaCache.set(cacheKey, name2);
    return name2;
  };
  const topLevelSource = (importName, name2, schema) => {
    const isClass = classes.has(name2);
    const isEnum = enums.has(name2);
    const topLevel = transformer.supportsTopLevel({
      importName,
      schema,
      name: name2,
      isClass,
      isEnum
    });
    const dependencySet = /* @__PURE__ */ new Set();
    const normalizedSchema = Object.keys(schema).length ? schema : { properties: {} };
    const source = toSource(
      importName,
      normalizedSchema,
      name2,
      topLevel,
      name2,
      dependencySet
    );
    dependencySet.delete(name2);
    dependencies.set(name2, dependencySet);
    return source.pipe(
      map2(
        (result) => transformer.onTopLevel({
          importName,
          schema,
          description: nonEmptyString3(schema.description),
          name: name2,
          source: result,
          isClass,
          isEnum
        })
      )
    );
  };
  const getSchema = (raw) => {
    if ("$ref" in raw) {
      return refStore.get(raw.$ref) ?? raw;
    }
    return cleanupSchema(raw);
  };
  const flattenAllOf = (schema) => {
    if ("allOf" in schema) {
      let out2 = {};
      for (const member of schema.allOf) {
        let s = getSchema(member);
        if ("allOf" in s) {
          s = flattenAllOf(s);
        }
        out2 = mergeSchemas(out2, s);
      }
      return out2;
    }
    return getSchema(schema);
  };
  const transformer = yield* JsonSchemaTransformer;
  const toSource = (importName, schema, currentIdentifier, topLevel = false, rootIdentifier = currentIdentifier, currentDependencies) => {
    const recordDependency = (name2) => {
      if (!currentDependencies || name2 === rootIdentifier) {
        return;
      }
      currentDependencies.add(name2);
    };
    schema = cleanupSchema(schema);
    if ("anyOf" in schema || "oneOf" in schema) {
      let itemSchemas = "anyOf" in schema ? schema.anyOf : schema.oneOf;
      let typePrimitives = 0;
      const constItems = empty2();
      for (const item of itemSchemas) {
        if ("type" in item && item.type !== "null") {
          typePrimitives++;
        } else if ("const" in item) {
          constItems.push(item);
        }
      }
      if (typePrimitives <= 1 && constItems.length > 0 && constItems.length + typePrimitives === itemSchemas.length) {
        itemSchemas = constItems;
      }
      const items = pipe(
        itemSchemas,
        filterMap2(
          (_) => toSource(
            importName,
            _,
            currentIdentifier + "Enum",
            false,
            rootIdentifier,
            currentDependencies
          ).pipe(
            map2(
              (source) => ({
                description: nonEmptyString3(_.description),
                title: nonEmptyString3(_.title),
                source
              })
            )
          )
        )
      );
      if (items.length === 0) {
        return none2();
      } else if (items.length === 1) {
        return some2(items[0].source);
      }
      return some2(transformer.onUnion({ importName, items, topLevel }));
    } else if ("properties" in schema) {
      const obj = schema;
      const required2 = obj.required ?? [];
      const properties = pipe(
        Object.entries(obj.properties ?? {}),
        filterMap2(([key, schema2]) => {
          const fullSchema = getSchema(schema2);
          schema2 = cleanupSchema(schema2);
          const isOptional = !required2.includes(key);
          const [enumNullable, filteredSchema] = filterNullable(fullSchema);
          return toSource(
            importName,
            enumNullable ? filteredSchema : schema2,
            currentIdentifier + identifier2(key),
            false,
            rootIdentifier,
            currentDependencies
          ).pipe(
            map2(
              (source) => transformer.onProperty({
                importName,
                description: nonEmptyString3(schema2.description),
                key,
                source,
                isOptional,
                isNullable: enumNullable || "nullable" in fullSchema && fullSchema.nullable === true || "default" in fullSchema && fullSchema.default === null,
                default: fullSchema.default
              })
            )
          );
        }),
        join(transformer.propertySeparator)
      );
      return some2(
        transformer.onObject({ importName, properties, topLevel })
      );
    } else if ("type" in schema && schema.type === "null") {
      return some2(transformer.onNull({ importName }));
    } else if ("type" in schema && schema.type === "object") {
      return some2(transformer.onRecord({ importName }));
    } else if ("const" in schema) {
      return some2(
        transformer.onEnum({
          importName,
          items: [JSON.stringify(schema.const)]
        })
      );
    } else if ("enum" in schema) {
      if (!topLevel && enums.has(currentIdentifier)) {
        recordDependency(currentIdentifier);
        return some2(
          transformer.onRef({ importName, name: currentIdentifier })
        );
      } else if (!topLevel && enums.has(currentIdentifier + "Enum")) {
        recordDependency(currentIdentifier + "Enum");
        return some2(
          transformer.onRef({ importName, name: currentIdentifier + "Enum" })
        );
      }
      const items = schema.enum.map((_) => JSON.stringify(_));
      return some2(
        transformer.onEnum({
          importName,
          items
        })
      );
    } else if ("$ref" in schema) {
      if (!schema.$ref.startsWith("#")) {
        return none2();
      }
      let name2 = identifier2(schema.$ref.split("/").pop());
      const canonical = aliasMap.get(name2);
      if (canonical) {
        name2 = canonical;
      }
      recordDependency(name2);
      return some2(transformer.onRef({ importName, name: name2 }));
    } else if ("properties" in schema) {
      return toSource(
        importName,
        { type: "object", ...schema },
        currentIdentifier,
        topLevel,
        rootIdentifier,
        currentDependencies
      );
    } else if ("allOf" in schema) {
      if (store.has(currentIdentifier)) {
        recordDependency(currentIdentifier);
        return some2(
          transformer.onRef({ importName, name: currentIdentifier })
        );
      }
      const sources = schema.allOf;
      if (sources.length === 0) {
        return none2();
      }
      const flattened2 = flattenAllOf(schema);
      return toSource(
        importName,
        flattened2,
        currentIdentifier + "Enum",
        topLevel,
        rootIdentifier,
        currentDependencies
      );
    } else if ("type" in schema && schema.type) {
      switch (schema.type) {
        case "string": {
          return some2(transformer.onString({ importName, schema }));
        }
        case "integer":
        case "number": {
          const minimum = typeof schema.exclusiveMinimum === "number" ? schema.exclusiveMinimum : schema.minimum;
          const exclusiveMinimum = typeof schema.exclusiveMinimum === "boolean" ? schema.exclusiveMinimum : typeof schema.exclusiveMinimum === "number";
          const maximum = typeof schema.exclusiveMaximum === "number" ? schema.exclusiveMaximum : schema.maximum;
          const exclusiveMaximum = typeof schema.exclusiveMaximum === "boolean" ? schema.exclusiveMaximum : typeof schema.exclusiveMaximum === "number";
          return some2(
            transformer.onNumber({
              importName,
              schema,
              minimum,
              exclusiveMinimum,
              maximum,
              exclusiveMaximum
            })
          );
        }
        case "boolean": {
          return some2(transformer.onBoolean({ importName }));
        }
        case "array": {
          const nonEmpty = typeof schema.minItems === "number" && schema.minItems > 0;
          return toSource(
            importName,
            itemsSchema(schema.items),
            currentIdentifier,
            false,
            rootIdentifier,
            currentDependencies
          ).pipe(
            map2(
              (item) => transformer.onArray({
                importName,
                schema,
                item,
                nonEmpty
              })
            )
          );
        }
      }
    }
    return none2();
  };
  const itemsSchema = (schema) => {
    if (schema === void 0) {
      return { $id: "/schemas/any" };
    } else if (Array.isArray(schema)) {
      return { anyOf: schema };
    }
    return schema;
  };
  const addAlias = (alias, target) => {
    if (alias !== target) {
      aliasMap.set(alias, target);
    }
  };
  const generate = (importName, options3) => sync5(() => {
    transformer.resetHoists?.();
    const storeEntries = Array.from(store.entries());
    const missingTopLevel = [];
    const sources = [];
    for (const [name2, schema] of storeEntries) {
      const maybeSource = topLevelSource(importName, name2, schema);
      match2(maybeSource, {
        onNone: () => {
          missingTopLevel.push(name2);
        },
        onSome: (source) => {
          sources.push({ name: name2, source });
        }
      });
    }
    if (sources.length === 0) {
      return "";
    }
    const topLevelNames = new Set(sources.map((_) => _.name));
    const graph = /* @__PURE__ */ new Map();
    const dependents = /* @__PURE__ */ new Map();
    const missingDependencies = [];
    for (const { name: name2 } of sources) {
      const deps = dependencies.get(name2);
      if (deps) {
        const filtered = /* @__PURE__ */ new Set();
        const missing = [];
        for (const dep of deps) {
          if (topLevelNames.has(dep)) {
            filtered.add(dep);
            const list4 = dependents.get(dep);
            if (list4) {
              list4.add(name2);
            } else {
              dependents.set(dep, /* @__PURE__ */ new Set([name2]));
            }
          } else if (store.has(dep)) {
            missing.push(dep);
          }
        }
        if (missing.length > 0) {
          missingDependencies.push({ name: name2, missing });
        }
        graph.set(name2, filtered);
      } else {
        graph.set(name2, /* @__PURE__ */ new Set());
      }
    }
    const indegree = /* @__PURE__ */ new Map();
    for (const { name: name2 } of sources) {
      indegree.set(name2, graph.get(name2)?.size ?? 0);
    }
    const insertionOrder = sources.map((_) => _.name);
    const queue = [];
    const enqueued = /* @__PURE__ */ new Set();
    for (const name2 of insertionOrder) {
      if ((indegree.get(name2) ?? 0) === 0) {
        queue.push(name2);
        enqueued.add(name2);
      }
    }
    const ordered = [];
    for (let index = 0; index < queue.length; index++) {
      const name2 = queue[index];
      ordered.push(name2);
      const nextNodes = dependents.get(name2);
      if (!nextNodes) {
        continue;
      }
      for (const dependent of nextNodes) {
        const next = (indegree.get(dependent) ?? 0) - 1;
        indegree.set(dependent, next);
        if (next === 0 && !enqueued.has(dependent)) {
          queue.push(dependent);
          enqueued.add(dependent);
        }
      }
    }
    const hasCycle = ordered.length !== topLevelNames.size;
    const finalOrder = hasCycle ? insertionOrder : ordered;
    const sourceMap = new Map(
      sources.map((_) => [_.name, _.source])
    );
    const warningBlocks = [];
    if (missingDependencies.length > 0) {
      const details = missingDependencies.map(
        ({ name: name2, missing }) => `${name2} -> ${missing.join(", ")}`
      ).join("; ");
      warningBlocks.push(
        `/* JsonSchemaGen warning: missing definitions for ${details}. */`
      );
    }
    if (hasCycle) {
      const cyclic = computeStronglyConnectedComponents(graph).filter(
        (component) => component.length > 1 || component.length === 1 && graph.get(component[0])?.has(component[0])
      );
      if (cyclic.length > 0) {
        warningBlocks.push(
          `/* JsonSchemaGen warning: circular dependencies detected among ${cyclic.map((component) => component.join(", ")).join(" | ")}. Original emission order preserved. */`
        );
      }
    }
    if (missingTopLevel.length > 0) {
      warningBlocks.push(
        `/* JsonSchemaGen warning: unsupported top-level schemas (${missingTopLevel.join(", ")}). */`
      );
    }
    const orderedSources = finalOrder.map((name2) => ({
      name: name2,
      source: sourceMap.get(name2)
    }));
    const joinedBody = orderedSources.map((_) => _.source).join("\n\n");
    const hoistPrefix = options3?.hoistReferencePrefix ?? "";
    const hoistResult = transformer.finalizeHoists ? transformer.finalizeHoists({
      referencePrefix: hoistPrefix,
      source: joinedBody
    }) : {
      hoists: [],
      replacements: /* @__PURE__ */ new Map()};
    const applyReplacements = (value5) => {
      let result = value5;
      for (const [placeholder, replacement] of hoistResult.replacements) {
        result = result.split(placeholder).join(replacement);
      }
      return result;
    };
    const resolvedSources = orderedSources.map(({ name: name2, source }) => ({
      name: name2,
      source: applyReplacements(source),
      dependencies: Array.from(dependencies.get(name2) ?? [])
    }));
    const aliasEntries = Array.from(aliasMap.entries()).filter(
      ([alias, target]) => alias !== target
    );
    aliasEntries.sort(([aAlias], [bAlias]) => aAlias.localeCompare(bAlias));
    return {
      aliases: aliasEntries.map(([alias, target]) => ({ alias, target })),
      hoists: hoistResult.hoists,
      sources: resolvedSources,
      warnings: warningBlocks.slice(0)
    };
  });
  return { addSchema, addAlias, generate };
});
var JsonSchemaGen = class extends Tag2("JsonSchemaGen")() {
};
var with_ = provideServiceEffect2(JsonSchemaGen, make64);
var JsonSchemaTransformer = class extends Tag2("JsonSchemaTransformer")() {
};
var layerTransformerSchema = sync6(JsonSchemaTransformer, () => {
  let hoistCounter = 0;
  const hoistEntries = [];
  const hoistMap = /* @__PURE__ */ new Map();
  const isSimpleIdentifier = (value5) => /^[A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)*$/.test(value5);
  const resetHoists = () => {
    hoistEntries.length = 0;
    hoistMap.clear();
    hoistCounter = 0;
  };
  const shouldHoist = (hint) => {
    switch (hint.kind) {
      case "optionalWith": {
        return isSimpleIdentifier(hint.baseSource) && hint.baseSource.includes(".");
      }
    }
    return false;
  };
  const registerHoist = (expression, hint) => {
    if (!shouldHoist(hint)) {
      return expression;
    }
    let entry = hoistMap.get(expression);
    if (!entry) {
      entry = {
        expression,
        hint,
        placeholder: `__JSON_SCHEMA_HOIST_${hoistCounter++}__`,
        count: 0
      };
      hoistMap.set(expression, entry);
      hoistEntries.push(entry);
    }
    entry.count++;
    return entry.placeholder;
  };
  const toPascalCase = (input) => {
    const words3 = input.replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/[^A-Za-z0-9]+/g, " ").trim().split(/\s+/).filter((_) => _.length > 0).map((word) => word[0].toUpperCase() + word.slice(1));
    return words3.join("");
  };
  const normalizeDefaultValue = (value5) => {
    const trimmed = value5.trim();
    if (trimmed.startsWith("-")) {
      return `Minus ${trimmed.slice(1)}`;
    }
    if (trimmed.startsWith("+")) {
      return `Plus ${trimmed.slice(1)}`;
    }
    if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
      return trimmed.slice(1, -1);
    }
    return trimmed;
  };
  const buildDefaultSuffix = (defaultSource) => {
    if (!defaultSource) {
      return "";
    }
    const match17 = defaultSource.match(/^\(\)\s*=>\s*(.+)\s+as const$/);
    const value5 = normalizeDefaultValue(match17 ? match17[1] ?? "" : defaultSource);
    const normalized = toPascalCase(value5);
    return normalized.length > 0 ? `WithDefault${normalized}` : "WithDefault";
  };
  const makeHoistName = (entry) => {
    switch (entry.hint.kind) {
      case "optionalWith": {
        const baseSegment = entry.hint.baseSource.split(".").pop() ?? entry.hint.baseSource;
        const normalizedBase = toPascalCase(baseSegment);
        const suffix = buildDefaultSuffix(entry.hint.defaultSource);
        const base = normalizedBase.length > 0 ? normalizedBase : "Value";
        return `optionalNullable${base}${suffix}`;
      }
    }
  };
  const resolveHoists = (source, referencePrefix) => {
    if (hoistEntries.length === 0) {
      return {
        hoists: [],
        replacements: /* @__PURE__ */ new Map(),
        source
      };
    }
    const replacements = /* @__PURE__ */ new Map();
    const hoists = [];
    const usedNames = /* @__PURE__ */ new Set();
    for (const entry of hoistEntries) {
      if (entry.count <= 1) {
        replacements.set(entry.placeholder, entry.expression);
        continue;
      }
      let name2 = makeHoistName(entry);
      if (!name2 || name2.length === 0) {
        name2 = `hoistedExpression${declarations.length + 1}`;
      }
      let uniqueName = name2;
      let index = 1;
      while (usedNames.has(uniqueName)) {
        uniqueName = `${name2}${++index}`;
      }
      usedNames.add(uniqueName);
      hoists.push({
        name: uniqueName,
        expression: entry.expression
      });
      const reference = referencePrefix.length > 0 ? `${referencePrefix}${uniqueName}` : uniqueName;
      replacements.set(entry.placeholder, reference);
    }
    let resolved = source;
    for (const [placeholder, replacement] of replacements) {
      resolved = resolved.split(placeholder).join(replacement);
    }
    resetHoists();
    return {
      hoists,
      replacements,
      source: resolved
    };
  };
  const hoistOptional = (expression, baseSource, defaultSource) => registerHoist(expression, {
    kind: "optionalWith",
    baseSource,
    defaultSource
  });
  const applyAnnotations = (S, options3) => (source) => {
    if (options3.isNullable && options3.default === null) {
      return `${S}.optionalWith(${S}.NullOr(${source}), { default: () => null })`;
    }
    const defaultSource = options3.default !== void 0 && options3.default !== null ? `() => ${JSON.stringify(options3.default)} as const` : void 0;
    if (options3.isOptional) {
      const expression = defaultSource !== void 0 ? `${S}.optionalWith(${source}, { nullable: true, default: ${defaultSource} })` : `${S}.optionalWith(${source}, { nullable: true })`;
      return hoistOptional(expression, source, defaultSource);
    }
    const newSource = options3.isNullable ? `${S}.NullOr(${source})` : source;
    if (defaultSource) {
      return `${newSource}.pipe(${S}.propertySignature, ${S}.withConstructorDefault(${defaultSource}))`;
    }
    return newSource;
  };
  const pipeSource = (modifers) => modifers.length === 0 ? "" : `.pipe(${modifers.join(", ")})`;
  return JsonSchemaTransformer.of({
    supportsTopLevel({ isClass, isEnum }) {
      return isClass || isEnum;
    },
    onTopLevel({ importName, schema, name: name2, source, isClass, description }) {
      const hasUnion = "oneOf" in schema || "anyOf" in schema;
      const isObject2 = "properties" in schema && Object.keys(schema.properties ?? {}).length > 0;
      if (hasUnion) {
        return `${toComment(description)}export class ${name2} extends ${source} {}`;
      }
      if (!isObject2 || !isClass) {
        return `${toComment(description)}export class ${name2} extends ${source} {}`;
      }
      return `${toComment(description)}export class ${name2} extends ${importName}.Class<${name2}>("${name2}")(${source}) {}`;
    },
    propertySeparator: ",\n  ",
    onProperty: (options3) => {
      const source = applyAnnotations(
        options3.importName,
        options3
      )(options3.source);
      return `${toComment(options3.description)}"${options3.key}": ${source}`;
    },
    onRef({ name: name2 }) {
      return name2;
    },
    onObject({ importName, properties, topLevel }) {
      return `${topLevel ? "" : `${importName}.Struct(`}{
  ${properties}
}${topLevel ? "" : ")"}`;
    },
    onNull({ importName }) {
      return `${importName}.Null`;
    },
    onBoolean({ importName }) {
      return `${importName}.Boolean`;
    },
    onRecord({ importName }) {
      return `${importName}.Record({ key: ${importName}.String, value: ${importName}.Unknown })`;
    },
    onEnum({ importName, items }) {
      return `${importName}.Literal(${items.join(", ")})`;
    },
    onString({ importName, schema }) {
      if (schema.format === "binary" || schema.contentEncoding === "binary") {
        return `${importName}.instanceOf(globalThis.Blob)`;
      }
      const modifiers = [];
      if ("minLength" in schema) {
        modifiers.push(`${importName}.minLength(${schema.minLength})`);
      }
      if ("maxLength" in schema) {
        modifiers.push(`${importName}.maxLength(${schema.maxLength})`);
      }
      if ("pattern" in schema) {
        modifiers.push(
          `${importName}.pattern(new RegExp(${JSON.stringify(schema.pattern)}))`
        );
      }
      return `${importName}.String${pipeSource(modifiers)}`;
    },
    onNumber({
      importName,
      schema,
      minimum,
      exclusiveMinimum,
      maximum,
      exclusiveMaximum
    }) {
      const modifiers = [];
      if (minimum !== void 0) {
        modifiers.push(
          `${importName}.greaterThan${exclusiveMinimum ? "" : "OrEqualTo"}(${minimum})`
        );
      }
      if (maximum !== void 0) {
        modifiers.push(
          `${importName}.lessThan${exclusiveMaximum ? "" : "OrEqualTo"}(${maximum})`
        );
      }
      return `${importName}.${schema.type === "integer" ? "Int" : "Number"}${pipeSource(modifiers)}`;
    },
    onArray({ importName, schema, item, nonEmpty }) {
      const modifiers = [];
      if ("minItems" in schema && nonEmpty) {
        modifiers.push(`${importName}.minItems(${schema.minItems})`);
      }
      if ("maxItems" in schema) {
        modifiers.push(`${importName}.maxItems(${schema.maxItems})`);
      }
      return `${importName}.${nonEmpty ? "NonEmpty" : ""}Array(${item})${pipeSource(modifiers)}`;
    },
    onUnion({ importName, items }) {
      return `${importName}.Union(${items.map((_) => `${toComment(_.description)}${_.source}`).join(",\n")})`;
    },
    resetHoists,
    finalizeHoists({ source, referencePrefix }) {
      return resolveHoists(source, referencePrefix);
    }
  });
});
var layerTransformerTs = succeed10(
  JsonSchemaTransformer,
  JsonSchemaTransformer.of({
    supportsTopLevel() {
      return true;
    },
    onTopLevel({ name: name2, source, schema, description }) {
      return source[0] === "{" ? "oneOf" in schema ? `${toComment(description)}export const ${name2} = ${source};
export type ${name2} = (typeof ${name2})[keyof typeof ${name2}];` : `${toComment(description)}export interface ${name2} ${source}` : `${toComment(description)}export type ${name2} = ${source}`;
    },
    propertySeparator: ";\n  ",
    onProperty(options3) {
      return `${toComment(options3.description)}readonly "${options3.key}"${options3.isOptional ? "?" : ""}: ${options3.source}${options3.isNullable ? " | null" : ""}${options3.isOptional ? " | undefined" : ""}`;
    },
    onRef({ name: name2 }) {
      return name2;
    },
    onObject({ properties }) {
      return `{
  ${properties}
}`;
    },
    onNull() {
      return "null";
    },
    onBoolean() {
      return "boolean";
    },
    onRecord() {
      return "Record<string, unknown>";
    },
    onEnum({ items }) {
      return items.join(" | ");
    },
    onString({ schema }) {
      if (schema.format === "binary" || schema.contentEncoding === "binary") {
        return `Blob`;
      }
      return "string";
    },
    onNumber() {
      return "number";
    },
    onArray({ item }) {
      return `ReadonlyArray<${item}>`;
    },
    onUnion({ items, topLevel }) {
      const useEnum = topLevel && !items.some((_) => isNone2(_.title));
      if (!useEnum) {
        return items.map((_) => _.source).join(" | ");
      }
      return `{
  ${items.map(({ description, title, source }) => `${toComment(description)}${JSON.stringify(getOrNull(title))}: ${source}`).join(",\n  ")}} as const
`;
    },
    resetHoists() {
    },
    finalizeHoists({ source }) {
      return {
        hoists: [],
        replacements: /* @__PURE__ */ new Map(),
        source
      };
    }
  })
);
function mergeSchemas(self, other) {
  if ("properties" in self && "properties" in other) {
    return {
      ...other,
      ...self,
      properties: {
        ...other.properties,
        ...self.properties
      },
      required: [...other.required || [], ...self.required || []]
    };
  } else if ("anyOf" in self && "anyOf" in other) {
    return {
      ...other,
      ...self,
      anyOf: [...self.anyOf, ...other.anyOf]
    };
  }
  return {
    ...self,
    ...other
  };
}
function resolveAllOf(schema, context7, resolveRefs = true, aliasMap) {
  if ("$ref" in schema) {
    const resolved = resolveRef(schema, context7, resolveRefs, aliasMap);
    if (!resolved) {
      return schema;
    }
    return resolved.schema;
  } else if ("allOf" in schema) {
    if (schema.allOf.length <= 1) {
      let out3 = { ...schema };
      delete out3.allOf;
      if (schema.allOf.length === 0) {
        return out3;
      }
      Object.assign(out3, schema.allOf[0]);
      return resolveAllOf(out3, context7, resolveRefs, aliasMap);
    }
    let out2 = {};
    for (const member of schema.allOf) {
      out2 = mergeSchemas(
        out2,
        resolveAllOf(member, context7, resolveRefs, aliasMap)
      );
    }
    return out2;
  }
  return schema;
}
function resolveRef(schema, context7, recursive = false, aliasMap) {
  if (!schema.$ref.startsWith("#")) {
    return;
  }
  const visited = /* @__PURE__ */ new Set();
  let ref = schema.$ref;
  let current = context7;
  let name2 = "";
  while (true) {
    const path2 = ref.slice(2).split("/");
    name2 = identifier2(path2[path2.length - 1]);
    current = context7;
    for (const key of path2) {
      if (!current) {
        return;
      }
      current = current[key];
    }
    if (!current || typeof current !== "object") {
      return;
    }
    if (!("$ref" in current)) {
      return {
        name: name2,
        schema: resolveAllOf(
          current,
          context7,
          recursive,
          aliasMap
        )
      };
    }
    const nextRef = current.$ref;
    if (typeof nextRef !== "string" || !nextRef.startsWith("#")) {
      return;
    }
    const targetName = identifier2(nextRef.split("/").pop());
    if (targetName !== name2 && aliasMap) {
      aliasMap.set(name2, targetName);
    }
    if (visited.has(nextRef)) {
      return {
        name: targetName,
        schema: resolveAllOf(
          current,
          context7,
          recursive,
          aliasMap
        )
      };
    }
    visited.add(nextRef);
    ref = nextRef;
  }
}
function filterNullable(schema) {
  if ("oneOf" in schema || "anyOf" in schema) {
    const items = schema.oneOf ?? schema.anyOf;
    const prop = "oneOf" in schema ? "oneOf" : "anyOf";
    let isNullable2 = false;
    let otherItems = empty2();
    for (const item of items) {
      if ("type" in item && item.type === "null") {
        isNullable2 = true;
      } else if ("const" in item && item.const === null) {
        isNullable2 = true;
      } else {
        otherItems.push(item);
      }
    }
    return [
      isNullable2,
      { ...schema, [prop]: otherItems }
    ];
  }
  return [false, schema];
}
function computeStronglyConnectedComponents(graph) {
  let index = 0;
  const indices = /* @__PURE__ */ new Map();
  const lowlinks = /* @__PURE__ */ new Map();
  const stack = [];
  const onStack = /* @__PURE__ */ new Set();
  const components = [];
  const strongConnect = (node) => {
    indices.set(node, index);
    lowlinks.set(node, index);
    index++;
    stack.push(node);
    onStack.add(node);
    for (const dep of graph.get(node) ?? /* @__PURE__ */ new Set()) {
      if (!indices.has(dep)) {
        strongConnect(dep);
        lowlinks.set(
          node,
          Math.min(
            lowlinks.get(node),
            lowlinks.get(dep)
          )
        );
      } else if (onStack.has(dep)) {
        lowlinks.set(
          node,
          Math.min(
            lowlinks.get(node),
            indices.get(dep)
          )
        );
      }
    }
    if (lowlinks.get(node) === indices.get(node)) {
      const component = [];
      while (true) {
        const item = stack.pop();
        onStack.delete(item);
        component.push(item);
        if (item === node) {
          break;
        }
      }
      components.push(component);
    }
  };
  for (const node of graph.keys()) {
    if (!indices.has(node)) {
      strongConnect(node);
    }
  }
  return components;
}

// src/OpenApi.ts
var import_swagger2openapi = __toESM(require_swagger2openapi());
var methodNames = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch",
  "trace"
];
var httpClientMethodNames = {
  get: "get",
  put: "put",
  post: "post",
  delete: "del",
  options: "options",
  head: "head",
  patch: "patch",
  trace: `make("TRACE")`
};
var structuralOmitKeys = /* @__PURE__ */ new Set([
  "description",
  "title",
  "summary",
  "externalDocs",
  "examples",
  "example"
]);
var canonicalizeSchema = (value5) => {
  if (Array.isArray(value5)) {
    return value5.map(canonicalizeSchema);
  }
  if (value5 && typeof value5 === "object") {
    const entries2 = Object.entries(value5).filter(
      ([key, v]) => v !== void 0 && !structuralOmitKeys.has(key) && !key.startsWith("x-")
    ).map(([key, v]) => [key, canonicalizeSchema(v)]).sort(([a], [b]) => a.localeCompare(b));
    const out2 = {};
    for (const [key, v] of entries2) {
      out2[key] = v;
    }
    return out2;
  }
  return value5;
};
var schemaHash = (schema) => JSON.stringify(canonicalizeSchema(schema));
var dedupeComponentSchemas = (schemas) => {
  const seen = /* @__PURE__ */ new Map();
  for (const [name2, schema] of Object.entries(schemas)) {
    if (!schema || typeof schema !== "object" || "$ref" in schema) {
      continue;
    }
    if (!(name2.endsWith("Attributes") || name2.endsWith("Relationships"))) {
      continue;
    }
    const key = schemaHash(schema);
    const canonical = seen.get(key);
    if (canonical && canonical !== name2) {
      schemas[name2] = { $ref: `#/components/schemas/${canonical}` };
    } else {
      seen.set(key, name2);
    }
  }
};
var make65 = gen2(function* () {
  const isV2 = (spec2) => "swagger" in spec2;
  const convert2 = fn("OpenApi.convert")(
    (v2Spec) => async2((resume2) => {
      (0, import_swagger2openapi.convertObj)(
        v2Spec,
        { laxDefaults: true, laxurls: true, patch: true, warnOnly: true },
        (err, result) => {
          if (err) {
            resume2(die5(err));
          } else {
            resume2(succeed8(result.openapi));
          }
        }
      );
    })
  );
  const generate = fnUntraced2(
    function* (spec2, options3) {
      if (isV2(spec2)) {
        spec2 = yield* convert2(spec2);
      }
      if (spec2.components?.schemas) {
        dedupeComponentSchemas(
          spec2.components.schemas
        );
      }
      const gen3 = yield* JsonSchemaGen;
      const components = spec2.components ? { ...spec2.components } : { schemas: {} };
      const context7 = { components };
      const operations = [];
      function resolveRef2(ref) {
        const parts2 = ref.split("/").slice(1);
        let current = spec2;
        for (const part of parts2) {
          current = current[part];
        }
        return current;
      }
      const handlePath = (path2, methods) => methodNames.filter((method) => !!methods[method]).forEach((method) => {
        const { ids: pathIds, path: pathTemplate } = processPath(path2);
        const operation = methods[method];
        const id2 = operation.operationId ? camelize(operation.operationId) : `${method.toUpperCase()}${path2}`;
        const op = {
          id: id2,
          method,
          description: nonEmptyString3(operation.description).pipe(
            orElse(() => nonEmptyString3(operation.summary))
          ),
          pathIds,
          pathTemplate,
          urlParams: [],
          headers: [],
          cookies: [],
          payloadFormData: false,
          successSchemas: /* @__PURE__ */ new Map(),
          errorSchemas: /* @__PURE__ */ new Map(),
          voidSchemas: /* @__PURE__ */ new Set(),
          paramsOptional: true
        };
        const schemaId = identifier2(operation.operationId ?? path2);
        const validParameters = operation.parameters?.filter(
          (_) => _.in !== "path" && _.in !== "cookie"
        ) ?? [];
        if (validParameters.length > 0) {
          const schema = {
            type: "object",
            properties: {},
            required: []
          };
          validParameters.forEach((parameter) => {
            if ("$ref" in parameter) {
              parameter = resolveRef2(parameter.$ref);
            }
            if (parameter.in === "path") {
              return;
            }
            const paramSchema = parameter.schema;
            const added = [];
            if ("properties" in paramSchema) {
              const required2 = paramSchema.required ?? [];
              Object.entries(paramSchema.properties).forEach(
                ([name2, propSchema]) => {
                  const adjustedName = `${parameter.name}[${name2}]`;
                  schema.properties[adjustedName] = propSchema;
                  if (required2.includes(name2)) {
                    schema.required.push(adjustedName);
                  }
                  added.push(adjustedName);
                }
              );
            } else {
              schema.properties[parameter.name] = parameter.schema;
              parameter.required && schema.required.push(parameter.name);
              added.push(parameter.name);
            }
            if (parameter.in === "query") {
              op.urlParams.push(...added);
            } else if (parameter.in === "header") {
              op.headers.push(...added);
            } else if (parameter.in === "cookie") {
              op.cookies.push(...added);
            }
          });
          op.params = gen3.addSchema(
            `${schemaId}Params`,
            schema,
            context7,
            true
          );
          op.paramsOptional = !schema.required || schema.required.length === 0;
        }
        if (operation.requestBody?.content?.["application/json"]?.schema) {
          op.payload = gen3.addSchema(
            `${schemaId}Request`,
            operation.requestBody.content["application/json"].schema,
            context7
          );
        } else if (operation.requestBody?.content?.["multipart/form-data"]) {
          op.payload = gen3.addSchema(
            `${schemaId}Request`,
            operation.requestBody.content["multipart/form-data"].schema,
            context7
          );
          op.payloadFormData = true;
        }
        let defaultSchema;
        Object.entries(operation.responses ?? {}).forEach(
          ([status2, response]) => {
            while ("$ref" in response) {
              response = resolveRef2(response.$ref);
            }
            if (response.content?.["application/json"]?.schema) {
              const schemaName = gen3.addSchema(
                `${schemaId}${status2}`,
                response.content["application/json"].schema,
                context7,
                true
              );
              if (status2 === "default") {
                defaultSchema = schemaName;
                return;
              }
              const statusLower = status2.toLowerCase();
              const statusMajorNumber = Number(status2[0]);
              if (isNaN(statusMajorNumber)) {
                return;
              } else if (statusMajorNumber < 4) {
                op.successSchemas.set(statusLower, schemaName);
              } else {
                op.errorSchemas.set(statusLower, schemaName);
              }
            }
            if (!response.content) {
              op.voidSchemas.add(status2.toLowerCase());
            }
          }
        );
        if (op.successSchemas.size === 0 && defaultSchema) {
          op.successSchemas.set("2xx", defaultSchema);
        }
        operations.push(op);
      });
      Object.entries(spec2.paths).forEach(
        ([path2, methods]) => handlePath(path2, methods)
      );
      const transformer = yield* OpenApiTransformer;
      const schemaModuleName = "Models";
      const primitivesModuleName = "Primitives";
      const schemas = yield* gen3.generate("S", {
        hoistReferencePrefix: `${primitivesModuleName}.`
      });
      const definitionList = schemas.sources.map(
        (definition, index) => ({
          ...definition,
          index
        })
      );
      const definitionByName = new Map(
        definitionList.map((definition) => [definition.name, definition])
      );
      const depthCache = /* @__PURE__ */ new Map();
      const computeDepth = (name2) => {
        const cached3 = depthCache.get(name2);
        if (cached3 !== void 0) {
          return cached3;
        }
        const definition = definitionByName.get(name2);
        if (!definition) {
          depthCache.set(name2, 0);
          return 0;
        }
        if (definition.dependencies.length === 0) {
          depthCache.set(name2, 0);
          return 0;
        }
        let depth = 0;
        for (const dep of definition.dependencies) {
          depth = Math.max(depth, computeDepth(dep) + 1);
        }
        depthCache.set(name2, depth);
        return depth;
      };
      const categoryConfig = {
        foundations: { filename: "foundations" },
        entities: { filename: "entities" },
        details: { filename: "details" },
        params: { filename: "params" },
        requests: { filename: "requests" },
        references: { filename: "references" },
        data: { filename: "data" }
      };
      const categorize = (name2) => {
        if (name2.endsWith("Params")) {
          return "params";
        }
        if (name2.endsWith("Request") || name2.endsWith("Requests")) {
          return "requests";
        }
        if (name2.endsWith("Response") || name2.endsWith("Responses")) {
          return "requests";
        }
        if (name2.startsWith("Referenced") || name2.startsWith("NullableReferenced")) {
          return "references";
        }
        if (name2.endsWith("Data")) {
          return "data";
        }
        const depth = computeDepth(name2);
        if (depth === 0) {
          return "foundations";
        }
        if (depth === 1) {
          return "entities";
        }
        return "details";
      };
      const filesByKey = /* @__PURE__ */ new Map();
      const definitionToFile = /* @__PURE__ */ new Map();
      const getOrCreateFile = (key, index) => {
        const config2 = categoryConfig[key] ?? categoryConfig.entities;
        const resolvedKey = categoryConfig[key] ? key : "entities";
        if (!filesByKey.has(resolvedKey)) {
          filesByKey.set(resolvedKey, {
            key: resolvedKey,
            filename: config2.filename,
            definitions: [],
            earliestIndex: index
          });
        }
        const file3 = filesByKey.get(resolvedKey);
        file3.earliestIndex = Math.min(file3.earliestIndex, index);
        return file3;
      };
      for (const definition of definitionList) {
        const desiredKey = categorize(definition.name);
        const file3 = getOrCreateFile(desiredKey, definition.index);
        file3.definitions.push(definition);
        definitionToFile.set(definition.name, file3.key);
      }
      const rebuildFileGraph = () => {
        const graph = /* @__PURE__ */ new Map();
        for (const [key, file3] of filesByKey) {
          const deps = /* @__PURE__ */ new Set();
          for (const definition of file3.definitions) {
            for (const dep of definition.dependencies) {
              const targetFile = definitionToFile.get(dep);
              if (targetFile && targetFile !== key) {
                deps.add(targetFile);
              }
            }
          }
          graph.set(key, deps);
        }
        return graph;
      };
      const mergeFiles = (target, sources) => {
        const targetFile = filesByKey.get(target);
        if (!targetFile) {
          return;
        }
        for (const sourceKey of sources) {
          if (sourceKey === target) {
            continue;
          }
          const sourceFile = filesByKey.get(sourceKey);
          if (!sourceFile) {
            continue;
          }
          for (const definition of sourceFile.definitions) {
            targetFile.definitions.push(definition);
            definitionToFile.set(definition.name, target);
          }
          targetFile.earliestIndex = Math.min(
            targetFile.earliestIndex,
            sourceFile.earliestIndex
          );
          filesByKey.delete(sourceKey);
        }
      };
      const computeStronglyConnectedComponents2 = (graph) => {
        let index = 0;
        const indices = /* @__PURE__ */ new Map();
        const lowlinks = /* @__PURE__ */ new Map();
        const stack = [];
        const onStack = /* @__PURE__ */ new Set();
        const components2 = [];
        const strongConnect = (node) => {
          indices.set(node, index);
          lowlinks.set(node, index);
          index++;
          stack.push(node);
          onStack.add(node);
          for (const dep of graph.get(node) ?? /* @__PURE__ */ new Set()) {
            if (!indices.has(dep)) {
              strongConnect(dep);
              lowlinks.set(
                node,
                Math.min(
                  lowlinks.get(node),
                  lowlinks.get(dep)
                )
              );
            } else if (onStack.has(dep)) {
              lowlinks.set(
                node,
                Math.min(
                  lowlinks.get(node),
                  indices.get(dep)
                )
              );
            }
          }
          if (lowlinks.get(node) === indices.get(node)) {
            const component = [];
            while (true) {
              const item = stack.pop();
              onStack.delete(item);
              component.push(item);
              if (item === node) {
                break;
              }
            }
            components2.push(component);
          }
        };
        for (const node of graph.keys()) {
          if (!indices.has(node)) {
            strongConnect(node);
          }
        }
        return components2;
      };
      let changed = true;
      while (changed) {
        changed = false;
        const graph = rebuildFileGraph();
        const components2 = computeStronglyConnectedComponents2(graph);
        for (const component of components2) {
          if (component.length <= 1) {
            continue;
          }
          changed = true;
          const [first3, ...rest] = component.sort();
          mergeFiles(first3, rest);
          break;
        }
      }
      for (const file3 of filesByKey.values()) {
        file3.definitions.sort((a, b) => a.index - b.index);
      }
      const chunkSize = 200;
      const dataFile = filesByKey.get("data");
      if (dataFile && dataFile.definitions.length > chunkSize) {
        filesByKey.delete("data");
        const chunks2 = Math.ceil(dataFile.definitions.length / chunkSize);
        for (let chunkIndex = 0; chunkIndex < chunks2; chunkIndex++) {
          const start4 = chunkIndex * chunkSize;
          const chunkDefinitions = dataFile.definitions.slice(
            start4,
            start4 + chunkSize
          );
          if (chunkDefinitions.length === 0) {
            continue;
          }
          const suffix = String(chunkIndex + 1).padStart(2, "0");
          const chunkKey = `data-${suffix}`;
          const chunkFilename = `${dataFile.filename}-${suffix}`;
          const chunkFile = {
            key: chunkKey,
            filename: chunkFilename,
            definitions: chunkDefinitions,
            earliestIndex: chunkDefinitions[0]?.index ?? dataFile.earliestIndex
          };
          filesByKey.set(chunkKey, chunkFile);
          for (const definition of chunkDefinitions) {
            definitionToFile.set(definition.name, chunkKey);
          }
        }
      }
      const orderedFiles = Array.from(filesByKey.values()).sort((a, b) => {
        if (a.earliestIndex !== b.earliestIndex) {
          return a.earliestIndex - b.earliestIndex;
        }
        return a.key.localeCompare(b.key);
      });
      const fileOrder = /* @__PURE__ */ new Map();
      orderedFiles.forEach((file3, index) => {
        fileOrder.set(file3.key, index);
      });
      const fileImports = /* @__PURE__ */ new Map();
      for (const file3 of orderedFiles) {
        const depMap = /* @__PURE__ */ new Map();
        for (const definition of file3.definitions) {
          for (const dep of definition.dependencies) {
            const depFileKey = definitionToFile.get(dep);
            if (!depFileKey || depFileKey === file3.key) {
              continue;
            }
            const set7 = depMap.get(depFileKey);
            if (set7) {
              set7.add(dep);
            } else {
              depMap.set(depFileKey, /* @__PURE__ */ new Set([dep]));
            }
          }
        }
        fileImports.set(file3.key, depMap);
      }
      const warningBlock = schemas.warnings.length > 0 ? schemas.warnings.join("\n") : void 0;
      const modelFiles = orderedFiles.map((file3, index) => {
        const imports = [];
        imports.push('import * as S from "effect/Schema"');
        const usesPrimitives = file3.definitions.some(
          (definition) => definition.source.includes("Primitives.")
        );
        if (usesPrimitives && schemas.hoists.length > 0) {
          imports.push('import * as Primitives from "../primitives"');
        }
        const dependencyMap = fileImports.get(file3.key);
        if (dependencyMap) {
          const entries2 = Array.from(dependencyMap.entries()).sort(
            ([a], [b]) => (fileOrder.get(a) ?? 0) - (fileOrder.get(b) ?? 0)
          );
          for (const [depFileKey, names] of entries2) {
            const depFile = filesByKey.get(depFileKey);
            if (!depFile || names.size === 0) {
              continue;
            }
            const sortedNames = Array.from(names).sort();
            imports.push(
              `import { ${sortedNames.join(", ")} } from "./${depFile.filename}"`
            );
          }
        }
        const body = file3.definitions.map((definition) => definition.source).join("\n\n");
        const sections = [];
        if (warningBlock && index === 0) {
          sections.push(warningBlock);
        }
        sections.push(imports.join("\n"));
        sections.push(body);
        const contents = sections.filter((section) => section.length > 0).join("\n\n");
        return {
          path: `models/${file3.filename}.ts`,
          contents
        };
      });
      const primitivesContent = schemas.hoists.length > 0 ? [
        'import * as S from "effect/Schema"',
        schemas.hoists.map(({ name: name2, expression }) => `export const ${name2} = ${expression}`).join("\n")
      ].join("\n\n") : void 0;
      const modelsIndexSections = orderedFiles.map(
        (file3) => `export * from "./${file3.filename}"`
      );
      if (schemas.aliases.length > 0) {
        for (const { alias, target } of schemas.aliases) {
          const targetFileKey = definitionToFile.get(target);
          if (!targetFileKey) {
            continue;
          }
          const targetFile = filesByKey.get(targetFileKey);
          if (!targetFile) {
            continue;
          }
          modelsIndexSections.push(
            `export { ${target} as ${alias} } from "./${targetFile.filename}"`
          );
        }
      }
      const modelsIndexContent = Array.from(new Set(modelsIndexSections)).join("\n");
      const modelsFacadeContent = `export * from "./models/index"`;
      const clientImports = [
        transformer.imports,
        `import * as ${schemaModuleName} from "./models"`
      ].join("\n");
      const clientImplementation = transformer.toImplementation(
        options3.name,
        operations,
        { schemaQualifier: `${schemaModuleName}.` }
      );
      const clientTypes = transformer.toTypes(options3.name, operations, {
        schemaQualifier: `${schemaModuleName}.`
      });
      const clientContent = [clientImports, clientImplementation, clientTypes].filter((_) => _.length > 0).join("\n\n");
      const indexLines = [
        `export * as ${schemaModuleName} from "./models"`,
        schemas.hoists.length > 0 ? `export * as ${primitivesModuleName} from "./primitives"` : void 0,
        'export * as Client from "./client"',
        'export * from "./models"',
        'export * from "./client"'
      ].filter((_) => _ !== void 0);
      const indexContent = indexLines.join("\n");
      const files = [
        ...modelFiles,
        { path: "models/index.ts", contents: modelsIndexContent },
        { path: "models.ts", contents: modelsFacadeContent },
        { path: "client.ts", contents: clientContent },
        { path: "index.ts", contents: indexContent }
      ];
      if (primitivesContent) {
        files.push({ path: "primitives.ts", contents: primitivesContent });
      }
      return files;
    },
    with_,
    (effect3, _, options3) => provide2(
      effect3,
      options3?.typeOnly ? layerTransformerTs2 : layerTransformerSchema2
    )
  );
  return { generate };
});
var OpenApi = class _OpenApi extends Tag3("OpenApi")() {
  static Live = effect(_OpenApi, make65);
};
var OpenApiTransformer = class extends Tag2("OpenApiTransformer")() {
};
var layerTransformerSchema2 = sync6(OpenApiTransformer, () => {
  const operationsToInterface = (name2, operations, options3) => {
    const qualifier = options3?.schemaQualifier ?? "";
    return `export interface ${name2} {
  readonly httpClient: HttpClient.HttpClient
  ${operations.map((op) => operationToMethod(name2, op, qualifier)).join("\n  ")}
}

${clientErrorSource(name2)}`;
  };
  const operationToMethod = (name2, operation, qualifier) => {
    const args2 = [];
    if (operation.pathIds.length > 0) {
      args2.push(...operation.pathIds.map((id2) => `${id2}: string`));
    }
    let options3 = [];
    if (operation.params && !operation.payload) {
      args2.push(
        `options${operation.paramsOptional ? "?" : ""}: typeof ${qualifier}${operation.params}.Encoded${operation.paramsOptional ? " | undefined" : ""}`
      );
    } else if (operation.params) {
      options3.push(
        `readonly params${operation.paramsOptional ? "?" : ""}: typeof ${qualifier}${operation.params}.Encoded${operation.paramsOptional ? " | undefined" : ""}`
      );
    }
    if (operation.payload) {
      const type2 = `typeof ${qualifier}${operation.payload}.Encoded`;
      if (!operation.params) {
        args2.push(`options: ${type2}`);
      } else {
        options3.push(`readonly payload: ${type2}`);
      }
    }
    if (options3.length > 0) {
      args2.push(`options: { ${options3.join("; ")} }`);
    }
    let success = "void";
    if (operation.successSchemas.size > 0) {
      success = Array.from(operation.successSchemas.values()).map((schema) => `typeof ${qualifier}${schema}.Type`).join(" | ");
    }
    const errors = ["HttpClientError.HttpClientError", "ParseError"];
    if (operation.errorSchemas.size > 0) {
      errors.push(
        ...Array.from(operation.errorSchemas.values()).map(
          (schema) => `${name2}Error<"${schema}", typeof ${qualifier}${schema}.Type>`
        )
      );
    }
    return `${toComment(operation.description)}readonly "${operation.id}": (${args2.join(", ")}) => Effect.Effect<${success}, ${errors.join(" | ")}>`;
  };
  const operationsToImpl = (name2, operations, options3) => {
    const qualifier = options3?.schemaQualifier ?? "";
    return `export const make = (
  httpClient: HttpClient.HttpClient, 
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): ${name2} => {
  ${commonSource}
  const decodeSuccess =
    <A, I, R>(schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) => {
      return HttpClientResponse.schemaBodyJson(schema)(response) as unknown as Effect.Effect<
        A,
        any,
        never
      >
    }
  const decodeError =
    <const Tag extends string, A, I, R>(tag: Tag, schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) => {
      return Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(${name2}Error(tag, cause, response)),
      ) as unknown as Effect.Effect<
        A,
        any,
        never
      >
    }
  return {
    httpClient,
    ${operations.map((operation) => operationToImpl(operation, qualifier)).join(",\n  ")}
  }
}`;
  };
  const operationToImpl = (operation, qualifier) => {
    const args2 = [...operation.pathIds];
    const hasOptions = operation.params || operation.payload;
    if (hasOptions) {
      args2.push("options");
    }
    const params = `${args2.join(", ")}`;
    const pipeline = [];
    if (operation.params) {
      const varName = operation.payload ? "options.params?." : "options?.";
      if (operation.urlParams.length > 0) {
        const props = operation.urlParams.map(
          (param) => `"${param}": ${varName}["${param}"] as any`
        );
        pipeline.push(`HttpClientRequest.setUrlParams({ ${props.join(", ")} })`);
      }
      if (operation.headers.length > 0) {
        const props = operation.headers.map(
          (param) => `"${param}": ${varName}["${param}"] ?? undefined`
        );
        pipeline.push(`HttpClientRequest.setHeaders({ ${props.join(", ")} })`);
      }
    }
    const payloadVarName = operation.params ? "options.payload" : "options";
    if (operation.payloadFormData) {
      pipeline.push(
        `HttpClientRequest.bodyFormDataRecord(${payloadVarName} as any)`
      );
    } else if (operation.payload) {
      pipeline.push(`HttpClientRequest.bodyUnsafeJson(${payloadVarName})`);
    }
    const decodes = [];
    const singleSuccessCode = operation.successSchemas.size === 1;
    operation.successSchemas.forEach((schema, status2) => {
      const statusCode = singleSuccessCode && status2.startsWith("2") ? "2xx" : status2;
      decodes.push(`"${statusCode}": decodeSuccess(${qualifier}${schema})`);
    });
    operation.errorSchemas.forEach((schema, status2) => {
      decodes.push(
        `"${status2}": decodeError("${schema}", ${qualifier}${schema})`
      );
    });
    operation.voidSchemas.forEach((status2) => {
      decodes.push(`"${status2}": () => Effect.void`);
    });
    decodes.push(`orElse: unexpectedStatus`);
    pipeline.push(`withResponse(HttpClientResponse.matchStatus({
      ${decodes.join(",\n      ")}
    }))`);
    return `"${operation.id}": (${params}) => HttpClientRequest.${httpClientMethodNames[operation.method]}(${operation.pathTemplate}).pipe(
    ${pipeline.join(",\n    ")}
  )`;
  };
  return OpenApiTransformer.of({
    imports: [
      'import type * as HttpClient from "@effect/platform/HttpClient"',
      'import * as HttpClientError from "@effect/platform/HttpClientError"',
      'import * as HttpClientRequest from "@effect/platform/HttpClientRequest"',
      'import * as HttpClientResponse from "@effect/platform/HttpClientResponse"',
      'import * as Data from "effect/Data"',
      'import * as Effect from "effect/Effect"',
      'import type { ParseError } from "effect/ParseResult"',
      'import * as S from "effect/Schema"'
    ].join("\n"),
    toTypes: operationsToInterface,
    toImplementation: operationsToImpl
  });
}).pipe(merge7(layerTransformerSchema));
var layerTransformerTs2 = sync6(OpenApiTransformer, () => {
  const operationsToInterface = (name2, operations) => `export interface ${name2} {
  readonly httpClient: HttpClient.HttpClient
  ${operations.map((s) => operationToMethod(name2, s)).join("\n  ")}
}

${clientErrorSource(name2)}`;
  const operationToMethod = (name2, operation) => {
    const args2 = [];
    if (operation.pathIds.length > 0) {
      args2.push(...operation.pathIds.map((id2) => `${id2}: string`));
    }
    let options3 = [];
    if (operation.params && !operation.payload) {
      args2.push(
        `options${operation.paramsOptional ? "?" : ""}: ${operation.params}${operation.paramsOptional ? " | undefined" : ""}`
      );
    } else if (operation.params) {
      options3.push(
        `readonly params${operation.paramsOptional ? "?" : ""}: ${operation.params}${operation.paramsOptional ? " | undefined" : ""}`
      );
    }
    if (operation.payload) {
      const type2 = operation.payload;
      if (!operation.params) {
        args2.push(`options: ${type2}`);
      } else {
        options3.push(`readonly payload: ${type2}`);
      }
    }
    if (options3.length > 0) {
      args2.push(`options: { ${options3.join("; ")} }`);
    }
    let success = "void";
    if (operation.successSchemas.size > 0) {
      success = Array.from(operation.successSchemas.values()).join(" | ");
    }
    const errors = ["HttpClientError.HttpClientError"];
    if (operation.errorSchemas.size > 0) {
      for (const schema of operation.errorSchemas.values()) {
        errors.push(`${name2}Error<"${schema}", ${schema}>`);
      }
    }
    return `${toComment(operation.description)}readonly "${operation.id}": (${args2.join(", ")}) => Effect.Effect<${success}, ${errors.join(" | ")}>`;
  };
  const operationsToImpl = (name2, operations) => `export const make = (
  httpClient: HttpClient.HttpClient, 
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): ${name2} => {
  ${commonSource}
  const decodeSuccess = <A>(response: HttpClientResponse.HttpClientResponse) =>
    response.json as Effect.Effect<A, HttpClientError.ResponseError>
  const decodeVoid = (_response: HttpClientResponse.HttpClientResponse) =>
    Effect.void
  const decodeError =
    <Tag extends string, E>(tag: Tag) =>
    (
      response: HttpClientResponse.HttpClientResponse,
    ): Effect.Effect<
      never,
      ${name2}Error<Tag, E> | HttpClientError.ResponseError
    > =>
      Effect.flatMap(
        response.json as Effect.Effect<E, HttpClientError.ResponseError>,
        (cause) => Effect.fail(${name2}Error(tag, cause, response)),
      )
  const onRequest = (
    successCodes: ReadonlyArray<string>,
    errorCodes?: Record<string, string>,
  ) => {
    const cases: any = { orElse: unexpectedStatus }
    for (const code of successCodes) {
      cases[code] = decodeSuccess
    }
    if (errorCodes) {
      for (const [code, tag] of Object.entries(errorCodes)) {
        cases[code] = decodeError(tag)
      }
    }
    if (successCodes.length === 0) {
      cases["2xx"] = decodeVoid
    }
    return withResponse(HttpClientResponse.matchStatus(cases) as any)
  }
  return {
    httpClient,
    ${operations.map(operationToImpl).join(",\n  ")}
  }
}`;
  const operationToImpl = (operation) => {
    const args2 = [...operation.pathIds];
    const hasOptions = operation.params || operation.payload;
    if (hasOptions) {
      args2.push("options");
    }
    const params = `${args2.join(", ")}`;
    const pipeline = [];
    if (operation.params) {
      const varName = operation.payload ? "options.params?." : "options?.";
      if (operation.urlParams.length > 0) {
        const props = operation.urlParams.map(
          (param) => `"${param}": ${varName}["${param}"] as any`
        );
        pipeline.push(`HttpClientRequest.setUrlParams({ ${props.join(", ")} })`);
      }
      if (operation.headers.length > 0) {
        const props = operation.headers.map(
          (param) => `"${param}": ${varName}["${param}"] ?? undefined`
        );
        pipeline.push(`HttpClientRequest.setHeaders({ ${props.join(", ")} })`);
      }
    }
    const payloadVarName = operation.params ? "options.payload" : "options";
    if (operation.payloadFormData) {
      pipeline.push(
        `HttpClientRequest.bodyFormDataRecord(${payloadVarName} as any)`
      );
    } else if (operation.payload) {
      pipeline.push(`HttpClientRequest.bodyUnsafeJson(${payloadVarName})`);
    }
    const successCodesRaw = Array.from(operation.successSchemas.keys());
    const successCodes = successCodesRaw.map((_) => JSON.stringify(_)).join(", ");
    const singleSuccessCode = successCodesRaw.length === 1 && successCodesRaw[0].startsWith("2");
    const errorCodes = operation.errorSchemas.size > 0 && Object.fromEntries(operation.errorSchemas.entries());
    pipeline.push(
      `onRequest([${singleSuccessCode ? `"2xx"` : successCodes}]${errorCodes ? `, ${JSON.stringify(errorCodes)}` : ""})`
    );
    return `"${operation.id}": (${params}) => HttpClientRequest.${httpClientMethodNames[operation.method]}(${operation.pathTemplate}).pipe(
    ${pipeline.join(",\n    ")}
  )`;
  };
  return OpenApiTransformer.of({
    imports: [
      'import type * as HttpClient from "@effect/platform/HttpClient"',
      'import * as HttpClientError from "@effect/platform/HttpClientError"',
      'import * as HttpClientRequest from "@effect/platform/HttpClientRequest"',
      'import * as HttpClientResponse from "@effect/platform/HttpClientResponse"',
      'import * as Data from "effect/Data"',
      'import * as Effect from "effect/Effect"'
    ].join("\n"),
    toTypes: operationsToInterface,
    toImplementation: operationsToImpl
  });
}).pipe(merge7(layerTransformerTs));
var processPath = (path2) => {
  const ids3 = [];
  path2 = path2.replace(/{([^}]+)}/g, (_, name2) => {
    const id2 = camelize(name2);
    ids3.push(id2);
    return "${" + id2 + "}";
  });
  return { path: "`" + path2 + "`", ids: ids3 };
};
var commonSource = `const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse = <A, E, R = never>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E, R>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ): Effect.Effect<A, E, R> => {
    if (options.transformClient) {
      return Effect.flatMap(
        Effect.flatMap(options.transformClient!(httpClient), (client) =>
          client.execute(request),
        ),
        f,
      ) as unknown as Effect.Effect<A, E, R>
    }
    return Effect.flatMap(httpClient.execute(request), f) as unknown as Effect.Effect<A, E, R>
  };`;
var clientErrorSource = (name2) => `export interface ${name2}Error<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class ${name2}ErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const ${name2}Error = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): ${name2}Error<Tag, E> =>
  new ${name2}ErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any`;

// src/main.ts
var spec = fileParse2("spec").pipe(
  withAlias2("s"),
  withDescription3("The OpenAPI spec file to generate the client from")
);
var name = text8("name").pipe(
  withAlias2("n"),
  withDescription3("The name of the generated client"),
  withDefault3("Client")
);
var typeOnly = boolean5("type-only").pipe(
  withAlias2("t"),
  withDescription3("Generate a type-only client without schemas")
);
var out = text8("out").pipe(
  withAlias2("o"),
  withDescription3("Directory to write generated files")
);
var root = make63("openapigen", { spec, typeOnly, name, out }).pipe(
  withHandler2(
    ({ spec: spec2, typeOnly: typeOnly2, name: name2, out: out2 }) => OpenApi.generate(spec2, { name: name2, typeOnly: typeOnly2 }).pipe(
      flatMap9(
        (files) => flatMap9(
          tryPromise2(() => Fs__namespace.mkdir(out2, { recursive: true })),
          () => forEach8(files, (file3) => {
            const targetPath = Path3__namespace.join(out2, file3.path);
            return flatMap9(
              tryPromise2(
                () => Fs__namespace.mkdir(Path3__namespace.dirname(targetPath), { recursive: true })
              ),
              () => tryPromise2(
                () => Fs__namespace.writeFile(
                  targetPath,
                  file3.contents.endsWith("\n") ? file3.contents : `${file3.contents}
`
                )
              )
            );
          })
        )
      )
    )
  )
);
var run9 = run8(root, {
  name: "openapigen",
  version: "0.0.0"
});
var Env = mergeAll4(
  layer12,
  OpenApi.Live,
  layer13({
    showBuiltIns: false
  })
);
run9(process.argv).pipe(provide2(Env), runMain3);
